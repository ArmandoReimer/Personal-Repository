% plt.m:   An alternative to plot & plotyy
% Author:  Paul Mennen (paul@mennen.org)
%          Copyright (c) 2020, Paul Mennen

%define
PLTversion = '03Jan20';
%end_define

%include
  pltcase;   % switch/case strings
  pltdef;    % index definitions
  abrev;     % graphic property abreviations
%end_include

function [Ret1,Ret2] = plt(varargin);

%dbstop if error;
global Hhcpy;     % hcpy handles

Ret1 = 0;  % Compiler wants this for some reason
Narg = nargin;
Mver = version;  Mver = sscanf(Mver(1:3),'%f');
MverE = (Mver<8.4); % True for "Early" Matlab versions (R2014a or earlier) using old graphics engine
                    % False for "Late" Matlab versions (R2014b or later) using new graphics engine

if ~Narg % if no arguments, user picks variables interactively
  eval('evalin(''base'',''pltdef'','''')'); % read in plt select defaults from pltdef.m
  w = plt('select','base','who');  % w = evalin('base','who');
  n = length(w);  b = zeros(1,n);  % create list of workspace variables
  options = [];       % will contain options defined by pltopt variables
  wstruct = {}; ws=0; % will contain numeric fields inside structures
  TraceIDlength = 7;  % default # of characters in Trace ID (workspace plotter only)
  for k=1:n
    a = plt('select','base',w{k});  % a = evalin('base',w{k});
    if length(w{k})>5 & findstr(w{k},'pltopt') options = [options a]; end;
    if strcmp(w{k},'TraceIDlen') TraceIDlength = a;  end;
    if isnumeric(a) & length(a)>3 b(k)=1; % remove strings, scalers & very short vectors
    elseif isstruct(a) & numel(a)==1 % skip arrays of structures for now
      f = fieldnames(a);
      for fn=1:length(f)
        g = getfield(a,f{fn});
        if isnumeric(g) & length(g)>3 ws=ws+1; wstruct{ws} = [w{k} '.' f{fn}]; end;
      end;
    end;
  end;
  w = [w(logical(b)); wstruct'];  nov = length(w);
  if nov<2 disp('Not enough vectors to plot'); return; end;
  spix = get(0,'screenp');
  fontsz = (196-spix)/10; % choose font appropriate to screen res
  spix = spix/80 - .2;  % 1 for normal fonts, 1.25 for large fonts
  vspace = round(20 * spix);  % vertical spacing between entries
  hspace = round(200 * spix); % horizontal spacing between entries
  set(0,PIXELS);  ssz = get(0,'screensize'); % get screen size in pixels
  nc = fix((ssz(4)-110)/(vspace+.2));      % max entries per column
  nov1 = nov+3;  nc = ceil(nov1/nc);       % number of columns
  nr = ceil(nov1/nc);                      % number of rows
  wid = nc*hspace+20; hei = nr*vspace+55;  % figure width/height
  % create figure to display base workspace variables
  fig = figure(NoMENU,'name','PLT select',COLOR,'black','Invert','on',...
               POS,figpos([inf inf wid hei]));
  axes(XLIM,[0 nc],YLIM,[0 nr+1]-.5,POS,[.02/nc 0 1 1],...
       COLOR,'black',XCOLOR,'black',YCOLOR,'black');
  hb = hei-25;
  set([BUTTON('Plot',    POS,[ 25 hb 40 21],CALLBK,'plt select plot;');
       BUTTON('CloseAll',POS,[ 80 hb 60 21],CALLBK,'plt close;');
       BUTTON('Help',    POS,[155 hb 40 21],CALLBK,SHOWhelp);
      ],NORMAL,FONTSIZE,fontsz);
  text(.05,nr-2.2,{'Right click on desired x vectors';
                   'Left click on desired y vectors';
                   'Double click for right hand axis'},...
                   ITALIC,FONTSIZE,9,COLOR,[0 1 .5]);
  txt = zeros(nov,1); sz1=txt; sz2=txt; len=txt; nvec=txt; sxy=txt; yright=txt;
  y=nr-3; x=0;
  for k=1:nov % create a text object in the figure for each workspace variable
    y = y-1;  if y<0 y=nr-1; x=x+1;  end;
    sz = size(plt('select','base',w{k}));
    sz1(k)  = sz(1);  % save variable size as part of state matrix
    sz2(k)  = sz(2);
    len(k)  = max(sz);
    nvec(k) = min(sz);
    txt(k) = text(x,y,' ');  % we will fill in the strings later (plt select text)
    set(txt(k),MOUSE,['plt(''select'',' int2str(k) ');']);
  end;
  set(fig,USER,[txt sz1 sz2 len nvec sxy yright]); % save state matrix
  setappdata(fig,'w',w);                           % save variable names
  setappdata(fig,'opt',options);                   % save plt options
  setappdata(fig,'IDlen',TraceIDlength);           % save trace ID length
  plt select text;                                 % set text & colors
  return;
end;

y1 = varargin{1}; 
if length(y1)==1 & ishandle(y1)
  y2 = varargin{2};
  if isempty(y2) | ~isnumeric(y2)   % if from callback
    hcback = y1;                    % save handle (maybe not needed?)
    varargin(1:2)=[]; Narg=Narg-2;  % remove 1st two arguments
    y1 = varargin{1};
  end;
end;
if ~ischar(y1)  y1='none'; end;
y1 = lower(y1); y1s = sum(y1);
if y1s==rename_ & y1(1)~='r' y1s=0; end; % rename and labelx collide
switch y1s
case select_
  v2 = varargin{2};
  if isnumeric(v2) | v2(1) ~= 'b'
      w = getappdata(gcf,'w');  e = get(gcf,USER);  % get variable names & state matrix
      len = e(:,SVlen); sxy = e(:,SVsxy); nov = length(len);
      xk = []; for k=1:nov if sxy(k)<0 xk = [xk k]; end; end; % list of x vector indices
  end;
  switch sum(v2)
    case base_, Ret1 = eval(['evalin(''base'',''' varargin{3} ''');']);
    case text_,
      lnxk = length(xk);
      for k=1:nov
        s = w{k};  if length(s)>20 s=s(1:20); end;  % use first 20 characters of variable name
        s = strrep(s,'_','\_'); % we don't want underscore to mean subscript
        s = [s '  (' int2str(e(k,SVsz1)) ',' int2str(e(k,SVsz2)) ')'];
        if sxy(k) s = [s ' \leftarrow ']; s2 = int2str(abs(sxy(k)));  end;
        %      color          Usage
        % ----------------    ------------------------------------------------
        % Grey   [.5 .5 .5.]  Can't be selected (because it's the wrong size)
        % White  [ 1  1  1]   It's the right size, so it can be selected
        % Red    [.9 .3  .3]  Currently selected as one of the x vectors
        % Yellow [ 1  1   0]  Currently selected as one of the y vectors
        % Orange [ 1 .6  .2]  The y vector to be ploted on the right hand axis
        %
        %  sxy      Usage
        % -----     ------------------------------------------
        %   0       This variable is not selected for plotting
        %  <0       This variable is to be plotted on the x axis
        %  >0       This variable is to be plotted on the y axis.
        %           e.g. if sxy=2, the variable is plotted on the y axis
        %           verses the x variable identified with sxy=-2
        %           the variable with sxy = -sxy;
        c = [1 1 1];  % default color = white (you can click on it)
        if lnxk % here if at least one x vector has been selected
          if lnxk==1 s2 = ''; end; % don't need extra identifier if only one x vector
          if ~sxy(k)
            if ~length(find(len(xk)==len(k))) c = .5*c; end; % grey out if this can't be a y vector
          elseif sxy(k)<0                 c = [.9 .3 .3]; s = [s 'x' s2];      % red
          else % here if sxy(k)>0
            if e(k,SVright)               c = [ 1 .6 .2]; s = [s 'y' s2 'R'];  % orange
                      else                c = [ 1  1  0]; s = [s 'y' s2];      % yellow
                      end;
          end;
        else if e(k,SVnvec) ~= 1 c = .5*c; end; % grey out if this can't be a x vector
        end;
        if c(3)==.5 | c(3)==1 bold = 'norm'; else bold = 'bold';  end;
        set(e(k,SVtxt),COLOR,c,'fontw',bold,STR,s);
      end; % end if for k=1:nov
    case plot_
      if ~max(sxy) return; end; % nothing to plot
      options       = getappdata(gcf,'opt');
      TraceIDlength = getappdata(gcf,'IDlen');
      opt = [];
      for k=1:length(options)  % build options string
        t = options{k};
        if   isnumeric(t) v = num2str(t);
             if length(t)>1
               q = v;  v = '[';
               for j=1:size(q,1) v = [v q(j,:) ';']; end;
               v = [v ']'];
             end;
        else v = ['''''' t ''''''];
        end;
        opt = [opt v ','];
      end;
      if length(xk)==1 x = w{find(sxy<0)}; else x = 'X axis'; end;
      right = [];                                 % list of traces for right hand axis
      ny = 0;                                     % count number of y traces
      nvL = 0; nvR = 0;                           % count number of variables to plot on left & right axes
      func = ['plt(''''LabelX'''',''''' x ''''','];
      id = '''''TraceID'''',[''''';
      for k=1:nov                                 % search thru all variables
        if sxy(k)>0                               % only do anything for the selected y variables
          nvec = e(k,SVnvec);                     % number of traces for this variable
          x = w{find(sxy==-sxy(k))};  y = w{k};   % find the x/y variable names
          s2 = strrep(y,'_','\_');                % potentially used for LabelY or LabelYR
          ss = strrep(y,'_','');                  % don't include underscores in trace IDs
          nn = TraceIDlength - (nvec>1);  s = []; % need a trace ID of TraceIDlength characters
          if length(ss) > nn                      % here if there are two many characters in the TraceID
            sp = findstr(ss,'.');
            if length(sp)                         % here for structures
              nn1 = min(sp-1,floor((nn-1)/2));    % use no more than half the chars for the struc name
              nn2 = min(nn-nn1-1,length(ss)-sp);  % number of characters for the field name
              nn1 = nn - nn2 - 1;                 % number of characters for the struc name
              ss = ss([1:nn1-1 sp-1:sp+nn2-1 end]); % use last character of both struc & field names
              % ss = [ss(1:nn1-1) ss(sp-1) '.' ss(sp+1:sp+nn2-1) ss(end)];  % equivalent to above
            else                                  % here if not a structure
              ss = [ss(1:nn-1) ss(end)];          % make sure we use the last character
            end;
          end;
          while length(ss)<nn ss = [ss ' ']; end; % pad with blanks if too short
          st = ss;
          for v = 1:nvec                          % can have multiple traces in one variable
            if nvec>1 ss=[st '0'+mod(v,10)]; end; % only works well for up to 10
            s = [s ss ''''';'''''];               % append the trace ID to the list
          end;
          if e(k,SVright) right = [right ny+(1:nvec)]; s2R=s2; nvR=nvR+1; else s2L=s2; nvL=nvL+1; end;
          ny = ny + nvec;                         % count the traces
          func = [func x ',' y ','];
          id = [id s];
        end;  % end if sxy(k)>0
      end;    % end for k=1:nov
      if nvL==1 func = [func '''''LabelY'''','''''  s2L ''''',']; end;
      if nvR==1 func = [func '''''LabelYr'''',''''' s2R ''''',']; end;
      if nvR>0  func = [func '''''Right'''',' prin('[{%d }]',right) ',']; end;
      if ny>1 func = [func id(1:end-3) '],']; end;
      func = [func opt '''''+'''',2);'];          % append other options, end with '+',2
      plt('select','base',func);                  % finally, go plot it
    otherwise, % here if user clicked on one of the workspace variable text objects
      click = MouseType;  sk = sxy(v2);
      if click==alt_ | ~length(xk)                % right click (select x vector)
        if sk>=0
             if e(v2,SVnvec)==1 e(v2,SVsxy) = min(sxy)-1; end; % select this as a new x vector
        else e(v2,SVsxy) = 0;                     % remove this as a x vector
             e(find(sxy==-sk),SVsxy)=0;           % remove all y vectors associated with it
        end;
      elseif sk>=0                                % single or double left click (select y vector)
        if click==open_ & sk sk = 0; end;         % double click
        xki = sort(-sxy(xk(find(len(xk)==len(v2))))); % possible x vectors
        if length(xki)
          if sk m = find(xki==sk)+1;              % already selected - move on the the next possible
                if m>length(xki) sk=0; e(v2,SVright)=0; else sk=xki(m);  end;
          else  sk = xki(1);                      % not selected - pick the first possible x vector
          end;
          e(v2,SVsxy) = sk;                       % insert it into the state matrix
          if click==open_ & sk e(v2,SVright)=1; end;  % double click - assign it to the right hand trace
        end;
      end;
      set(gcf,USER,e);                            % save new state matrix
      plt('select','text');                       % set text & colors
  end;  % end switch(v2)
% end case 'select'

case metricp_
% function [Ret1,Ret2] = plt('metricp',x)
% Converts a number to a form using the standard metric prefixes.
%    x    : The value to be converted
%    Ret1 : The metric prefix which applies to the new value
%    Ret2 : Multiplier (new value to display is x*Ret2)
    x = varargin{2};
    m=0;  nv=x;   % m will be multiplier index, nv will be new value
    if ~x Ret1=''; Ret2=1; return; end;
    while nv>900  m=m+1;  nv=.001*nv; end;
    while nv<.9   m=m-1;  nv=1000*nv; end;
    if (m==1 & x<10000) | (m==-1 & x>=.1 ) m=0; nv=x; end;
    Ret2 = nv/x;
    if     m>5  Ret1 = Pftoa('%4w',1/Ret2);
    elseif m<-6 Ret1 = Pftoa('%5w',1/Ret2);
    else        qs=reshape('Atto FemtoPico Nano MicroMilli     Kilo Mega Giga Tera Peta ',5,12)';
                Ret1 = deblank(qs(m+7,:));
    end;
    if length(Ret1) Ret1 = [Ret1 '-']; end;
% end case 'metricp'

case datestr_
% plt('datestr',datenum,fmt) is a more accurate version of datestr(datenum,fmt)
% - milliseconds instead of seconds.
  c = datevec(varargin{2});
  if isempty(c) | isnan(c(1)) Ret1 = []; return; end;
  frac = sprintf('%4.3f',mod(c(6),1));
  c(6) = floor(c(6));
  if strcmp(frac,'1.000')  % deal with sprintf rounding (note that the "1" gets lost)
    if c(6)==59 frac = '0.999'; else c(6) = c(6)+1;  end;
  end;
  % note that 01:02:59.9996 improperly gets rounded down to 01:02:59.999
  % - an error that will occur 8.333 times with a million random dates.
  if Mver < 7 % slightly less general method needed with Matlab 6
       if Narg<3 fmt=0; else fmt=varargin{3}; end;  % If fmt not specified, 0 is assumed.
       Ret1 = [datestr(datenum(c),fmt) frac(2:end)];
       if strcmp(Ret1(7:9),'-20') Ret1(8:9) = []; end; % change dd-mon-20yy to dd-mon-yy
  else
       if Narg<3 fmt = 'dd-mmm-yy HH:MM:SS'; % use this format if fmt is not included
                                             % note that the default is different than fmt=0
       else      fmt = varargin{3};
       end;
       Ret1 = datestr(datenum(c),fmt);
       p = findstr(':',Ret1);
       if length(p) ~= 2 return; end;
       p = p(2);
       Ret1 = [Ret1(1:p+2) frac(2:end) Ret1(p+3:end)];
  end;
% end case 'datestr'

case help_
  if Narg==1        f = '';
  elseif MouseRight f = get(gcbo,TAG);              % right click on Help tag
  else              f = get(gcbo,USER);             % left click on Help tag
  end;
  tp = '';                                          % assume no chm topic specifier
  if exist('tp')                                    % here if running from matlab
    if length(f)                                    % here if the help file was specified
      if isempty(findstr(f,'.')) eval(f); return; end;  % if no extension, evaluate it
      dd = findstr(f,'::');                         % is there a chm file topic path?
      if length(dd) tp=f(dd:end); f=f(1:dd-1); end; % save topic specifier in tp and remove from f
      if isempty(findstr(f,filesep))
        f = feval('which',f);                       % search for it if the path was not included
      end;
      if ~exist(f) f = ''; end;
    end;
    if isempty(f)                                   % here if the help file wasn't specified or found
      fc = feval('which','plt.chm'); nc=length(fc); % search for help files
      fh = feval('which','plt.htm'); nh=length(fh); % use feval to prevent compiler warning
      if (nc+nh)==0
         na = get(gcf,'name'); % if plt.chm & plt.htm not found, look for application specific help file
         fc = feval('which',[na '.chm']);  nc=length(fc);
         fh = feval('which',[na '.htm']);  nh=length(fh);
         if ~nh fh = feval('which',[na '.pdf']);  nh=length(fh); end;
         if (nc+nh)==0 disp(['No plt or ' na ' help files were found']); return; end;
      end;
      if ispc if nc f=fc; else f=fh; end;           % for PCs  give priority to chm file
      else    if nh f=fh; else f=fc; end;           % for unix give priority to htm file
      end;
    end;
    if ispc & strcmpi(f(end-2:end),'chm')
         dos(['hh ' f tp ' &']);                    % for chm files on a pc, call hh.exe
    else feval('web',['file:///' f ],'-browser');   % otherwise open with the browser
    end;
  else                                              % here for compiled code
    if isempty(f) f = 'plt.chm'; end;
    if isempty(findstr(f,filesep)) f = fullfile(fileparts(GetExe),f); end;
    if ~exist(f) return; end;
    if strcmpi(f(end-2:end),'chm') dos(['hh ' f ' &']); else ibrowse(f); end;
  end;
% end case 'help'

case helptext_                                              % operates on the current axis
  if Narg>1 a = varargin{2}; else a = 'off'; end;
  s = getappdata(gca,'helptext'); n = length(s);            % get helptext argument and length
  if ~n & Narg<3
    e = findobj(gcf,'type','axes','tag','click')';
    for k=e  s=getappdata(k,'helptext'); n=length(s);
             if n axes(k); break; end;
    end;
    if ~n return; end;
  end;
  ht = findobj(gca,USER,355/113);                           % find help text
  if a(1)=='t' Ret1 = ht; return; end;                      % "text" command
  if a(1)=='g' Ret1 = s; return; end;                       % "get" command
  if a(2)=='f' | length(ht) delete(ht); return; end;        % "off": remove all help text
  if Narg>2                                                 % everything else is assumed to be the "on" command
    if n plt('helptext'); end;                              % on command can include new help text
    s = varargin{3};  n = length(s);                        % if it does, delete the old help text and then
    setappdata(gca,'helptext',s);                           % create the new helptext object
    if a(1)=='s' return; end;                               % The set command doesn't turn the help text on.
  end;
  if ~n return; end;                                        % "on" command: nothing to do if no help text defined
  if ~iscell(s) s = {s}; n=1; end;
  a = find(~cellfun('isreal',s));
  if length(a) a = [a n+1];
  else         s = [s {.03+.96i}];  a = n+[1 2];
  end;
  p = 1;  btn = get(gca,MOUSE);  props = {};
  for k=1:2:length(a)                                       % loop thru all helptext strings
    p1 = a(k);  p2 = a(k+1);  pos = s{p1};  props = [props s(p1+1:p2-1)];
    h = text(real(pos),imag(pos),s(p:p1-1),NORMAL,'fontsize',12,...
             'color',[1 .6 0],'vert','top',USER,355/113,MOUSE,btn);
    for m=1:2:length(props) r=props{m}; v=props{m+1}; if strcmpi(r,'color') v=ctrip(v); end; set(h,r,v); end;
    if p2<length(s) & imag(s{p2})>0 props = {}; end;
    p = p2+1;  % point to the start of the next helptext string
  end;
% end case 'helptext'

case image_
  h = varargin{2};
  if ischar(h)
    img = findobj(gcf,TAG,['img' h]);
    cmd = varargin{3};
    switch lower(cmd(1))
    case 'i',   % here for image cursor callback ('plt image N Icur;')
      [xy k] = plt('cursor',0,'get');           % xy contains the location of the mouse click (real/imag)
      xcur = real(xy);  ycur = imag(xy);
      z = get(img,'Cdata');  y = get(img,'y');  % get the intensity data from the plot
      [v m] = min(abs(y-ycur));                 % find closest region in the intensity map
      plt('cursor',0,'updateN',k,xcur,y(m));    % "snap to" the center of that region
      if k > size(z,2) za = ''; else za = prin('Z = %6w',z(m,k)); end;
      set(findobj(gca,TAG,'zstr'),'str',za);    % update the Z cursor readout
      ob = plt('cursor',0,'obj');  set(ob([4 6]),'vis','off');   % for julia.m
    case 's'    % here for edge/mid slider callbacks ('plt image N Slider;')
      zstat = get(img,USER);
      r = findobj(gcf,TAG,['edge' h]); % compute range of data to display (in standard deviations)
      if length(r) r = plt('slider',r); else r=0; end;
      if ~r clim = zstat(3:4);  if ~diff(clim) clim = clim + [-1 1]; end;
      else
        r = r*zstat(2); if isnan(r) | r==0 r = .01; end;
        m = findobj(gcf,TAG,['mid' h]);  % compute mid-point of data to display (in standard deviations)
        if length(m) m = plt('slider',m); else m=0; end;
        m = m*zstat(2) + zstat(1);  if isnan(m) m=0; end;
        clim = m + [-r r];
      end;
      set(get(img,'parent'),'Clim',clim); % set the axis Clim property
    case 'c'   % here for colorbar callback ('plt image N Cbar;')
      if MverE c = findobj(gcf,TAG,'cbar'); % early versions only allow one colormap
      else     c = findobj(gcf,'buttond',['plt image ' h ' cbar;']);
      end;
      if isempty(c) return; end;
      if nargin>3 u = varargin{4}; if ischar(u) u = s2d(u); end; % colormat choice specified in call
      else        u = get(c(1),USER) + 2*(MouseLeft) - 1;        % rotate colormap forward or back
      end;
      n = '';
      if exist('n') u = mod(u,10); else u = mod(u,5); end;      % mod 5 for compiled version
      u = mod(u,10);  set(c,USER,u);
      switch(u)
        case 0,  s = 'jet';                     % one of the standard colormaps defined by Matlab
        case 1,  n = 'Rainbow';                 % blue via green to red
                 t = 1/21.0000001; t2 = t/2;  
                 a = ones(1,22);  b = ones(1,21);  d = t2:t:1;
                 s = [[0*b;d;b] [d;b;1-t2:-t:0] [a;1:-t:0; 0*a]]';
        case 2,  n = 'Sometric';                % Interp(DkGreen,Green,Yellow,Gold,Brown,Wheat)
                 s = [0 4 0; 5 7 3; 10 9 0; 8 6 10; 5 2 1; 10 10 9];
                 s = round(interp1(linspace(1,64,6),s*100,1:64))/1000;
        case 3,  n = 'Seismic';                 % dark blue via white to dark red
                 t = ones(1,22);  b = 0*t; w = (0:21)/22;  s = [b w 1]; f = fliplr(w);
                 b = [f b];  s = [s t f; s b; w t 1 b]';  s = s((1:64)+12,:);
        case 4,  s = 'gray';
        case 5,  s = 'colorcube';
        case 6,  s = 'lines';
        case 7,  s = 'hot';
        case 8,  s = 'cool';
        case 9,  s = 'winter';
      end;
      if isempty(n) n=s; end;
      colormap(get(img,PARENT),s);  if ~MverE colormap(get(c,PARENT),s); end;
      for k=1:length(c)
        t = findobj(get(c(k),'parent'),'type','text'); % identify the colormap in use with a
        set(t,STR,n);                                  % rotated label above the colorbar
      end;
    case 'v'  % here for view all button callback ('plt image N view')
      ax = get(img,PARENT);
      if MouseLeft ilim = getappdata(ax,'ilim');  ilim = ilim(1:4);
      else         xl = get(ax,'xlim');  yl = get(ax,'ylim');  % zoom in 15% (if Zout tag is missing)
                   zo = findobj(gcf,STR,'Zout')';
                   cid = get(gca,USER);                     % if the Zout tag is there, then
                   for k = zo  b = get(k,MOUSE);            % the right click redefines the image default limits
                               if b{3}==cid setappdata(ax,'ilim',[xl yl]); return; end;
                   end;
                   ilim = .15*[1 -1]; ilim = [xl+diff(xl)*ilim  yl+diff(yl)*ilim];
      end;
      plt('cursor',get(ax,USER),'xylim',ilim);
    end;  % end switch h
    return;
  end;  % end if ischar(h)
  x = varargin{3};  vn = length(varargin);
  if ischar(x)                           % here for image pseudo object modifications:
    c=x; zstat=[]; x=varargin{4}; xx=[]; % plt('image',imageHandle,Param1,Value1,Param2,Value2,...)
    imgS = get(h,TAG); imgS=imgS(4:end);
    gn = 5;                              % points to next argument
    while length(c)                      % continue until all arguments are used up
      c = lower(c);
      switch c
        case 'x'  , set(h,'x',x);                  xx = x;
        case 'y'  , set(h,'y',x);
        case 'z'  , set(h,'Cdata',x);              zstat = x(:);
        case 'xy' , y = varargin{gn};  gn=gn+1;
                    set(h,'x',x,'y',y);            xx = x;
        case 'xz' , y = varargin{gn};  gn=gn+1;
                    set(h,'x',x,'Cdata',y);        zstat = y(:);  xx = x;
        case 'yz' , y = varargin{gn};  gn=gn+1;
                    set(h,'y',x,'Cdata',y);        zstat = y(:);
        case 'xyz', y = varargin{gn};  z = varargin{gn+1};  gn=gn+2;
                    set(h,'x',x,'y',y,'Cdata',z);  zstat = z(:);  xx = x;
        case {'edge' 'mid'},  plt('slider',findobj(gcf,TAG,[c imgS]),'set',x);
        case {'xlim' 'ylim'}, set(get(h,PARENT),c,x);
      end;
      if vn>=gn c=varargin{gn}; x=varargin{gn+1}; gn=gn+2; else c=[]; end;
    end;
    if length(xx) set(findobj(gcf,TAG,'imgLine'),'x',xx,'y',xx*NaN); end;
    if length(zstat) zstat(isnan(zstat)) = [];            % ignore missing points (NaNs)
                     zstat = [mean(zstat) std(zstat) min(zstat) max(zstat)];
                     set(h,USER,zstat);                   % save mean & sigma in image user data
                     plt('image',imgS,'slider');          % update the Clim property
    end;
  else  % here for image pseudo object initialization: plt('image',axisNumber,x,y,z)
    y = varargin{4};  z = varargin{5};  w = 1;
    if nargin>5 opt = varargin{6}; n = length(opt); else n = 0; end;
    pc = [];  pm = [];  pe = [];  pg = [];  pv = [];  cmap = 0;
    ax = getappdata(gcf,'axis');   ax = ax(h);  set(ax,'box','off');
    ah = get(ax,POS); al = ah(1);  ab = ah(2);  aw = ah(3);  ah = ah(4);
    l = getappdata(ax,'Lhandles');  fh = get(gcf,POS);  fw = fh(3);  fh = fh(4);
    if length(l)<1 disp('Error, image axis must contain at least one trace'); return; end;
    while n >= w
      cas = opt{w};  w=w+1;
      if n >= w & ~ischar(opt{w})  v=opt{w};  w=w+1;  else v=[]; end;
      switch lower(cas(1))
        case 'c',  if length(v) pc = v;     % Cbar
                   else pc = [al-59/fw  ab+.5273*ah  18/fw  .3669*ah];
                   end;
                   cmap = cas(end)-'0';  cmap = cmap * (cmap>=0 & cmap<=9); 
        case 'm',  if length(v) pm = v;     % Mid
                   else pm = [al-94/fw  ab+.18*ah  17/fw  .293*ah];
                   end;
        case 'e',  if length(v) pe = v;     % Edge
                   else pe = [al-59/fw  ab+.18*ah  17/fw  .293*ah]; end;
        case 'g',  if length(v) pg = v;     % Grid
                   else pg = [al+aw-94/fw  5.6/fh  48/fw  20/fh];
                   end;
                   gON = cas(1)=='G'; % Grid/grid starts with checkbox on/off
        case 'v',  if length(v) pv = v;     % ViewAll
                   else pv = [al+aw-41/fw  8/fh  48/fw  15/fh];
                   end;
      end;
    end;  % end while n >= w
    zstat = z(:);  zstat(isnan(zstat)) = [];
    zstat = [mean(zstat) std(zstat) min(zstat) max(zstat)];
    set(l(1),'x',x,'y',x*NaN,TAG,'imgLine');
    b = axes;                             % temporary axis for the map
    img = imagesc(x,y,z);
    if MverE ht='on'; else ht='off'; end; % 'on' for Matlab R2014a or earlier
    imgN = getappdata(gcf,'imgN');  if isempty(imgN) imgN = 1; else imgN = imgN+1; end;
    setappdata(gcf,'imgN',imgN);
    imgS = sprintf('%d',imgN);  imgP = ['plt image ' imgS ' '];  axb = get(ax,'buttond');
    set(img,'parent',ax,'buttond',axb,USER,zstat,TAG,['img' imgS]);
    delete(b);                          % delete the temporary axis
    ilim = [x([1 end]) y([1 end])];
    setappdata(ax,'ilim',ilim);         % for view all button
    set(ax,'xlim',ilim(1:2),'ylim',ilim(3:4));
    grd = plt('grid',ax);               % update imap grid lines
    uistack(grd,'top');                 % move grid to the top of the stack
    if MverE set(grd,'erase','xor');
    else     set(grd,'linestyle',':','color',[.4 .4 .4]);
             uistack(findobj(ax,'color',[1 1 .51]),'top');
    end;
    if length(pv) uistack(uicontrol('style','text','string','view all',NORMAL,'pos',pv,...
                             INACTIVE,MOUSE,[imgP 'view;']),'bottom');
    end;
    if length(pg)
      set(grd,TAG,'       ','vis',char('of'+[0 8*gON])); % A blank tag prevents grid tag from
                  % changing this grid line, but still has to be length 7 (same as 'SkipCur')
      uicontrol('sty','checkbox',USER,grd,...      % create grid on/off box
        'string','grid','value',gON,NORMAL,'pos',pg,'callback',...
        'set(get(gcbo,''user''),''vis'',char(''of''+[0 8*get(gcbo,''value'')]));');
    end;
    setappdata(ax,'offline',1);         % allow the cursor to appear anywhere inside the image
    axes(ax); text(.26,-.06,'',NORMAL,'fontsize',12,'color',[.3 1 .3],TAG,'zstr');
    k = round(length(x)/2);
    ob = plt('cursor',-h,'obj');  s = [imgP 'Icur; ' get(ob(6),'user')];  % append to cursor callback
    plt('cursor',-h,'moveCB',s);                             % set image cursor callback
    plt('cursor',-h,'updateN',k,x(k),mean(get(ax,'ylim')));  % move image cursor to the middle
    if length(pc)
      c = axes('pos',pc);                                      % create the axis for the colorbar
      image(transpose(63:-1:0),'buttond',[imgP 'cbar;'],TAG,'cbar'); % create the colorbar key
      text(.475,1.023,'',NORMAL,'rot',90,'color','white');     % create colorbar text
      set(c,'vis','off');  axes(ax);                           % hide the axis for the colorbar
    end;
    imgPS = [imgP 'slider;'];
    if length(pm) hm = plt('slider',pm,[0 -1 1], 'mid', imgPS,1,'4'); end;
    if length(pe) he = plt('slider',pe,[1 0 2.5],'edge',imgPS,1,'3'); end;
    set(hm,TAG,['mid' imgS]);  set(he,TAG,['edge' imgS]);
    plt('image',imgS,'cbar',cmap);                           % initialize the colorbar
    plt('image',imgS,'slider');                              % initialize the Clim property
    ERAS = 'eras';  em = 'norm'; % For old graphics engine (except Matlab 6)
    if ~MverE ERAS = 'pi';  em = 'v';  elseif Mver<7 em = 'xor'; end;
    mk = findobj(ax,'marker','+',SHOW);
    set(mk,'MarkerSize',16,'Marker','*',ERAS,em,'buttond',axb);
    uistack(mk,'top');
    Ret1 = img;                                              % returns the image handle
  end;
% end case 'image'

case pop_
% Ret1 = plt('pop','PropName1',PropValue1,...)
%
% A new popup is created with the specified
% properties. The new popup handle is returned in "Ret1". (The
% popup handle is the handle of the popup text object - the text
% object that appears when the popup is not open.)
%
% Ret1 = plt('pop',loc,choices,'PropName1',PropValue1,...)
% is equivalent to:
% Ret1 = plt('pop','location',loc,'choices',choices,'PropName1',PropValue1,...)
%
% Ret1 = plt('pop',hin,'PropName1',PropValue1,...)
%
% If hin is a scaler, the specified properties are applied to the
% previously defined popup with handle hin.
%
% If hin is a vector then PropName1 of hin(k) is set to the
% kth row of PropValue1. If PropValue1 doesn't have that many
% rows, the last row will be used. Only 1 property is allowed
% in the case where hin is a vector.
%
% If a property name is given which isn't in the following list
% then the property is applied to the popup text obect:
%
% Property  Property
% Name      Value
% -------   ------------------------------------------------------------
% location  height or [x y width height] for the popup (pixels or normalized)
% choices   A cell array of strings specifying the choices given when
%           the popup is selected.
% index     An integer specifying the current choice (default = 1)
% callbk    A callback to be executed when the popup index is changed.
%           Occurrences of '@IDX' are replaced with the popup index
%           Occurrences of '@STR' are replaced with the popup string
% colorbk   The background color used when the popup is open.
% colorfr   The foreground color used when the popup is open.
% offset    y or [x y] position of closed popup (default = [.08 0] or [.08 n])
% enable    -1=hide,  0=disable,  1=enable (default=1)
% hide      A list of objects to hide before opening the popup.
% interp    'none' or 'tex' (default='none')
% label.....If the argument is a string, that string will become a label for
%           the edit object. The argument may also be the cell array:
%           {string, offset, 'prop1', 'val1', ... 'propN','valN'}
%           The label will be a uicontrol/text object for a type 1/2
%           edit pseudo object respectively
%
% plt('pop',hin)                 returns currently selected index (1 = 1st choice)
% plt('pop',hin,'get')           same as above
% plt('pop',hin,'get','index')   same as above
% plt('pop',hin,'get','string')  returns a string containing the currently selected choice.
% plt('pop',hin,'get','choices') returns cell array of choices.

  k = 2; b = varargin;  a1 = b{2};  nvar = length(b);
  if nvar==2 b = [b {'get'}];  nvar = nvar+1; end;  % 3rd argument defaults to 'get' if omitted
  if isnumeric(a1) & ~ischar(b{3})
     a1 = POS; b = [b(1) {a1} b(2) {'choices'} b(3:nvar)]; nvar = nvar+2;
     % Ret1 = plt(b{:}); return;
  end;
  if ischar(a1)
       g  = gca;
       bk = [0 .3 .4]; % default 'colorbk'
       a = axes(HIDE,NOTICK,COLOR,bk,XCOLOR,bk,YCOLOR,bk);
       %   axis, choices, index, callbk, offset, foreground, enable, hide, interp, lbl, swap
       pd = {a     ''       1      ''      99    [.1 1 .9]     1      []   'none'   -1   0 };
       Ret1 = text(0,0,'','units','data',USER,pd,'interp','none',COLOR,[1 1 .4]);
       % shouldn't need the 'units' property above. (Bug in Matlab R2009b?)
       setappdata(gcf,'pop',[getappdata(gcf,'pop') Ret1]);
       setappdata(Ret1,'ty','pop');  setappdata(a,'ty','pop');
       set(Ret1,MOUSE,{@plt 'pop' Ret1 'open'});
       set(a,USER,Ret1); % so we can find popup handle from axis handle
       axes(g);          % restore current axis
  else n = length(a1);  Ret1 = a1;
       if n==1 k=k+1; pd=get(Ret1,USER); a=pd{Uaxis};
       else    argn = b{3};  argv = b{4};  s = size(argv,1);
               if s for k=1:n plt('pop',Ret1(k),argn,argv(min(k,s),:)); end;
               else for k=1:n plt('pop',Ret1(k),argn,[]); end;
               end;
               return;
       end;
  end;
  nvar = length(b);  ofs = [];  cb = 0;
  while k <= nvar
    argn  = lower(b{k}); k=k+1;
    if k>nvar argv=''; else  argv = b{k}; k=k+1; end;
    switch sum(argn)
    case {pos_,position_},
                    switch length(argv)
                      case 1, fp=get(a,POS); argv=[fp(1:3) argv];
                      case 2, fp=get(a,POS); argv=[fp(1:2) argv];
                    end;
                    if argv(1)<0 argv(1)=-argv(1); pd{Uoff}=0; end;  % indicates offset at the bottom
                    if argv(2)<0 argv(2)=-argv(2); pd{Uswap}=1; edg(Ret1,pd{Ufr}); end; % super button
                    if max(argv)>1 u='pixels'; else u='normal'; end;
                    set(a,'units',u,POS,argv);
    case choices_,  if isnumeric(argv)
                      if sum(mod(argv,1)) fm = '{%5w!row}'; else fm = '{%d!row}'; end;
                      argv = prin(fm,argv);
                    end;
                    pd{Uchoice} = argv;
    case open_,
                    if pd{Uena}<1 return; end;                     % if not enabled, don't open
                    mv = get(Ret1,MOUSE);
                    if iscell(mv) mv = mv{2}(1); else mv = mv(5); end;
                    mv = (mv=='m');                                % mv indicates reposition mode (plt misc)
                    if xor(MouseLeft,pd{Uswap}) & ~(MouseDbl) | mv % left click comes here - open popup selection menu
                      uh = findobj(pd{Uhide},SHOW);                % objects to hide
                      setappdata(Ret1,'Uhide',uh);                 % save so we can reverse it
                      set([Ret1; uh],HIDE);  ch = pd{Uchoice};  n = length(ch);
                      set(a,SHOW);  axes(a);
                      s = {@plt 'pop' Ret1 'index'};  w = get(gcf,POS);
                      p = get(a,POS);  p = p(3);  if p<1 p = p*w(3); end;
                      p = 5/p;                                     % leave 5 pixels to the left of popup items
                      for m=1:n 
                        ht = text(p,n+.5-m,ch{m},'units','data');  % units bug in R2009b?
                        set(ht,'interp',pd{Uterp},COLOR,pd{Ufr},MOUSE,[s {-m}]);
                        if m==pd{Uindex} set(ht,BOLD); end;
                      end;
                      cr = get(a,COLOR);  z = zeros(1,n-1);
                      x = [z;z+1;z];  z = [z;z;z+NaN];   y = 1:n-1;  y = [y;y;y];
                      line(ZDATA,z(:),YDATA,y(:),XDATA,x(:),COLOR,cr-.2+.4*(cr<.5),USER,w);
                    else                                              % right click comes here - advance popup by 1 position
                      g = gcf;  setappdata(g,'bdown',1);
                      set(g,'WindowButtonUp','setappdata(gcf,''bdown'',0);');
                      n = length(pd{Uchoice});  v = pd{Uindex};
                      [rpt p] = getREPEAT;                            % get custom or default repeate rate
                      while ishandle(g) & getappdata(g,'bdown')       % loop until user lets go of mouse or min/max is reached
                        if v==n v=1; else v=v+1; end;                 % if at last, go to 1st position
                        plt('pop',Ret1,'index',-v);
                        if rpt < 0 break; end;                        % disable repeating by seting a negative repeat rate 
                        q=p; while q>0 & ishandle(g) & getappdata(g,'bdown') pause(.01); q=q-.01; end; % pause in 10ms intervals
                        p = rpt;                                      % change from repeat delay to repeat rate
                      end;
                    end; % end if c=='a'
                    return;
    case hide_,     if isempty(argv) argv = 0; end;
                    z = find(argv==0);
                    if length(z) argv(z) = findobj(gcf,isGRID); end;
                    pd{Uhide} = argv;
    case offset_,   pd{Uoff} = argv;
    case colorfr_,  pd{Ufr} = argv;
    case colorbk_,  set(a,COLOR,argv,XCOLOR,argv,YCOLOR,argv);
    case interp_,   pd{Uterp} = argv;  set(Ret1,'interp',argv);
    case swap_,     pd{Uswap} = 1;  if isempty(argv) argv = 'none'; elseif length(argv)==1 argv = pd{Ufr}; end;
                    edg(Ret1,argv);
    case index_,    w = abs(argv);  pd{Uindex} = w;   v = get(a,VISIBLE);
                    if v(2)=='n'
                      set(a,HIDE);  ch = get(a,CHILDREN); li = findobj(ch,'type','line');
                      dp = sum(abs(get(li,USER) - get(gcf,POS))); % total change in figure position (horiz+vert)
                      if dp>0 & dp<20
                        pd{Uswap} = 1 - pd{Uswap};                % toggle swap if figure moved, but < 20 pixels
                        disp('swap toggled');
                      end; 
                      ch(find(ch==Ret1)) = [];  ch(find(ch==pd{Ulbl})) = [];
                      li = getappdata(Ret1,'li');  if ishandle(li) ch(find(ch==li)) = []; end; % only needed for v6
                      delete(ch); % don't delete closed popup or popup label
                      uh = getappdata(Ret1,'Uhide');
                      set([Ret1; uh],SHOW); % restore hidden objects
                      ch = gcf;
                      if Mver < 7.5
                        set(ch,'Share','off'); % BUG workaround (verson 7.4 and earlier)
                        set(ch,'Share','on');  % BUG workaround
                      end;
                    end;
                    cb = (argv<0);  % execute callback if index is negative
    case callbk_,   pd{Ucallbk} = argv;  set(Ret1,USER,pd);
    case get_,      switch sum(argv)
                      case string_,  Ret1 = get(Ret1,STR); % returns the string corresponding to the current choice
                      case axis_,      Ret1 = pd{Uaxis};   % returns the handle of the popup axis
                      case choices_,   Ret1 = pd{Uchoice}; % returns a cell array of all the choices
                      case {index_,0}, Ret1 = pd{Uindex};  % returns the index of the selected choice
                      case callbk_,    Ret1 = pd{Ucallbk}; % returns the callback function string or handle
                      case offset_,    Ret1 = pd{Uoff};    % returns the offset parameter
                      case colorfr_,   Ret1 = pd{Ufr};     % returns the axis foreground color
                      case enable_,    Ret1 = pd{Uena};    % returns -1/0/1 if the popup is hidden/disabled/enabled
                      case hide_,      Ret1 = pd{Uhide};   % returns and array of objects to be hidden
                      case interp_,    Ret1 = pd{Uterp};   % returns 'tex' or 'none'
                      case label_,     Ret1 = pd{Ulbl};    % returns the label handle
                      case swap_,      Ret1 = pd{Uswap};   % returns true if the swap (super-button) mode is selected
                      otherwise,       Ret1 = pd;          % returns popup state in a 10 element cell array
                    end;
                    return;
    case enable_,   pd{Uena} = argv;  set(Ret1,USER,pd);  vs = char('on' - [0 8]*(argv<0));  set(Ret1,VISIBLE,vs);
                                      if ishandle(pd{Ulbl}) set(pd{Ulbl},VISIBLE,vs); end;
    case {label_ labely_},
                    if ischar(argv) argv = {argv ''}; end;
                    s = argv{1};                    % get label string
                    q = argv{2};                    % offset = [real(q) imag(q)] in pixels
                    if isempty(q)
                      if sum(argn)==label_ q = -5;  % default label position (5 pixels to the left)
                      else  q = (16 + pd{Uswap}*(6 - 3*MverE)) * 1i;
                                                    % default label position for LabelY is: -----
                                                    % 16 for regular mode
                      end;                          % 19 for super button mode (ver 2014a or earlier)
                    end;                            % 22 for super button mode (later that 2014a)
                    q = [real(q) imag(q)];          % separate x & y coordinates of the offset
                    if ~q(2) & q(1)<0 hz = 'right'; else hz = 'left'; end;
                    t = text(0,0,s,'units','data','horiz',hz,COLOR,[.6 .6 .8],PARENT,a,USER,q);
                    pd{Ulbl} = t;
                    j=3;  while length(argv)>j set(t,argv{j},argv{j+1}); j=j+2; end; % process optional args
    otherwise,      set(Ret1,argn,argv);
    end;
  end; % end while  k <= nvar
  c = pd{Uchoice};  n = length(c);  f = pd{Uoff};  i = pd{Uindex};  s = c{i};
  if length(f)<2 f=[.08 f]; end;  % only y offset is specfied, so x defaults to .08
  if f(2)==99 f(2)=n; end;        % 99 indicates the offset at the top
  set(a,YLIM,[0 n]);
  set(Ret1,POS,f,STR,s,USER,pd);
  edg(Ret1);
  p = get(a,POS);
  t = pd{Ulbl};
  if ishandle(t)                                        % here if a label was defined
    e = p(3:4);
    if p(1)<1  r = get(gcf,POS); e = e .* r(3:4); end;  % make sure e is in pixel units
    q = get(t,USER)./e;  q(2)=q(2)*n;                   % convert offset (from user data) to data units
    set(t,POS,f+q);                                     % set label position
  end;
  p(4) = p(4)/n;
  setappdata(Ret1,'ppos',p - [([0 .3]-f) .4 .4] .* p([3 4 3 4]));  % save extent of closed popup
  if cb evalRep(pd{Ucallbk},{'@STR',s,'@IDX',int2str(i)}); end;    % execute callback if necessary
% end case 'pop'

case grid_  % 'grid' and 'edit' share the same case statement
if MverE  ERAS = 'eras';  ERAXOR = 'xor';  ERANOR = 'norm'; % for Matlab R2014a or earlier
else      ERAS = 'pi';    ERAXOR = 'v';    ERANOR = 'v';    % Matlab R2014b or later doesn't
end;                                                        % support the erasemode property
if y1(1) == 'g'
% case grid_
% function Ret1 = plt('grid',ax,Action,color,erMode,LineStyle,In7,In8,In9,In10)
%
% plt('grid',ax,'init',color,erMode,LineStyle) - initialize grid line
% plt('grid',ax,'toggle')                      - toggle grids (on/off)
% plt('grid',ax,'get')                         - get grid line handle
% plt('grid',ax,'off')                         - turn grids off
% plt('grid',ax,'on')                          - turn grids on
% plt('grid',ax,'update')                      - updates grids
% plt('grid',ax)                               - same as above
% plt('grid')                                  - equivalent to plt('grid',gca)
%
% Grid always returns the grid line handle.
% In7 to In10 may be used to assign additional gridline properties
%
% To see what it does, try typing this at the command promt:
%    >> a = axes;                 % create axis
%    >> plt('grid',a,'init');     % draw grid lines
%    >> set(a,'ylim',[0 6]);      % change axis limits
%    >> plt('grid');              % update grid lines
  if Narg==1 ax = gca;
  else       ax = varargin{2};  if ax==0 ax = gca; end;
  end;
  if Narg<3 Action='update'; else  Action = varargin{3};  end;
  Action = sum(Action);
  if Action == init_
    if Narg<4 grdclr = [.13 .13 .13]; else grdclr = varargin{4}; end;
    if Narg<5 erMode = ERAXOR;  else erMode = varargin{5}; end;
    if Narg<6 sty = '-';        else sty    = varargin{6}; end;
    f = findobj(ax,'type','line');        % use buttondownfcn of other lines so we
    if length(f) f=get(f(1),MOUSE); end;  % don't interfere with cursor functions
    Ret1 = line(COLOR,grdclr,NoCUR,MOUSE,f,LINESTYLE,sty,isGRID,ERAS,erMode);
    set(Ret1,PARENT,ax);                  % move line to this axis (which avoids the axes
    setappdata(Ret1,'clr',grdclr);        %   command to prevent figure becoming visible)
    Action = on_;                 % start with grids on
    if Narg >= 7 set(Ret1,varargin{7},varargin{8}); end;   % extra line properties
    if Narg >= 9 set(Ret1,varargin{9},varargin{10}); end;  % more line properties
    % put grid on bottom of stacking order
    set(ax,CHILDREN,flipud(get(ax,CHILDREN)));
  else  Ret1 = findobj(ax,isGRID);
        if length(Ret1) ~= 1 return; end;      % grid object must have been deleted
        z = get(Ret1,ZDATA);   e = length(z);
        if e e = z(1) | e>=2; end;             % get current grid on/off state
  end;

  switch Action
  case update_, if e Action=on_; end;
                fixMark;
  case toggle_, if e Action=off_; else Action=on_; end;
  end;

  switch Action
  case on_,  z = 1;  l = [get(ax,XLIM) get(ax,YLIM)];
             s = get(ax,'Xscale');  t = 1;
             if s(2)=='o' &  l(2)/l(1)<getappdata(gcf,'logTR')     % default logTR = 1e6
               t = get(ax,'XtickLabel'); if iscell(t) t = [t{:}]; else t = t(:)'; end;
               t = length(findstr(t,'.'));
             end;
             if t  xt = [l(1) get(ax,'XTICK') l(2)]; n=length(xt); % here for linear X grids
                   if xt(2) <= xt(1)   xt = xt(2:n); n=n-1; end;   % or log grids without subdecades
                   if xt(n) <= xt(n-1) n=n-1;  xt = xt(1:n); end;
             else  xt = logTicks(l(1:2));  n = length(xt);         % here for log grids with subdecades
             end;
             s = get(ax,'Yscale');  t = 1;
             if s(2)=='o' & l(4)/l(3)<getappdata(gcf,'logTR')      % default logTR = 1e6
               t = get(ax,'YtickLabel'); if iscell(t) t = [t{:}]; else t = t(:)'; end;
               t = length(findstr(t,'.'));
             end;
             if t  yt = [l(3) get(ax,'YTICK') l(4)]; m=length(yt); % here for linear Y grids
                   if yt(2) <= yt(1)   yt = yt(2:m); m=m-1; end;   % or log grids without subdecades
                   if yt(m) <= yt(m-1) m=m-1;  yt = yt(1:m); end;
             else  yt = logTicks(l(3:4));  m = length(yt);         % here for log grids with subdecades
             end;
             t = m + n - 4;
             if t s = ones(3,1);  y = [1 m m];  x = [1 n n];  n=n-1;  m=m-1;
                  z = [0;0;NaN] * ones(1,t);           z=z(:);
                  y = [s*yt(2:m)  yt(y)'*ones(1,n-1)]; y=y(:);
                  x = [xt(x)'*ones(1,m-1) s*xt(2:n)];  x=x(:);
             else x = 0;  y = 0;  z = 0;
             end;
             tlen = [ 0   0  ];
  case off_, tlen = [.01 .025]; x=0; y=0; z=0;
  otherwise, return;                                               % get action comes here
  end;
  set(Ret1,ZDATA,z,YDATA,y,XDATA,x);  set(ax,'TickLen',tlen);
% end case 'grid'
else   % 'grid' and 'edit' share the same case statement
% case edit_ ------------------------------------------------------------------------

% H = plt('edit',PropName1',PropValue1,...)
%
% A new edit pseudo object is created with the specified properties.
% The new object's handle is returned in "Ret1".
% There are two types of edit pseudo objects:
%
% Type 1: type = uicontrol (style = 'text')
% Type 2: type = text
%
% If the position is given as a 4 element vector, then the first type
% (uicontrol) is created. The position is relative to the figure window.
% Otherwise the 2nd type (text) is created, and the postion is relative
% to the current axis.
%
% The pseudo objects handle (H) is the same as the handle of the
% uicontrol or text object for case 1 and 2 respectively.
%
% H = plt('edit',loc,val,'PropName1',PropValue1,...)
%
% If both loc and val are numeric, then the above statement is equivalent to:
% H = plt('edit','pos',loc,'value',val,'PropName1',PropValue1,...);
%  ---- or if all the values of loc are less than 3 ----
% H = plt('edit','units','norm','pos',loc,'value',val,'PropName1',PropValue1,...);

% plt('edit',H,'PropName1',PropValue1,...)

% If H is a scaler, then the specified properties are
% applied to the previously defined popup with handle H.
%
% If H is a vector then PropName1 of H(k) is set to the
% kth row of PropertyValue1. If PropValue1 doesn't have that many
% rows, the last row will be used. Only 1 property is allowed in
% the case where H is a vector.
%
% plt('edit',H)                  returns current numerical value of the object
% plt('edit',H,'get')            same as above
% plt('edit',H,'get','value')    same as above
% plt('edit',H,'get','minmax')   returns [min max] - the allowed limits for the value
% plt('edit',H,'get','callbk')   returns the string or function handle that was set via the 'callbk' parameter
% plt('edit',H,'get','enable')   returns -1/0/1 if the pseudo object is hidden/disabled/enabled
% plt('edit',H,'get','incr')     returns the value that was set via the 'incr' parameter
% plt('edit',H,'get','length')   returns the value that was set via the 'length' parameter
% plt('edit',H,'get','format')   returns the string that was set via the 'format' parameter
% plt('edit',H,'get','label')    returns the label handle
% plt('edit',H,'get','cell')     returns an 9 element cell array that is a concatination of the
%                                previous 8 get commands: {val min max callback enable incr length label}
%                                Actually the word 'cell' may be replaced by any string other than one
%                                of the other 8 valid 'get' arguments.

% If a property name is given which isn't in the following list
% then the property is applied to the text object itself:
%
% Property  Property
% Name      Value
% -------   ------------------------------------------------------------
% value     [scaler] - sets the numerical value of the object (default = 1).
%           [min max] - sets the min and max values allowed (defaults = -1e99, 1e99).
%           [value min max] - sets both of the above.
%           Except for the length 2 argument case, the callback function is called
%           if it has been provided earlier in the argument list or in a previous
%           call to plt('edit').
% val       Equivalent the value property above, except that the callback is not called.
% minmax    Equivalent to the val property above. (For clarity, use this only when
%           the argument has length 2 (i.e. [min max]).
% callbk    A callback to be executed when the popup value is changed.
%           Occurrences of '@VAL' are replaced with the current value
%           Occurrences of '@OBJ' are replaced with the object handle
% enable    -1=hide,  0=disable,  1=enable (default=1)
% incr      The increment value for a numeric plt edit object
%           If the edit object's value is a multiple of "incr" then when
%           you click on the right/left side of the center of the object,
%           the value of the object is increased/decreased by "incr".
% length    The length of the vector allowed as the edit value.
%           Usually length=1 indicating the edit value must be a scaler.
%           If length=4 (for example), an allowed edit value must be a row
%           or column vector of length 4. Two special cases are length=-1
%           and length=0. length=-1 is used to indicate that a numeric
%           array of any length is a legal value. length=0 is used for
%           string edit objects. I.E. the edit string should not be
%           interpreted as a number or vector. If the value of a string
%           edit object is requested, the number zero will be returned.
% format    The format conversion string used to display numeric edit objects.
%           (only used when length=1)
% label.....If the argument is a string, that string will become a label for
%           the edit object. The argument may also be the cell array:
%           {string, offset, 'prop1', 'val1', ... 'propN','valN'}
%           The label will be a uicontrol/text object for a type 1/2
%           edit pseudo object respectively

  k = 2; b = varargin;  a0 = b(1); a1 = b{2};  nvar = length(b);
  if nvar==2 b = [b {'get'}];  nvar = nvar+1; end;  % 3rd argument defaults to 'get' if omitted
  if isnumeric(a1) & isnumeric(b{3})
     if     max(a1)<4      a0 = {'edit' 'units' 'norm'};
     elseif length(a1)==2  a0 = {'edit' 'units' 'pix'};  % type 2
     end;
     a1 = POS;  b = [a0 {a1} b(2) {'value'} b(3:nvar)];
     nvar = length(b);
  end;
  if ischar(a1)
       ui = 0;
       for z = 2:2:nvar  d = b{z};
                         if lower(d(1))=='p' ui = length(b{z+1}); break; end;
       end;
       if ~ui disp('You must specify a position for the edit pseudo object'); return; end;
       ui = (ui==4);  % ui is true  if this is a uicontrol type edit pseudo object (type 1)
                      % ui is false if this is a text type edit pseudo object      (type 2)

       %    value, min, max, callback, ena, incr, len, fmt, lbl, olds, oldi
       pd = { 1  -1e99 1e99     ''      1    1     1  '%6w'  -1   ''    ''  };

       c = get(gcf,COLOR)/2;  f = [1 1 .4];  if sum(c)>1.5 f = 1-f; end; % default colors
       if Mver < 7 fsz = 8; else fsz=9; end;
       if ui ut='uic'; Ret1 = uicontrol('style','text',FONTSIZE,fsz,INACTIVE,'foregr',f,'backgr',c);
       else  ut='txt'; Ret1 = text(0,0,'1',CENTERalgn,COLOR,f);
       end;
       setappdata(gcf,ut,[getappdata(gcf,ut) Ret1]);
       setappdata(Ret1,'ty','edi');
       set(Ret1,USER,pd,MOUSE,{@plt 'edit' Ret1 'click' 0});
  else n = length(a1);  Ret1 = a1;
       if n==1 k = k + 1;   pd = get(Ret1,USER); % continue processing arguments below
       else    argn = b{3};  argv = b{4};  s = size(argv,1);
               if s for k=1:n plt('edit',Ret1(k),argn,argv(min(k,s),:)); end;
               else for k=1:n plt('edit',Ret1(k),argn,[]); end;
               end;
               return;
       end;
  end;
  ui = get(Ret1,'type');  ui = (ui(1) == 'u');  % ui true for type 1
  if ui cp = 'foregr'; gc = gcf;   nun = 'pix';
  else  cp = COLOR;    gc = gca;   nun = 'data';
  end;
  while k <= nvar
    argn  = lower(b{k}); sargn = sum(argn); k=k+1;
    if k>nvar argv=''; else  argv = b{k}; k=k+1; end;
    switch sargn
    case click_,
      if argv  % keypress function comes here
        c = get(gcf,'CurrentChar');
        if ~length(c) c=666;  end;                      % shift key, function keys, etc.
        if argv==2 c=27; end;                           % a second click acts like an escape
        t = get(Ret1,STR);   u = get(Ret1,cp);
        p = findstr(t,'_');  n = length(t);
        done = 0;            eeval = 0;
        switch abs(c)
        case 666,                                       % Shift key (does nothing)
        case 8,    if p>1 t(p-1)=[]; end;               % Backspace
        case 127,  if p==n t='_'; else t(p+1)=[];  end; % Delete
        case 28,   if p>1 t(p)=t(p-1); t(p-1)='_'; end; % Left arrow
        case 29,   if p<n t(p)=t(p+1); t(p+1)='_'; end; % Right arrow
        case 27,   done = 1;  t = pd{Wolds};            % Escape
        case 13,   done = 1;                            % Carriage return
                   t(p) = [];                           % remove '_'
                   if pd{Wlen}
                     tt=t;  t = 'error';                % assume try will fail
                     try, s = eval(tt);                 % Here for numeric edit objects
                        if pd{Wlen}==-1 | pd{Wlen}==length(s)
                          if length(s)==1
                            if isreal(s)
                                 s = max(min(s,pd{Wmax}),pd{Wmin});
                                 t = ['  ' Pftoa(pd{Wfmt},s) '  '];
                            else pd{Wincr} = imag(s);   % use imaginary input to change increment
                                 t = pd{Wolds};         % restore original string
                            end;
                          else  t = ['[' num2str(s) ']'];
                          end;
                          if isreal(s)  pd{Wvalue} = s;  eeval = 1; end;
                        end;
                     end;
                   else pd{Wvalue}=0; eeval=1;          % Here for string edit objects
                   end;
       %case 30,   % available for special function?    % Up arrow
       %case 31,   % available for special function?    % Down arrow
        otherwise, t = strrep(t,'_',[c '_']);           % Other keys - add it to the string where the '_' is
        end; % end switch abs(c)
        set(Ret1,STR,t);
        if done                                         % set new string/value, restore old color/erasemode/interpreter
          set(Ret1,USER,pd,cp,u([3 1 2]))
          if ~ui set(Ret1,ERAS,ERANOR,'interp',pd{Woldi}); end;
          if Mver<7 ky = gcf; else ky = [gcf; findobj(gcf,'type','uicontrol')]; end;
          set(ky,'keypress',' ');
          if eeval setappdata(gcf,'OBJ',Ret1);  evalRep(pd{Wcallbk},{'@VAL' t '@OBJ' 'plt("misc",3)'}); end;
        end;
      else    % mouse click function comes here
        kp = get(gcf,'keypress');
        if iscell(kp) & length(kp)==5 & kp{4}(1)=='c'   % is an edit object already open?
           kp{5}=2;  plt(kp{2:end}); return;            % yes, do an escape
        end;
        if pd{Wena}<1 return; end;                      % return if not enabled
        c = MouseType;
        if c ~= alt_                                    % left or double click comes here
          v = pd{Wvalue}; w = pd{Wincr};                % w is increment value (0 disables incr/decr function)
          if pd{Wlen}==1 & w                            % only use incr/decr for numeric vectors of length 1
            cp = get(gc,CurPOINT); cp = cp(1,1);        % x-coord of mouse click (pixels/axis-units for type1/2)
            rp = get(Ret1,POS);  un = get(Ret1,'unit');
            if un(1) ~= nun(1)                          % here if edit object isn't defined in it natural unit
              set(Ret1,'units',nun);                    % switch to the natural units
              rp2 = rp;  rp = get(Ret1,POS);            % get position in the natural units
              set(Ret1,'units',un,POS,rp2);             % switch back to original units
            end;
            cp = cp > rp(1) + ui*rp(3)/2;                   % true if click was right of center
            cp = 2*cp - 1;                                  % cp = +1/-1 for right/left of center
            [rpt p] = getREPEAT(0);                         % get custom or default repeate rate
            setappdata(gcf,'bdown',1);
            set(gcf,'WindowButtonUp','setappdata(gcf,''bdown'',0);');
            m = 0;                             % set after first incr/decr
            while getappdata(gcf,'bdown')      % loop until user lets go of mouse or min/max is reached
              if w<0 vf = (1 - w/100)^cp;      % increase/decrease by percentage amount (-w)
                     if v v = v*vf;            % multiply by the percentage amount
                     else v = vf-1;            % if it's zero, we want to change it somewhat anyway
                     end;
              else   v = v + w*cp;             % increment/decrement by fixed amount (w)
              end;
              if     v>pd{Wmax} if m break; else v=pd{Wmin}; end; % rotate if 1st time thru. Otherwise stop at upper limit
              elseif v<pd{Wmin} if m break; else v=pd{Wmax}; end; % rotate if 1st time thru. Otherwise stop at lower limit
              end;
              m = 1;  pd{Wvalue} = v;  s = ['  ' Pftoa(pd{Wfmt},v) '  '];
              set(Ret1,STR,s,USER,pd);
              setappdata(gcf,'OBJ',Ret1); evalRep(pd{Wcallbk},{'@VAL' s '@OBJ' 'plt("misc",3)'});
              if rpt < 0 break; end;           % disable repeating by setting a negative repeat rate 
              q=p; while q>0 & getappdata(gcf,'bdown') pause(.01); q=q-.01; end; % pause in 10ms intervals
              p = rpt;                         % change from repeat delay to repeat rate
            end;
            return;
          else c=alt_;                         % if it can't increment, pretend it was a right click
          end;   % end if pd{Wlen}==1 & w
        end;     % end if c ~= alt_
        if c==alt_                             % right click comes here (open)
          t = get(Ret1,STR);
          if ~strcmp(t,'error') pd{Wolds} = t; end;       % save old string (if not error)
          t = deblank(t);  while(t(1)==' ') t(1)=[]; end; % remove blanks at both ends
          oldc = get(Ret1,cp);
          if ~ui pd{Woldi} = get(Ret1,'interp'); set(Ret1,'interp','none',ERAS,ERAXOR); end;
          set(Ret1,STR,[t '_'],cp,oldc([2 3 1]),USER,pd);
          % we have to set all the keypress functions, otherwise if you had clicked on a button
          % before right clicking on the edit object, it would not accept keyboard input.
          % It would be safer to save all these keypress properties before changing this
          % property, and then restore them when the edit object is closed, but I will
          % leave it this (simpler) way until this proves to be a problem.
          if Mver<7 ky = gcf; else ky = [gcf; findobj(gcf,'type','uicontrol')]; end;
          set(ky,'keypress',{@plt 'edit' Ret1 'click' 1});
        end;
      end;
    case get_,    switch sum(lower(argv))
                  case {0,value_}, Ret1 = pd{Wvalue};
                  case minmax_,    Ret1 = [pd{Wmin:Wmax}];
                  case callbk_,    Ret1 = pd{Wcallbk};
                  case enable_,    Ret1 = pd{Wena};
                  case incr_,      Ret1 = pd{Wincr};
                  case length_,    Ret1 = pd{Wlen};
                  case format_,    Ret1 = pd{Wfmt};
                  case label_,     Ret1 = pd{Wlbl};
                  otherwise,       Ret1 = pd(1:Wlbl);
                  end;
    case {value_,val_,minmax_},
                  if     length(argv)==3  pd(Wmin:Wmax) = {argv(2) argv(3)};
                  elseif length(argv)==2  pd(Wmin:Wmax) = {argv(1) argv(2)}; set(Ret1,USER,pd);  return;
                  end;
                  pd{Wvalue}  = argv(1);  s = ['  ' Pftoa(pd{Wfmt},argv(1)) '  '];
                  set(Ret1,STR,s,USER,pd);
                  if sargn==value_ setappdata(gcf,'OBJ',Ret1); evalRep(pd{Wcallbk},{'@VAL',s,'@OBJ','plt("misc",3)'}); end;
    case callbk_, pd{Wcallbk} = argv;  set(Ret1,USER,pd);
    case incr_,   pd{Wincr}   = argv;  set(Ret1,USER,pd);
    case length_, pd{Wlen}    = argv;  set(Ret1,USER,pd);
    case enable_, pd{Wena}    = argv;  set(Ret1,USER,pd);  vs = char('on' - [0 8]*(argv<0));  set(Ret1,VISIBLE,vs);
                                       if ishandle(pd{Wlbl}) set(pd{Wlbl},VISIBLE,vs); end;
    case format_, if     isnumeric(argv) argv = sprintf('%%%dw',argv);
                  elseif length(argv)<2  argv = ['%' argv 'w']; end;
                  pd{Wfmt}    = argv;  set(Ret1,USER,pd);
    case label_,  if isnumeric(argv)
                       m = argv;  argv = getappdata(m,'argv');  % indicate repositioning mode
                  else m = 0;                                   % indicates normal mode
                  end;
                  if ischar(argv) argv = {argv ''}; end;
                  p = get(Ret1,POS);  u = get(Ret1,'units');  hz = 'right';
                  s = argv{1};  q = argv{2}; % get label string and position
                  if ui % --------- for type 1 edit objects --------------------------------
                    r = length(s);   tl = findstr(s,'~');
                    if length(tl)  tl = tl(end);  s(tl) = [];  r = tl-1; end;
                    r = round(22 + 6.5*r);
                    if u(1)=='n' sz=get(gcf,POS); r=r/sz(3); end;                % compute estimated label width
                    switch length(q)
                    case 0, q = [p(1)-r p(2) r p(4)];                            % use estimated width
                    case 1, q = [p(1)-q p(2) q p(4)];                            % arg2=width (scaler)
                    case 2, w = q(1);  if ~w w = r; end;                         % arg2=[width xyoffset]
                            xo = real(q(2));  yo = imag(q(2));
                            q = [p(1)+xo-w p(2)+yo w p(4)];
                            if ~xo  q(1) = p(1)+(p(3)-w)/2;  hz = 'cent';  end;
                    case 4, hz='cent';                                           % arg2=[x y width height]
                    end;  % end switch
                    if m set(m,POS,q); return; end;  % don't create the label if we are just repositioning
                    a = TEXT(s,'units',u,POS,q,'foregr',[.6 .6 .8],'backgr',get(Ret1,'backgr'),...
                             'horiz',hz,FONTSIZE,fsz,MOUSE,get(Ret1,MOUSE),INACTIVE,USER,Ret1,TAG,'E');
                  else % --------- for type 2 edit objects --------------------------------
                    p = p(1:2);
                    switch length(q)
                    case 0, r = pd{Wfmt};  t = length(get(Ret1,STR)) - 4;
                            r = max([t length(Pftoa(r,pd{Wmin})) length(Pftoa(r,pd{Wmax}))]);
                            r = 5 + r*4;                       % quess for best horiz offset (pixels)
                            if u(1)=='n' sz=get(gcf,POS); r=r/sz(3); end;
                            q = p - [r 0];
                    case 1, xo=real(q); yo=imag(q); q=p+[xo yo]; % arg = xy offset
                            if ~xo hz='cent'; end;
                    case {2,3}, hz='cent';                       % [x y] location specified
                    end;  % end switch
                    if m set(m,POS,q); return; end;  % don't create the label if we are just repositioning
                    a = text(q(1),q(2),s,'units',u,'horiz',hz,COLOR,[.6 .6 .8],...
                             MOUSE,get(Ret1,MOUSE),USER,q(1:2)-p);
                  end;  % end if ui ---------------------------------------------------------
                  j=3;  while length(argv)>j set(a,argv{j},argv{j+1}); j=j+2; end; % process optional args
                  pd{Wlbl} = a;  set(Ret1,USER,pd);                                % save label handle
                  setappdata(a,'argv',argv(1:2));                                  % for label repositioning
    otherwise,    set(Ret1,argn,argv);                                             % set edit pseudo object property
                  a = pd{Wlbl};                                                    % get label handle
                  if ishandle(a) & argn(1)=='p' plt('edit',Ret1,'label',a); end;   % adj label position if necessary
    end;
  end; % end while k <= nvar
end; % end if y1(1) == 'g'

case slider_
  Hin = varargin{2};
  if length(Hin)>1
     % function Ret1 = plt('slider',In1,In2,In3,In4,In5,In6,In7)
     %
     % Creates a pseudo object that has the 5 following sub objects:
     %     ------label-----
     %     min---value--max
     %     -----slider-----
     %
     % In1= [x,y,w] in pixels or normalized units (the only required parameter)
     %      if w is not specified .13 is used
     % In2= [value,sldmin,sldmax,edmin,edmax] values
     %      if edmin & edmax are not specified, 1e-99 & 1e99 are used
     % In3= slider label, no label if In3=''
     % In4= slider call back (@VAL is replaced with the current value)
     % In5= mode 1 = linear steps (default)
     %           2 = linear integers
     %           3 = power of 2
     %           4 = linear quantized to In5(2) or default 10
     %           5 = log steps
     %           6 = linear quantized to In5(2) or default 10
     %               also arrows step In5(2); trough steps 10*In5(2)
     % In6= [fmtmin; fmtval; fmtmax] format strings. (default = '2 6 3')
     %      All the following forms are equivalent:
     %      '%2d %6.1f %5w'                 (space delimeted)
     %      '%2d %6.1f 5'                   (w format is assumed for format strings of a single digit)
     %      {'%2d' '%6.1f' '5'}
     %      ['%2d  '; '%6.1f'; '%5w  ']     (the single digit trick is not allowed in this form)
     % In7= [[r g b];   label background color
     %       [r g b];   edit field background color
     %       [r g b];   label foreground color, [0 0 0] if not given
     %       [r g b]]   edit field foreground color, default=[0 0 0]
     % Ret1 returns the handle of this pseudo object which is also the
     %      handle of the label object
     if Narg>2  In2 = varargin{3}; else In2 = 100;   end;
     if Narg>3  In3 = varargin{4}; else In3 = '';    end;
     if Narg>4  In4 = varargin{5}; else In4 = '';    end;
     In5 = 1;  In6 = '%2w %6w %3w';  In7 = [.75 .75 .75; 0 1 1]; % defaults for last 3 parameters
     for k=6:8               % get up to 3 more parameters
       if Narg<k break; end; % exit loop if there are no more parameters
       v = varargin{k};      % get next argument
       if isnumeric(v)       % if its numeric it must be the quantization or color parameters
          if length(v)<3 In5 = v; else In7 = v; end;
       else In6 = v;         % otherwise it must be the formatting strings (cell or char array)
       end;
     end;
     if isempty(In2)                      In2 = 100; end;
     if length(In2)==1                    In2 = [0 In2]; end;
     if length(In2)==2 | length(In2)==4   In2 = [mean(In2(1:2)) In2]; end;
     if length(In2)==3                    In2 = [In2 -1e99 1e99]; end;
     if length(In7(:,1))<3                In7 = [In7; 0 0 0; 0 0 0]; end; 
     if ischar(In6) & length(In6(:,1))==1
        d = find(In6 == ' ');
        if length(d)<2 In6 = ['%2w ' In6 ' %3w'];  d = find(In6 == ' '); end;
        In6 = {In6(1:d(1)-1) In6(d(1)+1:d(2)-1) In6(d(2)+1:end)}; % blank delim string --> cell array
     end;
     if iscell(In6)
       for k=1:3  d=In6{k}; if length(d)<2 In6{k} = ['%' d 'w']; end; end;  % allow single digit trick
       In6 = char(In6); % convert to a character array
     end;
     hs = zeros(1,last_h); % pre allocate handle vector
     % userdata in this label is a vector of all the handles of the pseudo slider.
     hs(label)  = TEXT(In3,CENTERalgn);  if isempty(In3) set(hs(label),VISIBLE,'off'); end;
     Ret1       = hs(label);        cb = {@plt 'slider' Ret1};
     hs(mintxt) = TEXT('a',USER,In6,LEFTalgn); % using 'a' instead of '' (mpp bug work around)
     hs(maxtxt) = TEXT('a',USER,In4,RIGHTalgn);
     hs(slide)  = SLIDER(USER,In2(1),CALLBK,[cb {'CBslide'}]);
     hs(valro)  = EDIT(BACKGROUND,In7(2,:),FOREGROUND,In7(4,:),USER,In2(4:5),CENTERalgn,CALLBK,[cb {'CBedit'}]);
     set(hs(label:maxtxt),BACKGROUND,In7(1,:),FOREGROUND,In7(3,:));
     In5 = [In5 10];  hs([mode1 quant]) = In5(1:2);  % store mode & optional quantization value
     if hs(mode1)==LOGc & In2(4)<0 In2(4) = 1e-99; end;
     set(hs(label),USER,hs);
     plt('slider',Ret1,'set','minmax',In2(2:5),In2(1));
     plt('slider',Ret1,'set',POS,Hin);               % set slider position
     if length(Hin)<4                                % don't reposition as a unit when using manual positioning
       setappdata(gcf,'sli',[getappdata(gcf,'sli') hs(label:lastobj)]); % save handles for repositioning
     end;
     return;
  end; % end if length(Hin)>1

  % function Ret1 = plt('slider',Hin,Action,In1,In2,In3,In4,In5)
  % Hin is the slider handle returned by the slider initialization (above)
  % Action
  %   omitted          Ret1 returns the current value of the pseudo slider
  %   'get'            Ret1 returns the current value of the pseudo slider
  %   'get','value'    Ret1 returns the current value of the pseudo slider
  %   'get','vis'      Ret1 returns 1 if the slider is visible. 0 otherwise
  %   'get','ena'      Ret1 returns 1 if the slider is enabled. 0 otherwise
  %   'get','obj'      Ret1 returns list of handles: [label slider mintext maxtext editbox]
  %   'get','position' Ret1 returns the sliders 3 element position vector
  %   'get','pos'      same as above
  %   'set',x          sets the slider to value x, Ret1 returns a possibly limited value
  %   'set','value',x  same as above
  %   'set','val',x    same as above, except user callback is not executed
  %   'set','minmax'   In2 [sldmin,sldmax,edmin,edmax] 
  %                    In3 (optional) value
  %                    Ret1 returns a possibly limited value
  %   'set,'visON'     Make visible.
  %   'set,'visOFF'    Make invisible.
  %   'set,'enaON'     Enable
  %   'set,'enaOFF'    Disable
  %   'set,'label'     In2 set label string (use '' to make label invisible)
  %   'set,'mode'      In2 has the new mode
  %                    In2(2) has new quantization value if mode 4 or 6
  %                    Ret1 returns a possibly limited value
  %   'set,'position'  In2= [x,y,w] in pixels or normalized units
  %   'set,'pos'       Same as above

  hs   = get(Hin,USER);                                      % get local handles
  fmat = get(hs(mintxt),USER);                               % get formatting info

  if nargin>2 Action = varargin{3}; else Action = 'get'; end;
  if Narg>3  In1 = varargin{4};  else In1 = ''; end;
  if Narg>4  In2 = varargin{5};  else In2 = []; end;
  if Narg>5  In3 = varargin{6};  else In3 = []; end;

  switch sum(lower(Action))
  case cbslide_                                               % call back for slider (sets value readout)
     oldval = get(hs(slide),USER);    newval = get(hs(slide),VALUE);  sval = [];
     smax   = get(hs(slide),'max');   smin   = get(hs(slide),'min');
     dv = newval-oldval;  sdv = sign(dv);
     switch hs(mode1)
     case LININTQc,                                           % quantize to value in hs(quant)
        v = hs(quant)*round(newval/hs(quant));
        if v==oldval v = v + hs(quant)*sdv; end;
        newval = v;
     case LININTc,
        v = round(newval);
        if v==oldval v = v + sdv; end;
        newval = v;
     case LOGc, sval = newval; newval = exp(sval);             % log steps
     case POWOF2c,                                             % limit to 2^N
        if newval >= get(hs(slide),USER)-eps  newval=2^nextpow2(newval);
        else                                  newval=2^nextpow2(newval/2);
        end;
     case UNITc,
        pdv = abs(dv)/(smax-smin);
        if     pdv < .02   newval = oldval + hs(quant)*sdv;    % clicked on left/right arrow
        elseif pdv < .11   newval = oldval + hs(quant)*sdv*10; % clicked in trough
        end;
        newval = hs(quant)*round(newval/hs(quant));            % always quantize the result
     end; % end switch hs(mode1)
     if isempty(sval)
       if newval<smin newval = smin; elseif newval>smax newval = smax; end;
       sval = newval;
     end;
     set(hs(valro),STR,Pftoa(fmat(2,:),newval));
     set(hs(slide),VALUE,sval,USER,newval);
     evalRep(get(hs(maxtxt),USER),{'@VAL',sprintf('%g',newval)}); % invoke user callback function

  case cbedit_                                                   % call back for edit box (set slider position)
     newval = s2d(get(hs(valro),STR));    sval = [];
     minmax = get(hs(valro),USER);
     if isempty(newval)
         set(hs(valro),STR,Pftoa(fmat(2,:),get(hs(slide),VALUE)));
     else
        switch hs(mode1)
        case LININTc,  newval = round(newval);                   % nearest integer
        case POWOF2c,  newval = 2 ^ nextpow2(newval/1.414);      % limit to 2^N
        case LININTQc, newval=hs(quant)*round(newval/hs(quant)); % quantize to value in hs(quant)
        case LOGc,     newval = min(max(newval,minmax(1)),minmax(2));
                       sval = log(newval);
        end;
        newval = min(max(newval,minmax(1)),minmax(2));
        Ret1 = newval;
        set(hs(valro),STR,Pftoa(fmat(2,:),newval));
        if isempty(sval) sval = newval; end;
        sval = max(min(get(hs(slide),'max'),sval),get(hs(slide),'min'));
        if hs(mode1)==LOGc newval = exp(sval); end;
        set(hs(slide),VALUE,sval,USER,newval);
        evalRep(get(hs(maxtxt),USER),{'@VAL',sprintf('%g',newval)});  % invoke user callback function
     end;

  case get_
     switch sum(In1)
     case visible_,         Ret1 = sum(get(hs(label),VISIBLE)) == on_;
     case ena_,             Ret1 = sum(get(hs(label),'ena')) == on_;
     case obj_,             Ret1 = hs(label:lastobj);
     case {pos_ position_}, Ret1 = get(hs(label),POS);  Ret1 = Ret1(1:3);
     otherwise              Ret1 = get(hs(slide),USER);  % Ret1 = s2d(get(hs(valro),STR));
     end;
  case set_
     if isnumeric(In1) set(hs(valro),STR,num2str(In1));
                       Ret1 = plt('slider',Hin,'CBedit');
     elseif Narg>3  varargin(3)=[];  plt(varargin{:}); % remove optional set argument
     end;
  case value_
     set(hs(valro),STR,num2str(In1));
     Ret1 = plt('slider',Hin,'CBedit');
  case val_
     set(hs(valro),STR,num2str(In1));  % same as 'value' except the user callback is skipped
     sv = get(hs(maxtxt),USER);  set(hs(maxtxt),USER,'');
     Ret1 = plt('slider',Hin,'CBedit');
     set(hs(maxtxt),USER,sv);
  case vison_,  set(hs(label:lastobj),SHOW)
                if isempty(get(hs(label),STR)) set(hs(label),HIDE); end;
  case visoff_, set(hs(label:lastobj),HIDE);
  case enaoff_, set(hs([slide valro]),DISABLE);
  case enaon_,  set(hs([slide valro]),ENABLE);
  case {pos_ position_},
     ob = hs(label:lastobj);                    % will position these objects
     if ~iscell(In1)                            % manual positioning using length 4,5,8 vector
       len2 = length(In1);
       switch len2
         case 8,     In1 = {In1(1:4) In1(5:8)};
         case {4,5}, wid = 8+6*length(get(ob(1),STR)); dx = 2;  dy = 4;
                     if max(In1)<3 w=get(gcf,'pos'); wid=wid/w(3); dx=dx/w(3); dy=dy/w(4); end; % normalized
                     if len2==5 wid = In1(5); end;
                     if In1(4)>In1(3) pl = [In1(1)-(wid-In1(3))/2 In1(2)+In1(4)+dy wid 4*dy]; % vertical
                        else          pl = [In1(1)-wid-2*dx In1(2) wid In1(4)];               % horizontal
                     end;
                     In1 = {In1(1:4) pl};
       end;
     end;
     if iscell(In1)                            % Here for manual positioning
       if length(In1)==2                       % Here if only the slider & label positions are spec'd
         ps = In1{1}; pl = In1{2};             % slider position, slider label position
         if ps(4)>ps(3) pe = [pl(1) ps*[0;2;0;1]-pl*[0;1;0;1]-dx pl(3) pl(4)+dx]; % vertical slider
         else           pe = [ps*[2;0;1;0]-pl*[1;0;1;0] pl(2:4)];                 % horizontal slider
         end;
         In1 = {pl; ps; []; []; pe};
       end;  
       ie = find(cellfun('isempty',In1))';     % Empty positions will be moved off screen
       if max(In1{2})>3
             for k=ie In1{k}=[-99 9 9 9]; end;  set(ob,PIXELS,{POS},In1);
       else  for k=ie In1{k}=[2 2 .1 .1]; end;  set(ob,NORMAL,{POS},In1);
       end;
     else                                       % Here for automated postioning
       a = (get(0,'screenp')-96)/10;            % Adjustment for large fonts
       p = get(gcf,POS);  w = p(3);  h = p(4);  % figure width/height
       if length(In1<3) In1 = [In1 120]; end;   % default width
       lmax = 7 + 7*fix(s2d(fmat(3,2:(length(deblank(fmat(3,:)))-1))));
       lmin = 7 + 7*fix(s2d(fmat(1,2:(length(deblank(fmat(1,:)))-1))));
       if isnan(lmax) lmax = 28; end;           % handle formats with no number such as '%d'
       if isnan(lmin) lmin = 14; end;
       h0=a+SSP1c;  h1=HTXTc+a/2;  h2=HSLDc-a-1;  h3=a+HSLDc;  h5=h3+2;
       if In1(1)>=1                             % here if xy position is in pixels
         if In1(3)<1 In1(3) = In1(3)*w; end;    % make sure width is also in pixels
         In1(3) = max(In1(3),65);               % 65 pixels is pretty much the minimum width
         ya = In1(2) - h0;
         set(ob,PIXELS,{POS},...
                {[In1(1:3) h1];
                 [In1(1),In1(2)-SSP2c,In1(3),h2];
                 [In1(1),ya,lmin,h3];
                 [In1(3)+In1(1)-lmax,ya,lmax,h3];
                 [In1(1)+lmin,ya-1,In1(3)-(lmin+lmax),h5]});
       else                                     % here if xy position is in normalized units
         if In1(3)>=1 In1(3) = In1(3)/w; end;   % make sure width is also normalzied
         In1(3) = max(In1(3),65/w);             % 65 pixels is pretty much the minimum width
         h1=h1/h; h2=h2/h; h3=h3/h; h5=h5/h; ya = In1(2)-h0/h;  lmin=lmin/w;  lmax=lmax/w;
         set(ob,NORMAL,{POS},...
                {[In1(1:3) h1];
                 [In1(1),In1(2)-SSP2c/h,In1(3),h2];
                 [In1(1),ya,lmin,h3];
                 [In1(3)+In1(1)-lmax,ya,lmax,h3];
                 [In1(1)+lmin,ya-1/w,In1(3)-(lmin+lmax),h5]});
        end;
      end;  % end if iscell(Hin)
  case mode_
     hs(mode1) = In1(1);
     if length(In1)>1 hs(quant) = In1(2); end;
     set(hs(label),USER,hs); % save new mode
     Ret1 = plt('slider',Hin,'CBedit');
  case minmax_
     lg = hs(mode1)==LOGc;
     if lg mn=1e-99; else mn=-1e99; end;
     if length(In1)<4 In1 = [In1 mn 1e99]; end;
     set(hs(maxtxt),STR,[Pftoa(fmat(3,:),In1(2)) ' ']);
     set(hs(mintxt),STR,[' ' Pftoa(fmat(1,:),In1(1))]);
     set(hs(valro),USER,In1(3:4));
     if isempty(In2) v = s2d(get(hs(valro),STR)); % no target value was supplied
     else            v = In2;                     % use target value
     end;
     v = min(max(v,In1(3)),In1(4));               % limit to edit box min-max values
     set(hs(valro),STR,Pftoa(fmat(2,:),v));
     m1 = In1(1);  m2 = In1(2);
     if lg m1=log(m1); m2=log(m2); v=log(v); end;
     set(hs(slide),'min',m1,'max',m2,VALUE,min(max(m1,v),m2));
     Ret1 = s2d(get(hs(valro),STR));
  case label_,  set(hs(label),STR,In1);
                if isempty(In1) set(hs(label),HIDE); end;
  otherwise disp(sprintf('Invalid Action in plt(''slider''), Action=%s',Action));
  end;  % end switch(Action)
% end case 'slider'

case hcpy_    % function plt('hcpy',Action,In1,In2)
              % Hardcopy support - assumes only one hardcopy active at a time.
  Action = varargin{2};
  if Narg > 2  In1 = varargin{3};
               if Narg > 3  In2 = varargin{4}; end;
  end;
  switch sum(Action)
  case init_
     Hhcpy(PicFig)= In1;                  % owner figure handle
     if Narg ==4  renderer = In2; else renderer = '-painters';  end;
     Hhcpy(FigHC)=figure(NoMENU,'resize','off',POS,auxLoc(350,105),COLOR,dlgBKc,'name','Hardcopy',TAGg);
     foobar = 0;                          % see if we can restore state from file pltHcpy.mat
     if exist('foobar')                   % returns true only if running from matlab
                                          % for matlab code use folder containing plt.m
          cpath = feval('which','plt.m'); % use feval to prevent compiler warning
     else cpath = GetExe;                 % for compiled code use folder containing matlab.exe
     end;
     filen = [fileparts(cpath) filesep 'pltHcpy.mat'];
     if exist(filen) load(filen);
           % f = fopen(filen); if f>=0 fclose(f); load(filen); % alternate for above line for compiler (shouldn't need)
     else  % Do a manual job of restoring the two variables in the file here
           % These entries correspond 1:1 with handle indexes
           % These initial states MUST be self consistent or the scheme won't
           % work. e.g you can't have two pushbuttons in the same group on
           % and file edit is not enabled when the clip board is selected.
       z = [0 0];  t = z+1;  w = [0 1];
       pS1=[z;w;[2 1];w;t;w;t;z;t;w;w]; % 1st/2nd column = value/enable
       pS2 = 'temp.bmp';  % default file name
     end;
     Hhcpy(ModePU)   = POPUP(['Win Meta|Bit Map|HPGL|LaserJet IIp|Post Script|Encaps PS|Windows'],...
                             CALLBK,'plt hcpy ModePUcb;');
     Hhcpy(ColorRB)  = RADIO(COLOR,CALLBK,'plt hcpy rbg1 C;');
     Hhcpy(bwRB)     = RADIO('B&W',CALLBK,'plt hcpy rbg1 BW;');
     Hhcpy(ClipBdRB) = RADIO('Clip Board',CALLBK,'plt hcpy rbg2 cb;');
     Hhcpy(DevRB)    = RADIO('Device',CALLBK,'plt hcpy rbg2 dev;');
     Hhcpy(FileRB)   = RADIO('File',CALLBK,'plt hcpy rbg2 file;');
     Hhcpy(PathFile) = TEXT(pS2,LEFTalgn);
     Hhcpy(FileLBL)  = TEXT( 'Path/File:',LEFTalgn); % space after ( needed for mpp (why?)
     Hhcpy(PrintPB)  = BUTTON('Print',CALLBK,'plt hcpy print;',USER,renderer);
     Hhcpy(OpenPB)   = BUTTON('Select File',CALLBK,'plt hcpy OpenPBcb;');
     cncl            = BUTTON('Cancel',CALLBK,'close(gcf)');
     h1 = Hhcpy([ModePU ColorRB bwRB ClipBdRB DevRB FileRB]);
     h2 = Hhcpy([PathFile FileLBL]);
     h3 = [Hhcpy([PrintPB OpenPB]) cncl];
     set(h1,{VALUE},{pS1(ModePU,1); pS1(ColorRB,1); pS1(bwRB,1); pS1(ClipBdRB,1); pS1(DevRB,1); pS1(FileRB,1)});
     set([h1 h2],BACKGROUND,lblBKc,FOREGROUND,lblFRc);
     set([h1 h2 h3],{POS},{[115 80 100 15]; [ 10 85 65 15]; [10 70  65 15]; [245 85 95 15];
                           [245 55  95 15]; [245 70 95 15]; [10 35 330 15]; [ 10 50 65 15];
                           [110  5  55 20]; [ 10  5 85 20]; [180 5  55 20]});
     % do the enabelz skewed by one cause of FigHC=1
     for i=FigHC+1:PicFig-1
       if pS1(i,2)==1  set(Hhcpy(i),ENABLE); else set(Hhcpy(i),DISABLE); end;
     end;
     if get(Hhcpy(DevRB),VALUE) set(Hhcpy(OpenPB),STR,'Select Dev');
     else                       set(Hhcpy(OpenPB),STR,'Select File');
     end;
     % set(Hhcpy(FigHC),SHOW);
  case rbg1_
     switch sum(In1)
     case C_,  set(Hhcpy(ColorRB),vON); set(Hhcpy(bwRB),vOFF);
     case BW_, set(Hhcpy(bwRB),vON);    set(Hhcpy(ColorRB),vOFF);
     end;
  case rbg2_
     switch sum(In1)
     case dev_,  set(Hhcpy(ClipBdRB),vOFF);  set(Hhcpy(FileRB),vOFF);
                 set(Hhcpy(PrintPB),ENABLE); set(Hhcpy(PathFile),DISABLE);
                 set(Hhcpy(DevRB),vON);      set(Hhcpy(OpenPB),STR,'Select Dev',ENABLE);
     case cb_,   set(Hhcpy(ClipBdRB),vON);   set(Hhcpy(FileRB),vOFF);
                 set(Hhcpy(PrintPB),ENABLE); set(Hhcpy(PathFile),DISABLE);
                 set(Hhcpy(DevRB),vOFF);     set(Hhcpy(OpenPB),DISABLE);
     case file_, set(Hhcpy(ClipBdRB),vOFF);  set(Hhcpy(FileRB),vON);
                 set(Hhcpy(DevRB),vOFF);     set(Hhcpy(OpenPB),STR,'Select File',ENABLE);
                 fileN = get(Hhcpy(PathFile),STR);
                 if length(fileN)<5 fileN='none'; set(Hhcpy(PathFile),STR,fileN); end; % something wrong
                 if strcmp(fileN(1:4),'none') set(Hhcpy(PrintPB),DISABLE); end;
                 set(Hhcpy(PathFile),ENABLE);
     end;
  case ModePUcb_
     s = get(Hhcpy(ModePU),VALUE);  % the selection
     %     Win Meta   Bit Map    HPGL       LaserJet   PostScript Encaps PS  Windows
     en = [1 1 0 1 1; 1 1 0 1 0; 1 1 0 1 1; 1 1 0 0 1; 0 1 0 1 1; 0 1 0 1 1; 0 0 1 1 1];
     va = [0 1 0 1 0; 0 1 0 1 0; 0 1 0 0 1; 0 1 0 0 1; 0 1 0 1 0; 0 1 0 1 0; 0 0 1 1 0];
     ext= ['wmf';     'bmp';     'hgl';     'jet';     'ps ';     'eps';     'xxx']; ext=ext(s,:);
     if s==7  set(Hhcpy(OpenPB),STR,'Select Dev', ENABLE); set(Hhcpy(PathFile),DISABLE);
     else     set(Hhcpy(OpenPB),STR,'Select File',ENABLE); set(Hhcpy(PathFile),ENABLE);
              fileN = get(Hhcpy(PathFile),STR);  lf = length(fileN);
              if lf < 5 fileN='none'; set(Hhcpy(PathFile),STR,fileN); end;
              d = findstr('.',fileN);
              if length(d) set(Hhcpy(PathFile),STR,[fileN(1:d(end)) ext]); % legit extension, replace it
              else         set(Hhcpy(PathFile),STR,[fileN '.' ext]);       % add to it
              end;
     end;
     ena = {'off' 'on'};
     set(Hhcpy(ClipBdRB),'ena',ena{1+en(s,1)},VALUE,va(s,1));
     set(Hhcpy(FileRB),  'ena',ena{1+en(s,2)},VALUE,va(s,2));
     set(Hhcpy(DevRB),   'ena',ena{1+en(s,3)},VALUE,va(s,3));
     set(Hhcpy(ColorRB), 'ena',ena{1+en(s,4)},VALUE,va(s,4));
     set(Hhcpy(bwRB),    'ena',ena{1+en(s,5)},VALUE,va(s,5));
  case OpenPBcb_
     if strcmp('Select File',get(Hhcpy(OpenPB),STR))
        ext=['wmf';'bmp';'hgl';'jet';'ps ';'eps';'xxx']; ext=ext(get(Hhcpy(ModePU),VALUE),:);
        [fileN,pathN]= uiputfile(['*.',ext],'Open (new) File');
        if fileN
           fi = fileN;
           if isempty(findstr('.',fi)) fi = [fi '.' ext]; end;
           set(Hhcpy(PathFile),STR,[pathN fi]);  set(Hhcpy(PrintPB),ENABLE);
        end;
     elseif strcmp('Select Dev',get(Hhcpy(OpenPB),STR)) print -dsetup
     else   disp('Invalid OpenPBcb string');
     end;
  case print_
     invertStr= get(Hhcpy(PicFig),INVERTHC);  % just in case its on
     set(Hhcpy(PicFig),INVERTHC,'off');       % turn it off
     figure(Hhcpy(PicFig)); drawnow;          % change to figure to be plotted
     PrintMode = get(Hhcpy(ModePU),VALUE);
     colorFlg  = get(Hhcpy(ColorRB),VALUE);   % 1=color 0= quasi B&W
     % added explicit figure handle with -f option
     printStr = sprintf('print -f%d',Hhcpy(PicFig)); % start with this and build up
     renderer = get(Hhcpy(PrintPB),USER);     % zbuffer messes up doc->pdf !!!
     options={[' ' renderer ' -dmeta '];' -dbitmap ';' -dhpgl ';' -dljet2p '};
     if colorFlg options = [options; {' -dpsc ';' -depsc ';' -dwinc '}];
     else        options = [options; {' -dps ' ;' -deps  ';' -dwin  '}];
     end;
     printStr=[printStr options{PrintMode,:} ' '];  % add selected option to the string
     if get(Hhcpy(FileRB),VALUE)==1                 % we are printing to a file
        PathFilen = get(Hhcpy(PathFile),STR);  printStr=[printStr '''' PathFilen ''''];
     end;
     printStr = [printStr ' -noui'];  axh = [];  axh = findobj(Hhcpy(PicFig),'type','axes');  nax = length(axh);
     if ~colorFlg
        figC=get(Hhcpy(PicFig),COLOR);              % quasi monochrome (B&W)
        % save axis colors
        axChild = [];   axCol = zeros(nax,3);  axSpcl = zeros(nax,1); % mark 'none' color axes
        for i=1:nax
           x = get(axh(i),COLOR);
           if strcmp('none',x) axSpcl(i) = 1; else axCol(i,:)  = x; end;
           axChild = [axChild; get(axh(i),CHILDREN)];
           xCol(i,:) = get(axh(i),XCOLOR);  yCol(i,:) = get(axh(i),YCOLOR);
           tCol(i,:) = get(get(axh(i),'title'),COLOR);
           % if border color is same as figure background, it does not show therefore make it white by setting the axSpcl flag
           if xCol(i,:) == figC  axSpcl(i) = axSpcl(i) + 2; end;
        end;
        naxChild = length(axChild);
        for i=1:naxChild
           if sum(get(axChild(i),'type'))==patch_   kidCol(i,:) = get(axChild(i),'facecolor');
                                                    set(axChild(i),'facecolor',[.25 .25 .25]);
           else kidCol(i,:) = get(axChild(i),COLOR); set(axChild(i),COLOR,'black');
           end;
        end;
        set(Hhcpy(PicFig),COLOR,'white');
        for i= 1:nax
           if axSpcl(i)==1 | axSpcl(i)==3
           else set(axh(i),COLOR,'white');
           end;
           if axSpcl(i)>=2 set(axh(i),XCOLOR,'white',YCOLOR,'white' ); % axis border color is same as fig, don't show it
           else            set(axh(i),XCOLOR,'black',YCOLOR,'black' ); % normally make it black
           end;
        end;
        for i=1:nax  % deal with axis labels ....
           if get(get(axh(i),'title'),COLOR)==figC set(get(axh(i),'title'),COLOR,'white');
           else                                    set(get(axh(i),'title'),COLOR,'black');
           end;
           if axSpcl(i) >=2 % marked as being the same as the fig color therefore it does not show up
                set(get(axh(i),XLABEL),COLOR,'white'); set(get(axh(i),YLABEL),COLOR,'white');
           else set(get(axh(i),XLABEL),COLOR,'black'); set(get(axh(i),YLABEL),COLOR,'black');
           end;
        end;
     end; % end if ~colorFlg
     set(Hhcpy(FigHC),'pointer','watch'); drawnow; pause(1);
     if PrintMode == 2          % BitMap Mode... do not mess with pixels vs normalized for this mode
        set(Hhcpy(FigHC),HIDE); % seems to get in the way of v5
        refresh
        eval(printStr);
        set(Hhcpy(FigHC),SHOW); % seems to get in the way of v5
     else  drawnow discard;  eval(printStr);
     end;
     if ~colorFlg & (PrintMode ~=4 | PrintMode ~=7)
        % we were in B&W mode
        % restore all colors to the original values...
        set(Hhcpy(PicFig),COLOR,figC); % restore figure
        for i=1:nax
           if ~rem(axSpcl(i),2) set(axh(i),COLOR,axCol(i,:)); end;  % restore axis
           set(axh(i),XCOLOR,xCol(i,:)); set(axh(i),YCOLOR,yCol(i,:));
           set(get(axh(i),'title'),COLOR,tCol(i,:));
        end;
        for i=1:naxChild
           if sum(get(axChild(i),'type'))==patch_ set(axChild(i),'facecolor',kidCol(i,:));
           else                                   set(axChild(i),COLOR,kidCol(i,:));
           end;
        end;
        if PrintMode==2 drawnow; else drawnow discard; end; % must do a drawnow if bitmap is used XXXX 4.2 bug
     end;
     pS1=zeros(PicFig-1,2);               % retrieve state
     for i=FigHC+1:PicFig-1
        pS1(i,1) = get(Hhcpy(i),VALUE);
        if sum(get(Hhcpy(i),'ena'))==on_ pS1(i,2)=1; end;
     end;
     pS2=get(Hhcpy(PathFile),STR);
     foobar = 0;                          % save state to file pltHcpy.mat
     if exist('foobar')                   % returns true only if running from matlab
                                          % for matlab code use folder containing plt.m
          cpath = feval('which','plt.m'); % use feval to prevent compiler warning
     else cpath = GetExe;                 % for compiled code use folder containing matlab.exe
     end;
     save([fileparts(cpath) filesep 'pltHcpy.mat'],'pS1','pS2');  % save state to pltHcpy.mat
     close(Hhcpy(FigHC));                   % close this dialog for the print
     set(Hhcpy(PicFig),INVERTHC,invertStr); % restore
     clear Hhcpy                            % be a good citizen ...
  otherwise disp([Action ' invalid Action in plt(hcpy)']);
  end; % end switch Action
% end case 'hcpy'

case cursor_
% function [Ret1,Ret2] = plt('cursor',CurID,Action,In1,In2,In3,In4,In5,In6,In7,In8,In9)
%
%   Pseudo Object providing cursor & display expansion control
%
%   No expansion box visible:
%     Left click on or near a line and the cursor will jump to the line
%     AND the line is selected for value readout, peak/valley finding
%     or marking for delta x/y.
%
%     Left click on or near a line and drag, and the cursor will track on the line.
%     Left click inside the axis will also drag the cursor, but won't change the
%     line the cursor is on (if there were multiple lines).
%
%     Double click and HOLD after the 2nd click drag opens an expansion box.
%
%     The ^ button will find peaks of the data on the selected line
%     The v button finds valleys
%
%     Clicking the delta button marks a line at the current cursor position. Subsequent clicks
%     on the line will readout the cursor position and the difference from the marker.
%     The expand is disabled in delta mode. Click the delta button again to turn this mode off.
%
%   With expansion box open:
%     editing readout text specifies expansion coords and exp. box shows results
%     left click expands to box coordinates and right click cancels the expansion mode
%
%   Action
%   'init'
%           CurID  = [owner axis    handle of owner axis
%                       aux axis]   (optional) handle of aux axis
%
%                   Locations for cursor objects (IN PIXELS)
%           In1 = [ x y w h    x label              1
%                   x y w h    y label              2
%                   x y w h    x cursor readout     3
%                   x y w h    x cursor expansion   4
%                   x y w h    y cursor readout     5
%                   x y w h    y cursor expansion   6
%                   x y w h    peak button          7
%                   x y w h    valley button        8
%                   x y w h    delta button (mark)  9
%                   x y w h    line markers button  10
%                   x y w h];  x cursor slider      11 (OPTIONAL)
%
%           In2 = [ r g b      label color
%                   r g b      readout color  (if [0 0 0] track associated line color)
%                   r g b      expansion box color
%                   r g b      delta line color
%                   r g b      cursor color for cursor  #1 (if [0 0 0] use associated line color)
%                   r g b];    cursor/expansion line color for each cursor #2 (optional)
%                              must have r g b for each line object that has a cursor
%                  If In2 is empty the default is: [.7 .7 .7; 0 0 0; 1 1 .51; 1 0 0; 0 0 0];
%
%           In3 = ['xlabel'    x & y labels
%                  'ylabel']   or may use {'xlabel','ylabel'}
%                              If In3 is empty, ['x';'y'] is used
%
%           In4 = stylestr     cursor LineStyle e.g. '+','o','x'
%                              must have a Line Style for each line that has
%                              a cursor.
%           In5 = cursor size  eg. 6... 28 (points) MarkerSize (one size fits all)
%
%           In6 = [fmtxro      format string for x readout
%                  fmtyro]     format string for y readout
%                              e.g ['%2.1f';'%6.1f'] or {'%2.1f','%6.1f'}
%                              Note that this argument is optional.
%                              If In6 not included or is empty ['%7w';'%7w'] is used
%
%           In7 =              visible 'on' / 'off' (optional)
%           In8 =              monotonic flag (optional)
%                              set to 1 if data will have a monotonic x component
%                              set to 0 if it will not (e.g. Nyquist plots)
%                              leave undefined and test will be done to determine
%                              x monotonicity.
%           In9 =              axis limit change callback (optional) executed when axis limits
%                              are changed
%
%           Ret1 =             returns cursor ID needed for calling program to
%                              communicate with the cursor (integer)
%
%   For cursor calls OTHER THAN 'init',  CurID is set to an internally assigned integer that
%   was returned to the calling program in Ret1 during the init phase.
%
%            In1
%   'visON'        visibility of all cursor objects, normal cursor state resored (no expand, no delta)
%   'visOFF'
%   'aux'          In1='on'/'off' to show or hide aux cursor & its readout
%   'setObjPos'    reset position of objects with In1 per definition of 'init' action
%   'xlab'         x readout label
%   'ylab'         y readout label
%   'xylim'        set new xylimits, update expansion history
%                  In1=[xmin,xmax,ymin,ymax]
%                  In2=[ymin,ymax] for aux axis (optional)
%   'ylim'         new y limits, update y expansion history
%                  In2=[ymin,ymax] for aux axis (optional)
%   'xlim'         new x limits, update x expansion history
%   'exRestore'    restores array of expansion history and sets axis
%   'clrpk'        clears peak/valley finder data
%   'axisCB',cback user defined callback function when an axis limit change occurs
%   'moveCB',cback user defined callback when cursor moves
%   'moveCB2',cbcck auxiliary user defined callback when cursor moves
%   'setActive'    In1 is new active line number.
%                  In2 (optional) is the initial cursor index (default = 1)
%   'get'          returns cursor position for a line number In1 (optional)
%                  if no line number is given, assumes active cursor
%   'expHis'       returns expansion history
%   'getActive'    returns active Ret1=line number and Ret2=handle to same (useful for overlayed line implementation)
%   'update'              Moves to the cursor index indicated by In1 (defaults to current position)
%                         In2,In3 is x,y cursor position (if you want the cursor off the line)
%   'peakval'             In1=0 (move to peak) or In2=1 (move to valley)
%   'clear'               clear ID slot in CurMain. Repeated calls eventually
%                         clear the global to be a good citizen. This
%                         action should be executed when a cursor is no
%                         longer needed.
%   'MVcur'               set text & color of the cursor ID tag (moveCB2)
%   'panAX'               pan axes
%   'expbox'              draw an expansion box
%   'axisCB'              AXIS callback method
%   'lineCB'              LINE callback method
%   'AxisCBr'             clicked on right hand axis
%   'editCB'              edit box callback method
%   'svHist'              save expansion history after panning or zooming
%   'scale'
%   'xincr'               x axis label callback
%   'xslider'             xaxis slider control
%   'peakval'             Peak / Valley finder (what will it do with a relation ?)
%   'restore'             terminate expansion & restore cursor readout
%   'markCB'
%   'mlsCB'
%   'clear'               delete cursor objects & clear out slot
%   'scaleAxis'           scaleAxis
%   'ZoomOut'             zoom axis in/out
%   'mark'                Add a marker at current cursor location
%   'TGLlogy'             Toggle the y-axis from lin to log (or back)
%   'TGLlogx'             Toggle the x-axis from lin to log (or back)

    % For actions other than 'init', the cursor routine needs the cursor objects handle vector.
    % The following retrieves the handle vector: Hc .
    Action = 'update';  CurID = -1; % default action and CurID
    if MverE  ERAS = 'eras';  ERAXOR = 'xor';  ERANOR = 'norm'; % for Matlab R2014a or earlier
    else      ERAS = 'pi';    ERAXOR = 'v';    ERANOR = 'v';    % Matlab R2014b or later doesn't
    end;                                                        % support the erasemode property
    In1 = '';  In2 = '';  In3 = '';  In4 = '';  In5 = '';
    In6 = '';  In7 = '';  In8 = '';  In9 = '';
    if Narg > 1
       CurID = varargin{2};
       if Narg > 2
          Action = varargin{3};
          if Narg > 3
            In1 = varargin{4};
            if Narg > 4
              In2 = varargin{5};
              if Narg > 5
                In3 = varargin{6};  if iscell(In3) In3 = char(In3); end;
                if Narg > 6
                  In4 = varargin{7};
                  if Narg > 7
                    In5 = varargin{8};
                    if Narg > 8
                      In6 = varargin{9};  if iscell(In6) In6 = char(In6); end;
                      if Narg > 9
                        In7 = varargin{10};
                        if Narg > 10
                          In8 = varargin{11};
                          if Narg > 11 In9 = varargin{12}; end;
                        end;
                     end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
    CurMain = getappdata(0,'CurMain');
    sact = sum(lower(Action));
    if sact ~= init_
      % CurID contains an integer representing the index into CurMain
      % CurID=0 is equivalent to CurID = get(gca,'user')
      % CurID=-n is equivalent to tmp = getappdata(gcf,'cid'); CurID = tmp(-n);
      % CurMain(CurID) has the xaxis label handle. The userdata in the xaxis label
      % has all other handles including the owner axes & an auxilliary axis (on the bottom)
      % if two are overlayed.
      if ischar(CurID) CurID = sscanf(CurID,'%d'); end; % allow a string representation as well
      if ~CurID CurID = getappdata(gcf,'cidP');         % get previously used CurID
      elseif CurID<0 tmp = getappdata(gcf,'cid');  CurID = -CurID;
                     if CurID>length(tmp) return; else CurID = tmp(CurID); end;
      end;
      if CurID > length(CurMain) disp('invalid cursorID'); return; end;
      Hc = get(CurMain(CurID),USER);
      if isempty(Hc) disp('invalid cursor ID'); return; end;
      setappdata(gcf,'cidP',CurID);                     % save for "previously used cid"
      ax = Hc(iaxOwner);  ax2 = Hc(iaxAux);
      if isempty(get(ax2,PARENT)) ax2 = []; end;        % can't just test for zero after R2014b
      axlink = 0;                                       % indicate that right & left axes are not linked
      if ishandle(ax2)
           if sum(get(ax2,VISIBLE)) == off_  ax2=[];
           else axlink = [get(get(ax2,YLABEL),STR) '  '];
                axlink = axlink(1)~=backslash_ | axlink(2) ~= 'd';  % \div indicates unlinked
           end;
      end;
      hix = Hc(ixro);  hiy = Hc(iyro);
      misc = get(hix,USER);                % misc parameters
      actv = misc(Jact);                   % active cursor
      iact = icurbase + actv;              % active cursor offset
      ix   = misc(Jix);                    % active cursor x index
      hact = Hc(iact);                     % handle of active cursor
      lh = get(hact,USER);
      lk = lh{1};                          % handle to active line
      Ret1 = hact;  Ret2 = lk;             % default return values (active cursor and line handles)
      if ~ishandle(hact) return; end;
      xylim = [get(ax,XLIM) get(ax,YLIM)]; % axis limits (using left axis)
      xyli = xylim;
      if get(hact,PARENT)==ax2 xyli(3:4) = get(ax2,YLIM); end; % axis limits (with active cursor)
      DualCur = getappdata(ax,'DualCur');
    end;
    Narg2=Narg;
    switch sact
    case init_
      if MverE Hc = zeros(1,icurbase);     % Allocate all cursor objects
      else     Hc = gobjects(1,icurbase);  % (except the cursors themselves)
      end;
      ax = CurID(1); % For the init Action, CurID is a poor variable name.
          % It contains the owner axis handle & the (optional) auxiliary axis handle.
      DualCur = getappdata(ax,'DualCur');
      if isempty(DualCur) DualCur = 0;  setappdata(ax,'DualCur',0); end;
      Hc(iaxOwner) = ax;
      if length(CurID)==2  ax2 = CurID(2);  ax2a = ax2; else ax2 = [];  ax2a = 0; end;
      Hc(iaxAux) = ax2a;
      hf = get(ax,PARENT); % force objects to be created in proper figure
                           % with figure handle obtained from axis
      if isempty(In7) vis='on'; else vis=In7; end; % optional visibility arg
      % The global CurMain holds the xlabel object handles.
      % For each new invocation of cursor, search for a 0 which means a free slot.
      Cn = length(CurMain);
      f = find(~CurMain); % find the zeros (free slots)
      if length(f) CurID = f(1); % a free slot in the CurMain  vector, use it
      else CurMain = [CurMain 0]; CurID = Cn+1;  % no free slots, append to end
      end;
      if CurID>200 disp('Warning: Clear actions missing for 200 cursor inits'); end;
      Ret1 = CurID;   % return ID to calling program for subsequent calls to the cursor
      setappdata(gcf,'cidP',CurID);                % save for "previously used cid"
      CurIDstr  = {@plt 'cursor' CurID};
      if getappdata(gcf,'indep') CurIDstr0 = {@plt 'cursor' 0}; else CurIDstr0 = CurIDstr; end;
      % check for line objects to attach cursor callbacks to...
      hLines = getappdata(ax,'Lhandles');
      %if isempty(hLines)
      %  hLines = flipud(findobj(ax,'type','line')); % returns line objects in owner axis
      %end;
      skp = get(hLines,TAG);                       % get tags (check for 'SkipCur'
      if ~iscell(skp) skp = {skp}; end;            % in case there is only one line
      hLines = hLines(cellfun('length',skp) ~= 7); % remove lines with tag = 'SkipCur'
      axes(ax);  % select this as current axes object (needed only if subplot is used)
                 % bug in Matlab ver 2009b causes the figure to become visible after this command
      set(gcf,HIDE); % bug workaround
      % check readout colors, if black, track line color with readout background
      if isempty(In2) In2 = [.7 .7 .7; 0 0 0; 1 1 .51; 1 0 0; 0 0 0]; end; % use default if needed
      trk = ~sum(In2(2,:));
      if length(hLines) % create main cursors .....
         In2n = length(In2(:,1));
         clines = length(hLines);
         cli4 = clines + 4;
         if In2n < cli4
           % short on cursor colors, simply reproduce the last one specified in In2 to fill in the required array.
           In2 = In2(min(1:cli4,In2n*ones(1,cli4)),:);
           % for i=In2n+1:clines+4 In2(i,:) = In2(In2n,:);  end;  % same as above line
         end;
         In4n = length(In4);
         if In4n<clines
           In4 = In4(min(1:clines,In4n*ones(1,clines)));
           % for i=In4n+1:clines In4(i) = In4(In4n); end;   % same as above line
         end;
         In2n     = length(In2(:,1));
         objColor = In2(5:In2n,:);   % extract cursor colors
         tact = 0;                   % will be first visible trace
         if length(ax2) hLines2 = findobj(ax2,'type','line');  % lines in right axis
         else           hLines2 = 0;
         end;
         if MverE  Hc = [Hc zeros(1,clines)];    % Allocate the handles
         else      Hc = [Hc gobjects(1,clines)]; % for the cursors
         end;
         for i=1:clines
            hi = hLines(i);
            xy = [get(hi,XDATA); get(hi,YDATA)];
            if sum(objColor(i,:)) curColor = objColor(i,:);
            else                  curColor = get(hi,COLOR);
            end;
            Hc(icurbase+i)=line(XDATA,xy(1,1),YDATA,xy(2,1),ERAS,ERAXOR,COLOR,curColor,'linestyle','none',...
                            'clipping','on',VISIBLE,vis,USER,{hi trk});
            set(Hc(icurbase+i),'marker',In4(i),'MarkerSize',In5);
            % stash associated line handles in userdata, set owner axes line object callbacks
            set(hi,MOUSE,[CurIDstr {'lineCB' i}]);
            if ~tact & (sum(get(hi,VISIBLE))==on_) tact = i; end;
            if length(find(hi==hLines2)) set(Hc(icurbase+i),PARENT,ax2); end;
         end;
      else disp('no lines to attach cursors to')
      end;  % end if length(hLines)
      if max(max(In1))>2 unitt = 'Pixels'; else unitt = 'Normal'; end;
      % create labels & edit box objects
      fontsz = (196-get(0,'screenpix'))/10; % choose font appropriate to screen res
      for i=ixlabel:iylabel
        if i==ixlabel  cbStr  = 'x'; else cbStr  = 'y'; end;
        cbStr= [CurIDstr {'scaleAxis' cbStr}];
        if isempty(In3) In3 = ['x';'y']; end;  % default labels
        Hc(i) = uicontrol(hf,'Style','text',FONTSIZE,fontsz,VISIBLE,vis,STR,deblank(In3(i-ixlabel+1,:)),...
                'Units',unitt,POS,In1(i-1,:),BACKGROUND,In2(1,:),CENTERalgn,MOUSE,cbStr,INACTIVE);
      end; % end for i=ixlabel:iylabel
      bd1 = 'plt click EDIT '; bd2 = {'1;' '6 1;' '2;' '6 3;'};      % for buttondown function
      for i=ixro:iyexp
        cbStr  = [CurIDstr {'editCB' i-ixro}];                       % callback
        bdStr  = [bd1 bd2{i-ixro+1}];                                % buttondown function
        Hc(i) = uicontrol(hf,'Style','edit',FONTSIZE,fontsz,VISIBLE,vis,STR,' ','Units',unitt,POS,In1(i-1,:),...
            FOREGROUND,[0 0 0],LEFTalgn,CALLBK,cbStr,MOUSE,bdStr,TAG,sprintf('%d',CurID));
      end;  % end for i=ixro:iyexp
      set(Hc([ixexp iyexp]),HIDE);
      hix = Hc(ixro);  hiy = Hc(iyro);
      % create Peak/Valley/MarkerLineStyle/Delta buttons
      ih = [ipkbut ivalbut imlsbut imkbut];  c = [173 175 79 68];
      cbs = {{'peakval' 0} {'peakval' 1} {'mlsCB' ''} {'markCB' ''}};
      cbk = CurIDstr0;
      for k = 1:4
        m = ih(k);    pt = In1(m-1,:);
        if pt(1)<0 break; end;
        if k==4 cbk = CurIDstr; end;
        Hc(m) = uicontrol(hf,'Units',unitt,POS,In1(m-1,:),VISIBLE,vis,CENTERalgn,...
                  STR,char(c(k)),'fontname','symbol',BOLD,CALLBK,[cbk cbs{k}]);
      end;
      if k==1  % skip the creation of the 4 button group
        if MverE  Hc(ipkbut:imkbut) = -1;        % for Matlab R2014a or earlier
        else      Hc(ipkbut:imkbut) = gobjects;  % Matlab R2014b must use a null graphics object
        end;
      else
        set(Hc(ipkbut), UICONTEXT,uicontextmenu(CALLBK,[cbk {'peakval' 2}]));           % peak button right click
        set(Hc(ivalbut),UICONTEXT,uicontextmenu(CALLBK,[cbk {'peakval' 3}]));           % valley button right click
        set(Hc(imlsbut),UICONTEXT,uicontextmenu(CALLBK,'plt misc rstyle;'));            % marker line style button right click
        set(Hc(imkbut),FONTSIZE,12,UICONTEXT,uicontextmenu(CALLBK,'plt misc rdelta;')); % delta button right click
        setappdata(gcf,'peak',-inf); setappdata(gcf,'vall',inf);                        % reset peak valley finder
      end;
      Hc(imkline) = line(XDATA,[],YDATA,[],ERAS,ERAXOR,COLOR,In2(4,:),HIDE);
      set(Hc(imkline),'marker','+','MarkerSize',5*In5,TAG,'DeltaC');
      if isempty(In6) In6 = ['%7w';'%7w']; end;  % default format strings
      set(Hc(iylabel),USER,In6);                 % stash format strings
      if length(In1(:,1)) >= imkbut
        uicontrol(hf,'style','slider','Units',unitt,POS,In1(imkbut,:),...
             BACKGROUND,[.3 .3 .3],'Min',0,'Max',1000,VALUE,500,USER,500,...
             VISIBLE,vis,CALLBK,[CurIDstr {'xslider'}],TAG,'xslider');
      end;
      set(get(ax,XLABEL),MOUSE,[CurIDstr {'xincr'}]);
      i = [CurIDstr {'axisCB'}];
      Hc(iexpbox) = line(XDATA,[],YDATA,[],ERAS,ERAXOR,HIDE,COLOR,In2(3,:),MOUSE,i); % expansion box line object
      set([hf ax],MOUSE,i); % set figure & axis callback
      % store primary handle (Hc(ixlabel)) in owner axes userdata along with (optional) aux axis handle
      if isempty(In8) monoFlag = -1; else monoFlag = In8; end; % set up mono flag
      set(Hc(ixexp),USER,In9); % save axis limit change callback
      misc = zeros(1,Jlast);
      if length(ax2) set(ax2,MOUSE,[CurIDstr {'AxisCBr'}]); end;
      % enter new handle into CurMain vector
      misc(Jmonoflag) = monoFlag;
      misc(Jact) = max(1,tact);
      set(hix,USER,misc);
      set(Hc(iyexp),USER,''); setappdata(Hc(iyexp),'CB2',''); % clear cursor move callbacks
      set(Hc(ixlabel),USER,Hc);      % stash all handles related to this cursor
      CurMain(CurID) = Hc(ixlabel);  % stash in CurMain
      setappdata(0,'CurMain',CurMain);
    %**************************** End plt('cursor','init'...) section ****************************

    %-------------------------------------------------------------------------------
    case panax_  % pan axes
                 % In1=1:   drag only the y-axis
                 % In1=0:   drag only the x-axis
                 % In1=-1:  drag both axes
                 % In1='R': drag only the right hand y axis
      p0 = getappdata(get(ax,XLABEL),'OldCur');          % get old cursor location
      sc = get(ax,'yscale');  liny = sc(2)=='i';         % get y-axis lin/log
      if ischar(In1)                                     % right hand y-axis only
          aPt = get(ax2,CurPOINT);  cy = aPt(1,2);       % get current point
          y = get(ax2,YLIM);                             % update y limits only
          if liny  y = y + p0(2) - cy;                   % linear scale
          else     y = y * p0(2) / cy;                   % log scale
          end;
          set(ax2,YLIM,y);
      else
        aPt = get(ax,CurPOINT);                          % here for left hand axis (may be linked)
        cx = aPt(1,1);  cy = aPt(1,2);                   % get current point
        if In1<1 x = xylim(1:2);                         % update x limits
                 sc = get(ax,'xscale');
                 if sc(2)=='i' x = x + p0(1) - cx;       % linear scale
                 else          x = x * p0(1) / cx;       % log scale
                 end;
                 if length(ax2) axb = [ax ax2]; else axb = ax; end;
                 set(axb,XLIM,x);
        end;
        if In1   y = xylim(3:4);                         % update y limits
                 if liny  yi = p0(2) - cy;  y = y + yi;  % linear scale
                 else     yi = p0(2) / cy;  y = y * yi;  % log scale
                 end;
                 set(ax,YLIM,y);
                 if axlink                               % update right hand axis if linked
                   yr = get(ax2,YLIM);
                   if liny  yr = yr + yi * diff(yr)/diff(y);
                   else     yr = yr * (yr(2)/yr(1))^(log(yi)/log(y(2)/y(1)));
                   end;
                   set(ax2,YLIM,yr);
                 end;
        end;
      end;
      plt('grid',ax);
      fixMark;
    %-------------------------------------------------------------------------------
    case zoomax_ % zoom axes (In1 same as for 'panAX')
      p0 = getappdata(get(ax,XLABEL),'OldCur');                      % get old cursor location
      if ischar(In1)                                                 % right hand y-axis only
          aPt = get(ax2,CurPOINT);                                   % get current point
          y = get(ax2,YLIM);  y0 = y(1);  y1 = y(2);                 % get y limits
          cy = aPt(1,2)-y0;  if ~cy cy=1e-6; end;
          set(ax2,YLIM,[y0 y0 + abs((p0(2)-y0)*(y1-y0)/cy)]);        % new y limits
      else
        aPt = get(ax,CurPOINT); % get current point,x=aPt(1,2) y=aPt(1,2)
        if In1<1 x0 = xylim(1);  x1 = xylim(2);                      % get x limits
                 cx = aPt(1,1)-x0;  if ~cx cx=1e-6; end;
                 if length(ax2) axb = [ax ax2]; else axb = ax; end;
                 set(axb,XLIM,[x0 x0 + abs((p0(1)-x0)*(x1-x0)/cx)]); % new x limits
        end;
        if In1   y0 = xylim(3);  y1 = xylim(4);  dy = y1-y0;         % get y limits
                 cy = aPt(1,2)-y0;  if ~cy cy=1e-6; end;
                 cy = dy/cy;  p2 = p0(2)-y0;
                 set(ax,YLIM,[y0 y0 + abs(p2*cy)]);                  % new y limits
                 if axlink      % update right hand axis if linked
                    sc = get(ax,'yscale');
                    if sc(2)=='i'                                    % for linear y
                       y = get(ax2,YLIM);  y0 = y(1);  y1 = y(2);
                       p2 = (y1-y0) * p2 / dy;
                       set(ax2,YLIM,[y0 y0 + abs(p2*cy)]);
                    else                                             % for log y
                       yr = get(ax2,YLIM);  yr0 = yr(1);  yr1 = yr(2);
                       aPt = get(ax2,CurPOINT);
                       cy = aPt(1,2)-yr0;  if ~cy cy=1e-6; end;
                       p0 = yr0 * exp(log(p0(2)/y0) * log(yr1/yr0) / log(y1/y0));
                       set(ax2,YLIM,[yr0 yr0 + abs((p0-yr0)*(yr1-yr0)/cy)]);
                     end;
                 end;
        end;
      end;
      plt('grid',ax);
      fixMark;
    %-------------------------------------------------------------------------------
    case expbox_ % draw an expansion box
      expbx = Hc(iexpbox);  set(hact,HIDE);           % hide active cursor
      if DualCur set(Hc(icurbase+DualCur),HIDE); end; % hide dual cursor
      aPt  = get(ax,CurPOINT);        % new point:  x = aPt(1,1);  y = aPt(1,2);
      xCur = max(xylim(1),min(xylim(2),aPt(1,1)));  yCur = max(xylim(3),min(xylim(4),aPt(1,2)));
      aPt   = get(expbx,USER);        % old point already xylimited
      xOld  = aPt(1);  yOld  = aPt(2);
      % check size of box, if not too small, draw it.
      % This all may not be needed with double click scheme, its hard to screw up.
      if sum(get(ax,'yscale')) == log_
            dxyOk = abs(log(xylim(3)/xylim(4))) < 50 * abs(log(yOld/yCur));
      else  dxyOk = diff(xylim(3:4)) < 50 * abs(yOld-yCur);
      end;
      if dxyOk
         if sum(get(ax,'xscale')) == log_
               dxyOk = abs(log((.0001*xylim(2)+xylim(1))/xylim(2))) < 50 * abs(log(xOld/xCur));
         else  dxyOk = diff(xylim(1:2)) < 50 * abs(xOld-xCur);
         end;
      end;
      if dxyOk
          set(expbx,XDATA,[xOld xCur xCur xOld xOld],YDATA,[yOld yOld yCur yCur yOld]);
          f2 = get(Hc(iylabel),USER);  f1 = f2(1,:);  f2 = f2(2,:);  % formats stashed here
          if sum(get(expbx,VISIBLE)) == off_
             set(hix,STR,Pftoa(f1,xOld));  set(hiy,STR,Pftoa(f2,yOld));
             set(expbx,SHOW);  set(Hc(ixro:iyexp),ENABLE);
             set2(Hc(imkbut),DISABLE);               % disable delta button
          end;
          bf = {BACKGROUND; FOREGROUND};  
          set(Hc([ixexp iyexp]),{STR},prin([f1 ' ~; ' f2],xCur,yCur),bf,get(hix,bf),SHOW);
      end;
      mZoom([xOld xCur yOld yCur]); % execute MotionZoom function
    %-------------------------------------------------------------------------------
    case expbox2_ % move the expansion box keeping its dimentions unchanged
      aPt  = get(ax,CurPOINT);  new = complex(aPt(1,1),aPt(1,2));
      expbx = Hc(iexpbox);   xy = get(expbx,USER);  old = xy(1);
      xy = xy(2:end) + new - old;  x = real(xy);  y = imag(xy);
      set(expbx,XDATA,x,YDATA,y);
      f2 = get(Hc(iylabel),USER);  f1 = f2(1,:);  f2 = f2(2,:); s = ' ~; ';  % formats stashed here
      set(Hc(ixro:iyexp),{STR},prin([f1 s f1 s f2 s f2],x(1:2),y(2:3))); 
      mZoom([x(1:2) y(2:3)]);      % execute MotionZoom function
    %-------------------------------------------------------------------------------
    case {axiscb_, linecb_}, % AXIS & LINE callback methods
      if sact==axiscb_ & Narg2>3 & ~isnumeric(In1) set(Hc(ixexp),USER,In1); return; end; % set axis callback function
      b = get(hact,MOUSE); if length(b) & ischar(b) eval(b); return; end; % in case we are in edit mode
      clkType = MouseType;   % get type of mouse click
      co = plt('cursor',CurID,'obj');  ye = find(get(co(2),'str') == [168 62 68]); % get yedit mode from ylabel string
      expbx = Hc(iexpbox);
      boxVis = sum(get(expbx,VISIBLE));
      aPt  = get(ax,CurPOINT);  cx = aPt(1,1);  cy  = aPt(1,2);
      xCur = max(xylim(1),min(xylim(2),cx));  % mouse position (constrained within axis limits)
      yCur = max(xylim(3),min(xylim(4),cy));
      dxy = diff(xylim);
      smv = '';                               % will be the start motion string
      StopMotion = MOTIONoff;
      CurIDstr = {@plt 'cursor' CurID};
      % add check for visibility. If the cursor labels are not visible, don't mess with callbacks
      if (boxVis==off_) & ~misc(Jxexp) & ~misc(Jyexp)
         if     cx<xylim(1) | cx>xylim(2)   dragy =  1; % drag only the y-axis
         elseif cy<xylim(3) | cy>xylim(4)   dragy =  0; % drag only the x-axis
         else                               dragy = -1; % drag both axes
         end;
         if clkType == normal_ | (length(ye) & clkType==alt_ & sact==linecb_)
            ovt = 0;  % will indicate we would like the overlayed trace callback (or the
                      % trace is on the right hand axis)
            if sact==axiscb_
               Narg2 = 4;
               % the editbox or axis callbacks can get to this point.
               % therefore should check to see that the active cursor is on a visible line ....
               if sum(get(lk,VISIBLE)) ~= on_ % trouble: look for a visible one
                  for i=icurbase+1:length(Hc)
                      lh = get(Hc(i),USER);  lk = lh{1};
                      if sum(get(lk,VISIBLE)) == on_ break; end;
                  end;
                  actv = i-icurbase;
               end;
               In1 = actv; % assuming the active trace is visible, we stick with it.
               % Note: we now must do this messy loop because when you click on a line on the
               % right hand axis, the buttondown function does not execute because the primary
               % axis is on top, and its callback gets priority
               if length(ax2)
                 ylm = get(ax2,YLIM);  dylm = diff(ylm);
                 cvert = (cy - xylim(3)) / dxy(3);   % cursor vert pos (fraction of axis height)
                 mdst = 1e99;                        % will be minimum mouse click to line distance
                 idst = 0;                           % will be the index where mdst is achieved
                 for i=icurbase+1:length(Hc)         % search thru all lines on right hand axis
                   if get(Hc(i),PARENT) ~= ax2 continue; end; % skip cursors on left hand axis
                   lh = get(Hc(i),USER); lk = lh{1};
                   if sum(get(lk,VISIBLE)) == off_ continue; end; % skip invisible traces
                   x = get(lk,XDATA); y = get(lk,YDATA);
                   if length(x)>999 | all(diff(x)>0) % use cheaper method for montonic or long lines
                     [toss,j] = min(abs(xCur-x));    % closest data point on overlayed trace
                     dvert = (y(j) - ylm(1)) / dylm; % data vert pos (fraction of axis height)
                     acv = abs(cvert-dvert);         % click to line distance
                   else                              % use poor man's distance (no sqr root)
                     acv = min(abs((x-xCur)/dxy(1)) + abs((y-ylm(1))/dylm - cvert));
                   end;
                   if acv < mdst  idst = i;  mdst = acv; end; % remember which one is closest
                 end;
                 if mdst < .02  % was the click close enough to a line on left hand axis?
                   ovt = 1;     % yes, allow overlayed trace callback
                   ii = idst-icurbase;
                   if ii ~= DualCur In1 = ii; end; % set line to active cursor (if not the Dual cursor)
                 end;
               end; % end if length(ax2)
            end; % end if sact==axiscb_
            lh = get(Hc(icurbase+In1),USER); lk = lh{1}; % also has trk flag
            x = get(lk,XDATA); y = get(lk,YDATA);
            if Narg2==4  % Narg2 will == 5 when dragging so don't go through the monotonic test.
               setappdata(gcf,'peak',-inf); setappdata(gcf,'vall',inf); % reset peak valley finder
               if misc(Jmonoflag)==-1
                  df = diff(x);  % check if monotonic X, this was not spec'd on 'init'
                  monoFlag = all(df>0) | all(df<0);
               else monoFlag = misc(Jmonoflag);  % user specified in 'init'
               end;
            else monoFlag=In2;  % must be a drag callback
            end;
            if monoFlag [junk,imin] = min(abs(xCur-x)); % just use horizontal position
               % Using the horiz position doesn't work well for relations (such as nyquist plots)
               % so we find the point on the line closest to the click (poor man's distance
               % should be ok) normalized by axis limits.
            elseif get(lk,PARENT)==ax2
                  ylm = get(ax2,YLIM);  dylm = diff(ylm);
                  cvert = (cy - xylim(3)) / dxy(3); % cursor vert pos (fraction of axis height)
                  [toss,imin] = min(abs((x-xCur)/dxy(1)) + abs((y-ylm(1))/dylm - cvert));
            else  [toss,imin] = min(abs((x-xCur)/dxy(1)) + abs(yCur-y)/dxy(3));
            end;
            actv = In1;  misc(Jact) = actv;  % active cursor
            iact = icurbase + actv;          % active cursor offset
            hact = Hc(iact);                 % handle of active cursor
            set(hix,USER,misc);
            if length(getappdata(gca,'offline')) yimin = yCur; % offline mode: just go to the mouse location
            else                                 yimin = y(imin);  % no, go to the line location
            end;
            plt('cursor',CurID,'update',imin,x(imin),yimin);
            if (sact==linecb_) | ovt
              if Narg2==4  % 1st time its called, there is no drag
                smv = [CurIDstr {'lineCB' In1 monoFlag 0}];
              end;
            else setappdata(get(ax,XLABEL),'OldCur',[cx cy xylim]); % axis callback - do panning of axes
                 StopMotion = [CurIDstr {'svHist'}];
                 smv = [CurIDstr {'panAX' dragy}];
            end;
         elseif clkType == alt_  % this is a right click to expand or contract the axes
            setappdata(get(ax,XLABEL),'OldCur',[cx cy xylim]);
            StopMotion = [CurIDstr {'svHist'}];
            smv = [CurIDstr {'zoomAX' dragy}];
         else % this is a left double click or shift-click (clkType=open)
            set(expbx,USER,[xCur yCur]);
            StopMotion = [CurIDstr {'expSwap'}];
            smv = [CurIDstr {'expbox'}];   % draw an expansion box
         end; % end switch clkType
      elseif (boxVis==on_) | misc(Jxexp) | misc(Jyexp)
        if clkType==normal_
              cxy   = complex(cx,cy);  xyl13 = complex(xylim(1),xylim(3));  dxy13 = complex(dxy(1),dxy(3));
              cor5  = complex(get(expbx,XDATA),get(expbx,YDATA));
              cor = cor5(1:4);                    % corner coordinates
              corn = divc(cor-xyl13,dxy13);       % corner positions (normalized)
              edgn = (corn + corn([2 3 4 1]))/2;  % edge positions (normalized)
              curn = divc(cxy-xyl13,dxy13);       % mouse position (normalized)
              [cdst ci] = min(abs(curn-corn));    % nearest corner to mouse
              [edst ei] = min(abs(curn-edgn));    % nearest edge to mouse
              edst = edst/2;  dst = min(edst,cdst);
              StopMotion = [CurIDstr {'expSwap'}];
              if dst > .02 plt('cursor',CurID,'scale','new2'); % left mouse click not near the box expands
              elseif dst==cdst
                   c = cor(mod(ci+1,4)+1); set(expbx,USER,[real(c) imag(c)]);
                   smv = [CurIDstr {'expbox'}]; % drag expansion box corner
              else set(expbx,USER,[cxy cor5]);  smv = [CurIDstr {'expbox2'}];         % move expansion box (preserve size)
              end;
        else  plt('cursor',CurID,'restore');      % right mouse click just cancels the expand
        end;
        misc([Jxexp Jyexp]) = 0;  set(hix,USER,misc);
      end; % end if (boxVis==off_) & ~misc(Jxexp) & ~misc(Jyexp)
      if length(smv) set(gcf,'WindowButtonMotionFcn',smv,'WindowButtonUpFcn',StopMotion); end;
      if clkType~=open_ & sact==linecb_ & length(ye)
        plt('click','Yedit',7+ye,0); % enter edit mode automatically (persistent edit mode)
      end;
    %-------------------------------------------------------------------------------
    case axiscbr_ % clicked on right hand axis
      CurIDstr = {@plt 'cursor' CurID};
      aPt  = get(ax2,CurPOINT);  setappdata(get(ax,XLABEL),'OldCur',[aPt(1,1) aPt(1,2)]);
      if MouseRight smv = [CurIDstr {'zoomAX' 'R'}]; % right click
      else          smv = [CurIDstr {'panAX'  'R'}]; % left click
      end;
      set(gcf,'WindowButtonMotionFcn',smv,MOTIONstop);
    %-------------------------------------------------------------------------------
    case editcb_ % edit box callback method
      s = get(Hc(ixro:iyexp),STR);
      fmt = get(Hc(iylabel),USER);  % formats stashed here
      for k=0:3
        ss = s{k+1};
        if k==In1 x = str2num(ss); j = ixro+k;
                  if length(x) set(Hc(j),STR,Pftoa(fmt(1+(k>1),:),x));
                  else         set(Hc(j),STR,'invalid');  setappdata(gcf,'newtxt',ss);  return;
                  end;
        else      x = str2double(ss);
        end;
        w(k+1) = x;
      end;
      % if sum(get(Hc(iexpbox),VISIBLE))==on_
      if sum(get(Hc(iexpbox),VISIBLE))==on_ | misc(Jxexp) | misc(Jyexp) 
         set(Hc(iexpbox),XDATA,w([1 2 2 1 1]),YDATA,w([3 3 4 4 3]));     % here if expansion box is visible
         mZoom(w);                                                       % execute MotionZoom function
         plt('cursor',CurID,'expSwap');                                  % also execute MotionUp function
      else                                                               % here if no expansion box
        if getappdata(gcf,'indep')>0
           ci = getappdata(Hc(ixro+In1),'indep');
           if length(ci)   % in independent mode, use CurID from appdata to get the last cursor
              CurID = ci;  % that was modified in this column.
              if CurID > length(CurMain) disp('invalid cursorID'); return; end;
              Hc = get(CurMain(CurID),USER);
              if isempty(Hc) disp('invalid cursor ID'); return; end;
              setappdata(gcf,'cidP',CurID);        % save for "previously used cid"
              ax = Hc(iaxOwner);  ax2 = Hc(iaxAux);
              if isempty(get(ax2,PARENT)) ax2 = []; end;
              hix = Hc(ixro);  hiy = Hc(iyro);
              misc = get(hix,USER);                % misc parameters
              actv = misc(Jact);                   % active cursor
              iact = icurbase + actv;              % active cursor offset
              hact = Hc(iact);                     % handle of active cursor
              lh = get(hact,USER);
              lk = lh{1};                          % handle to active line
              xyli = [get(ax,XLIM) get(ax,YLIM)];  % axis limits (using left axis)
              if get(hact,PARENT)==ax2 xyli(3:4) = get(ax2,YLIM); end; % axis limits (with active cursor)
           end;
        end;
        xd = get(lk,XDATA);  yd = get(lk,YDATA);
        editd = length(get(hact,MOUSE)); % true if in edit data mode
        switch In1
          case 0, if editd set(hact,XDATA,w(1)); plt click EDIT 5 0; return; end;
                  [q ix] = min(abs(xd-w(1))); % find point with an x value closest to the entered value
          case 2, if editd set(hact,YDATA,w(3)); plt click EDIT 5 0; return; end;
                  [q ix] = min(abs(yd-w(3))); % find point with an y value closest to the entered value
          otherwise, return;  % This shouldn't happen ?
        end;
        xv = xd(ix);  yv = yd(ix);
        if xv<xyli(1) | xv>xyli(2) plt('cursor',CurID,XLIM,xv+[-.5 .5].*diff(xyli(1:2))); end;
        if yv<xyli(3) | yv>xyli(4) plt('cursor',CurID,YLIM,yv+[-.5 .5].*diff(xyli(3:4))); end;
        plt('cursor',CurID,'update',ix);
      end;
    %-------------------------------------------------------------------------------
    case expswap_  % motion button up function when drawing expansion box
      MOTIONOFF;   % stop the motion, then flop the limits if needed so that xexp>xro and yexp>yro
      expbx = Hc(iexpbox);
      x = get(expbx,XDATA); if length(x)<5 return; end; y = get(expbx,YDATA);
      if x(2)<x(1) x = x([2 1 1 2 2]);  set(expbx,XDATA,x);  s = get(Hc(ixexp),STR);
                   set(Hc(ixexp),STR,get(Hc(ixro),STR));  set(Hc(ixro),STR,s);
      end;
      if y(3)<y(2) y = y([3 3 2 2 3]);  set(expbx,YDATA,y);  s = get(Hc(iyexp),STR);
                   set(Hc(iyexp),STR,get(Hc(iyro),STR));  set(Hc(iyro),STR,s);
      end;
      a = getappdata(gca,'MotionZup');
      if length(a)
        b = [x(1:2) y(2:3)];
        if ischar(a)     feval(a,b);
        elseif iscell(a) a = [a {b}]; feval(a{:})
        else             a = {a b};   feval(a{:});
        end;
      end;
    %-------------------------------------------------------------------------------
    case svhist_       % save expansion history after panning or zooming
      MOTIONOFF;
      p0 = getappdata(get(ax,XLABEL),'OldCur');           % get old limits
      if any(xylim - p0(3:6))                             % here if any of the limits changed
        set(Hc(iexpbox),XDATA,[xylim(1:2) 0 0 0],...
                        YDATA,[xylim(3) 0 xylim(4) 0 0]); % fake expansion box
        set(ax,XLIM,p0(3:4),YLIM,p0(5:6));                % temporarily restore old limits
        plt('cursor',CurID,'scale','new',0,0);            % restore panned/zoomed limits
      end;                                                % last 2 arguments prevent axlink adjustment
    %-------------------------------------------------------------------------------
    case {update_ updateh_ updaten_}
      % In1 = index (not used if any other parameters are included)
      % In2 = x           
      % In3 = y           
      set(Hc(icurbase+1:end),HIDE);               % hide all cursor handles
      if ischar(In1) In1 = sscanf(In1,'%d'); end; % allow a string representation as well
      if isempty(In1) | ~In1 In1 = ix; end;       % index=0: use current index, check that cursored trace is visible, do callbacks
      if sum(get(lk,VISIBLE)) == off_             % if current trace is not visible
        for i=icurbase+1:length(Hc)               % look for the first one that is
          lh = get(Hc(i),USER); lk = lh{1};
          if sum(get(lk,VISIBLE)) == on_ break; end;
        end;
        actv = i-icurbase; misc(Jact) = actv;     % new active cursor index, update shadow
        iact = icurbase + actv;                   % active cursor offset
        hact = Hc(iact);                          % handle of active cursor
        if ~ishandle(hact) return; end;
      end;
      if sum(get(lk,VISIBLE)) == off_ return; end;   % nothing visible to cursor
      if isempty(In2)
        x = get(lk,XDATA);  y = get(lk,YDATA);  n = length(x);
        if ~n return; end;
        if In1>n | In1<=0                            % move to center if index out of range ---
           [toss,In1] = min(abs(mean(xyli(1:2))-x)); % closest data point to midpoint
         end;  
        In2 = x(In1);  In3 = y(In1);
      end;
      a = get(hact,PARENT);
      if length(getappdata(a,'subTr')) evalQ(get(Hc(ixexp),USER)); return; end;
      if a == ax  xyl = xylim;  else xyl = xyli; end;
      xlim = xyl(1:2);  ylim = xyl(3:4);
      xd = 1.01 * (In2-xlim);  yd = 1.01 * (In3-ylim);
      if xd(1)<=0 xlim = xlim + xd(1); elseif xd(2)>=0 xlim = xlim+xd(2); end;
      if yd(1)<=0 ylim = ylim + yd(1); elseif yd(2)>=0 ylim = ylim+yd(2); end;
      if ~isequal(xyl,[xlim ylim]) ...      % have the limits changed?
           & sact==update_ ...              % skip this for updateH or updateN
           & isempty(getappdata(a,'hold'))  % also skip this if the 'hold' appdata has been set
         setlim(a,XLIM,xlim); setlim(a,YLIM,ylim);
         if a==ax plt('grid',ax); end;
         evalQ(get(Hc(ixexp),USER));        % execute axis change callback
      end;
      set(hact,YDATA,In3,XDATA,In2,SHOW);   % show active cursor in new position
      multi = getappdata(ax,'multi');
      if length(multi)
        Lha = getappdata(ax,'Lhandles'); n = length(Lha); % get line handles
        for k = 1:n  yd = get(Lha(k),YDATA); yd = yd(min(In1,length(yd)));
                     set(multi(k),POS,[In2 yd],STR,prin(get(multi(k),TAG),yd));
                     set(multi(k+n),XDATA,In2,YDATA,yd);
        end;
        set(multi(end),XDATA,[In2 In2]);
      end;
      bf = {BACKGROUND FOREGROUND};
      fmt = get(Hc(iylabel),USER);                 % formats stashed here
      lc = get(lk,COLOR);                          % get line color
      fr = repmat(max(lc.*[.9 1 .5])<=.5,1,3);     % choose black or white for cursor text
      set([hix hiy],{STR},{Pftoa(fmt(1,:),In2); Pftoa(fmt(2,:),In3)},bf,{lc fr});
      dmode = sum(get(Hc(imkline),VISIBLE))==on_;  % true for delta mode
      if dmode                                     % delta mode --------------
         dxy = {Pftoa(fmt(1,:),In2-get(Hc(imkline),XDATA)); Pftoa(fmt(2,:),In3-get(Hc(imkline),YDATA))};
         set(Hc([ixexp iyexp]),{STR},dxy,bf,get(hix,bf),SHOW);
      end;
      if DualCur
        if DualCur>0 dact=icurbase+DualCur; ow=0; % positive DualCur specifies the trace number
        else dact = iact-DualCur;                 % negative DualCur means it's an offset from the primary cursor
             ow = (dact > length(Hc));            % true = need to go the opposite way
             if ow dact=iact+DualCur; end;        % go the opposite way if necessary
        end;
        Hcd = Hc(dact);
        dh = get(Hcd,USER); dk = dh{1};           % get line handle for dual cursor
        if sum(get(dk,VISIBLE)) == on_
          xy = [get(dk,XDATA); get(dk,YDATA)];
          misc(Jyaux) = xy(2,In1);
          xylen = length(xy(1,:)); if ix>xylen ix=xylen; end;  % xylimit fudge
          yd = xy(2,In1);
          a = get(Hcd,PARENT); b = get(a,'YaxisLoc');
          if b(1)=='r' b = get(a,YLIM); yd = max(b(1),min(b(2),yd)); end;
          set(Hcd,XDATA, max(xyli(1),min(xyli(2),xy(1,In1))),YDATA,yd,SHOW);
          if ~dmode set(Hc(ixexp),HIDE);                     % don't overwrite delta cursor values
                    s = Pftoa(fmt(2,:),xy(2,In1));
                    if ow t = s;  s = get(Hc(iyro),STR); set(Hc(iyro),STR,t); end; % swap iy & iyexp boxes
                    dc = get(dk,COLOR);                      % get line color
                    fr = repmat(max(dc.*[.9 1 .5])<=.5,1,3); % choose black or white for cursor text
                    set(Hc(iyexp),bf,{dc fr},STR,s,SHOW);
          end;
        end;
      end;
      misc([Jix Jx Jy]) = [In1 In2 In3];  set(hix,USER,misc);  % update numerical shadows
      s = getappdata(Hc(iyexp),'CB2');  evalQ(s);              % user defined callback (moveCB2)
          %%%%% Hack just for Matlab ver 2006a (Mouse button up event sometimes gets lost)
          %%%%% Don't seem to need this after swapping order of MoveCB & MoveCB2 (why??)
          %%%%%           if length(get(gcf,'WindowButtonUpFcn')) & ~isMouseDown
          %%%%%             set(gcf,{'WindowButtonMotionFcn','WindowButtonUpFcn'},{'',''});
          %%%%%           end;
      sx = getappdata(ax,'xstr');  sy = getappdata(ax,'ystr');  s = [sx sy];
      rep1 = {'@XVAL','real(@XY)',...
              '@YVAL','imag(@XY)',...
              '@XY',  'plt("cursor",@CID,"get")',...
              '@IDX', 'plt2nd({"cursor",@CID,"get"})',...
              '@LNUM','plt("cursor",@CID,"getActive")',...
              '@HAND','plt2nd({"cursor",@CID,"getActive"})',...
              '@XU'  ,'plt("misc",1)',...
              '@YU'  ,'plt("misc",2)',...
              '@CID', sprintf('%d',CurID)};
      for k=1:length(s)
        set(s(k),STR,evalRep2(getappdata(s(k),'evl'),rep1)); % xstring & ystring callbacks
      end;
      if length(getappdata(ax,'moveCBext')) | length(find(ax==findobj(gcf,'type','axes')))
        s = get(Hc(iyexp),USER);       % execute the moveCB callback only if the axis is in the
        if length(s) & sact~=updaten_  % current figure, or if 'moveCBext' is specified
          evalRep(s,rep1);             % Also skip the callback if updateN was used 
        end;
      end;
    %-------------------------------------------------------------------------------
    case scale_
      expHis = get(hiy,USER);  % retrieve the expansion history
      % col 5 has a marker for the current expansion
      % 1st scale operation, save original axis limits and mark as current
      if isempty(expHis) expHis = [xylim 1]; end;
      lExp   = length(expHis(:,1));  % get length of expansion history
      curExp = find(expHis(:,EXPFLAGc)==1); % find current scale selection
      skip   = [];   In1S = sum(In1);  new2r = (In1S==new2_);
      switch In1S
      case {new_ new2_} % set axis scale limits per expansion box dimensions
         xy = Hc(iexpbox);  xy = [get(xy,XDATA) get(xy,YDATA)];
         expLim = [sort(xy(1:2)) sort(xy([6 8])) 1];
         if isequal(xylim,expLim(1:4))   % same limits
            if length(curExp) expHis(curExp,EXPFLAGc)=1; end; % set current expansion marker to a 1
         else
            if length(curExp) % set current expansion marker to a 0. (we will gen a new one)
               expHis(curExp,EXPFLAGc)=0;
               if max(curExp,lExp) < EXPMAXc
                  expHis = [expHis; expLim]; % simply append new data
               else  % the max depth has been attained, circulate expansions.
                  if curExp==EXPMAXc  expHis(2:EXPMAXc,:)=[expHis(3:EXPMAXc,:); expLim];
                  elseif curExp >= 1  expHis(curExp+1,:)=expLim;
                  end;
               end;
            else    % was autoscaled  (all zeros in EXPFLAG column)
               if lExp < EXPMAXc  expHis = [expHis; expLim]; % room to add one more
               else               expHis = [expHis(lExp-1,:); expLim];
               end;
            end;
         end;
         autoScale=NONEc;
      case old_ % find where we are and back down history by 1 till rock bottom then roll around.
          if MouseRight autoScale=BOTHc;  % always autoscale for right click
          else  % left click ----
            if isempty(curExp) curExp = lExp;  % was autoscaled move to end
            else               expHis(curExp,EXPFLAGc)=0;  curExp = curExp-1;
            end;
            % if curExp == 1 fprintf(1,'%c',7); end;  % unit beep, we are @ original display limits
            if curExp  autoScale=NONEc;  expLim=expHis(curExp,:); expHis(curExp,EXPFLAGc)=1;
            else       autoScale=BOTHc;    % autoscale if we back through bottom
            end;
          end;
      case auto_
          switch sum(In2)
          case x_,    autoScale=XONLYc;
          case y_,    autoScale=YONLYc;
          case both_, autoScale=BOTHc;
          otherwise, disp([In2 ' is not a valid action in plt(cursor,CurID,scale,auto,In2)']);
          end;
      otherwise, disp([In1 ' is not a valid action in plt(cursor,CurID,scale,In1)']);
      end; % end switch In1
      if autoScale == NONEc  % use expLim scales
          setlim(ax,XLIM,sort(expLim(1:2)));
          setlim(ax,YLIM,sort(expLim(3:4)));
          wii = 0;
      else % auto scale axes and then update expLim for use if there is an aux axis
           % move cursors onto an active line for the moment to facilitate autoscaling
         numLines=length(Hc)-icurbase;  minx=+inf;  maxx=-inf;
         temp = zeros(numLines,2);  lineList = [];   wii = 1; % pessimist
         for i=1:numLines
            hLine=get(Hc(icurbase+i),USER);
            if sum(get(hLine{1},VISIBLE)) == on_
               % line is visible, can have an active cursor on invisible line ...
               % therefore this search is needed.
               xdata = get(hLine{1},XDATA);
               minx  = min(minx,min(xdata));      % must consider Nyquist
               maxx  = max(maxx,max(xdata));      % so min & max are not at ends
               if wii ydata = get(hLine{1},YDATA); end;
               lineList = [i lineList];  wii = 0; % a line is alive
            end;
         end;

         if wii msgbox('Possible autoscale without any visible lines','Warning','warn','modal');
         else
            for i=1:numLines
              k = Hc(icurbase+i);
              tx = get(k,XDATA);  ty = get(k,YDATA);
              temp(i,:) = [tx(1) ty(1)];
              set(k,XDATA,xdata(1),YDATA,ydata(1));
            end;
            %   Yaxis auto scales OK here, but Xaxis is suboptimal on zoomed data
            %   therefore use min / max of Xdata to scale x axis.
            skip = findobj(ax,NoCUR,SHOW); set(skip,HIDE);
            switch autoScale
            case BOTHc,  set(ax,YLIMauto);                   % Y autoscale
                         expLim = [minx maxx get(ax,YLIM) 1];
                         setlim(ax,XLIM,expLim(1:2));        % X scale
            case XONLYc, expLim = [minx maxx get(ax,YLIM) 1];
                         setlim(ax,XLIM,expLim(1:2));        % X scale
            case YONLYc,
               misc=get(hix,USER);                           % misc parameters
               if ismember(actv,lineList)
                  ydata = get(lk,YDATA);
                  ymax = max(ydata);  ymin = min(ydata);  dy = 0.25*(ymax-ymin);
                  ymin = ymin - dy;   ymax = ymax + dy;
                  if ymin ~= ymax  set(ax,YLIMman); set(ax,YLIM,[ymin ymax]); drawnow;
                  else             set(ax,YLIMauto);  drawnow;
                  end;
               else set(ax,YLIMman); drawnow; set(ax,YLIMauto); % drawnow seems to make it reliable
               end;
               expLim = [xylim 1];
            end;
            for i=1:numLines set(Hc(icurbase+i),XDATA,temp(i,1),YDATA,temp(i,2)); end; % restore cursor positions
         end;  % end if wii
      end;     % end if autoScale == NONEc
      if ~wii
         if length(ax2) setlim(ax2,XLIM,expLim(1:2)); end;
         set(hiy,USER,expHis);                 % save history
         if axlink & Narg<6                    % update right hand axis if linked
           yr = get(ax2,YLIM);
          setlim(ax2,YLIM,yr(1) + (get(ax,YLIM) - xylim(3)) * diff(yr) / (xylim(4)-xylim(3)));
         end;
         if new2r plt('cursor',CurID,'restore'); end;
         axes(ax); evalQ(get(Hc(ixexp),USER)); % execute axis change callback stored in here
      end;
      set(ax,YLIMman);
      set(skip,SHOW);
      plt('grid',ax);
      xView = getappdata(ax,'xView');
      if length(xView) set(xView{1},XDATA,get(ax,XLIM)); end;
    %-------------------------------------------------------------------------------
    case xincr_,   % x axis label callback
      lx = length(get(lk,XDATA));
      ty = MouseType;
      if ty==open_ & getappdata(gcbo,'ty')==alt_ ty = alt_; end; % double left/right click moves twice right/left
      [rpt p] = getREPEAT;                                       % get custom or default repeate rate
      setappdata(gcf,'bdown',1);
      set(gcf,'WindowButtonUp','setappdata(gcf,''bdown'',0);');
      while getappdata(gcf,'bdown')                              % loop until user lets go of mouse
        if ty==alt_ ix = max(ix-1,1);                            % right click)
        else        ix = min(ix+1,lx);                           % left click
        end;
        setappdata(gcbo,'ty',ty);
        plt('cursor',CurID,'update',ix);                         % update main cursor
        if rpt < 0 break; end;                                   % disable repeating by setting a negative repeat rate 
        pause(p);  p = rpt;                                      % repeat rate
      end;
    case xslider_, % xaxis slider control
      x = get(lk,XDATA);   y = get(lk,YDATA); lx = length(x);
      xlim = xylim(1:2);   ylim = xylim(3:4);  dxlim = diff(xlim);
      v = get(gcbo,VALUE);  x1 = min(x);  x2 = max(x);   xrange = x2 - x1;
      if xrange/dxlim < 2   % here if x-axis is not expanded (or expanded just a little)
        dx = round(v - 500);
        if abs(dx)==10 pmove = .01; else pmove = .05; end; % slider arrow/trough  - move 1%/5%
        ix = max(min(lx,ix + sign(dx)*round(lx*pmove)),1);
        x = x(ix);  xd = 1.01 * (x-xlim);
        if xd(1)<0 xlim = xlim + xd(1); elseif xd(2)>0 xlim = xlim+xd(2); end;
        v = 500;
      else                  % here if x-axis is expanded significantly (2 or more)
        dx = v - get(gcbo,USER);
        switch round(abs(dx))
          case 10,   xlim = xlim + sign(dx)*dxlim/10;       % 10  percent of dx for arrow
          case 100,  xlim = xlim + sign(dx)*dxlim;          % 100 percent of dx for trough
          otherwise, xlim = x1 + xrange*v/1000 + dxlim*[-.5 .5];
        end;
        if     xlim(1)<x1  xlim = [x1 x1+dxlim] - dxlim/50; % limits go at most 2% beyond the data
        elseif xlim(2)>x2  xlim = [x2-dxlim x2] + dxlim/50;
        end;
        xlc = mean(xlim);
        v = 1000*(xlc-x1)/xrange;
        v = max(min(v,1000),0);                             % not sure if we really need this
        [dmy ix] = min(abs(xlc-x));
      end;
      set(gcbo,VALUE,v,USER,v);
      y = y(ix);  yd = 1.01 * (y-ylim);
      if yd(1)<0 ylim = ylim + yd(1); elseif yd(2)>0 ylim = ylim+yd(2); end;
      if sum(xylim - [xlim ylim])       % have the limits changed?
         set(ax,XLIM,xlim,YLIM,ylim);   % yes
         if length(ax2) set(ax2,XLIM,xlim); end;
         plt('grid',ax);
         evalQ(get(Hc(ixexp),USER));    % execute axis change callback
      end;
      plt('cursor',CurID,'update',ix);
    case peakval_ % Peak / Valley finder (what will it do with a relation ?)
      if ischar(In1) In1 = s2i(In1); end;           % allow string index as well
      switch In1                                    % right click on pk/valley buttons comes here
        case 2, In1=0; setappdata(gcf,'peak',-inf); % reset peak finder
        case 3, In1=1; setappdata(gcf,'vall',inf);  % reset valley finder
      end;
      y = get(lk,YDATA); x = get(lk,XDATA);
      xx = find(x <= xylim(2) & x >= xylim(1)); % indicies within x limits
      if isempty(xx) x = xylim(1); xx = 1:length(x); disp('You must select a line for the min/max finder'); end;
      y = y(xx);  ly = length(y);               % y data within x limits
      if In1                                    % In1=1, valley finder
         ix=find(y < [y(2:ly) inf] & ...        % must be < point on right
                 y < [inf  y(1:ly-1)] & ...     % must be < point on left
                 y > getappdata(gcf,'vall'));   % must be > previous valley
         if isempty(ix)
              [y ix] = min(y);                  % no more valleys: go to min
         else [y i]  = min(y(ix));
              ix = ix(i);                       % there are more: go to smallest
         end;
         setappdata(gcf,'vall',y);              % save amplitude of the valley
      else                                      % In1=0, peak finder
         ix=find(y > [y(2:ly) -inf] & ...       % must be > point on right
                 y > [-inf y(1:ly-1)] & ...     % must be > point on left
                 y < getappdata(gcf,'peak'));   % must be < previous peak
         if isempty(ix)
              [y ix] = max(y);                  % no more peaks: go to max
         else [y i] = max(y(ix));
              ix = ix(i);                       % there are more: go to biggest
         end;
         setappdata(gcf,'peak',y);              % save amplitude of the peak
      end; % end if In1
      ix = ix + xx(1) - 1;                      % translate index to point to full data block
      plt('cursor',CurID,'update',ix);
   %-------------------------------------------------------------------------------
    case restore_ % terminate expansion and restore cursor readout
      fmt = get(Hc(iylabel),USER);  % formats stashed here
      set(hiy,STR,Pftoa(fmt(2,:),misc(Jy)));
      set(hix,STR,Pftoa(fmt(1,:),misc(Jx)));
      set(Hc(iexpbox),HIDE);
      if sum(get(Hc(imkline),VISIBLE)) == off_
         set(Hc([ixexp iyexp]),HIDE,STR,'');
      end;
      set(hact,YDATA,max(xyli(3),min(xyli(4),misc(Jy))),...
               XDATA,max(xyli(1),min(xyli(2),misc(Jx))));
      set(Hc([ixlabel:iylabel]),INACTIVE);  set2(Hc(imkbut),ENABLE);
    %-------------------------------------------------------------------------------
    case mlscb_    % marker line style button callback
        l = getappdata(ax,'Lhandles');                  % get all lines assigned to this axis
        % l = getappdata(gcf,'Lhandles');               % perhaps add an option for all lines?
        MRK ='marker';  STY = LINESTYLE;
        k = getappdata(ax,'mls');
        if isempty(k) k=1;
                      setappdata(ax,'mrk',get(l,MRK));  % save original line markers
                      setappdata(ax,'sty',get(l,STY));  % save original line styles
        end;
        mrk = 'o';  sty = getappdata(ax,'sty');         % case 2: switch to markers plus original style
        switch k
          case 1, sty = 'none';                         % switch to markers only
          case 3, mrk = getappdata(ax,'mrk'); k = 0;    % revert to original markers & style
                    
        end;
        setappdata(ax,'mls',k+1);
        if iscell(mrk) MRK = {MRK}; end;
        if iscell(sty) STY = {STY}; end;
        set(l,MRK,mrk,STY,sty);
    %-------------------------------------------------------------------------------
    case markcb_
      set(Hc(imkbut),BACKGROUND,1-get(Hc(imkbut),BACKGROUND)); % complement color of delta button
      if sum(get(Hc(imkline),VISIBLE)) == off_
            setappdata(ax,'DualCsv',DualCur);  % save DualCur
            setappdata(ax,'DualCur',0);        % turn DualCur off while delta cursors are active
            set(Hc(imkline),SHOW,PARENT,get(hact,PARENT),USER,actv,...
                XDATA,get(hact,XDATA),YDATA,get(hact,YDATA));
      else  set(Hc([imkline ixexp iyexp]),HIDE); % bug in matlab R2009b causes cursor to disappear here
                                                 % (when ixexp or iyexp visibility is turned off)
                                                              % BUG FIX HERE ---------------------------
            set(lk,HIDE); drawnow; set(lk,SHOW);              % for some reason, this restores the cursor
            DualCur = getappdata(ax,'DualCsv');               % restore DualCur state
            if DualCur setappdata(ax,'DualCur',DualCur); end; % re-enable dual cursor
      end;
    %-------------------------------------------------------------------------------
    case mvcur_  % set text & color of the cursor ID tag (moveCB2 function)
      fg = get(hix,PARENT);
      a = findobj(fg,isTraceID)';
      if length(a)>1 for k=a if getappdata(k,'cid')==CurID a=k; break; end; end; end;
      a = flipud(findobj(a,'type','text'));
      if length(a)<actv  d = 'Yval';      % only one trace or not enough TraceIDs
      else d = deblank(get(a(actv),STR)); % otherwise get TraceID text
      end;
      b = findobj(fg,MOUSE,'plt click RMS;')';
      if length(b)>1 for k=b if get(k,USER)==ax b=k; break; end; end; end;
      set(b,{STR,COLOR},{d,get(hact,COLOR)});
      bx = getappdata(fg,'bx');                   % find cursor listbox
      if length(bx) & ishandle(bx)
        ha = get(get(bx,PARENT),POS);  ha=ha(4);  % get height of figure window
        nb = round(.03839*ha - 2.27);             % # of lines above & below the cursor (fontsize=9)
        s = get(bx,USER);  t = s{2}; s = s{1};
        d = d(1:min(9,length(d))); f = findstr(d,t);
        if isempty(f) v=''; else v = [blanks(f(1)-1) repmat('v',1,length(d))]; end; % point to the cursored data
        set(bx,STR,[s(1:ix-1) {t v} s(ix:end)],'Value',ix+1);
        drawnow;                            % needed only for R2014b (Matlab bug?)
        set(bx,'ListboxTop',max(1,ix-nb));  % can't combine this with set(bx) command above (R2014b only)
      end;
    %-------------------------------------------------------------------------------
    case obj_
      % return: = [handle 1 - x label               (userdata stores all object handles)
      %            handle 2 - y label               (userdata stores readout edit box formats)
      %            handle 3 - x cursor readout      (userdata has misc parameters - see J indicies)
      %            handle 4 - x cursor expansion    (userdata has axis change callback)
      %            handle 5 - y cursor readout      (userdata stores expansion history)
      %            handle 6 - y cursor expansion    (userdata has cursor move callback)
      %            handle 7 - peak button           (userdata has peak)
      %            handle 8 - valley button         (userdata has valley)
      %            handle 9 - marker line style btn
      %            handle 10- delta button        
      %            handle 11- expansion box         (userdata stores point for axis click)
      %            handle 12- delta cursor          (userdata has who was active when the mark was made)
      %            handle 13- cursor                (userdata(1) has associated line handle)
      Ret1 = [Hc(ixlabel:imkline) hact];
    case get_  % return x,y position of cursor in Ret1 (complex)
               % returns corresponding index into data array in Ret2
      if Narg2==4 if ~isnumeric(In1) disp('Error: plt(''cursor'',cid,''get'',arg) arg must be numeric'); return; end;
                  lineNum = In1;
      else        lineNum = actv;
      end;
      k = Hc(icurbase+lineNum);
      Ret1 = complex(get(k,XDATA),get(k,YDATA));
      Ret2 = ix;
    case getactive_
      Ret1 = actv;     % active line number
      Ret2 = lk;
      if Narg>3 & sum(get(Ret2,VISIBLE))==off_
        Ret1 = 0;      % used by set dual cursor menu to turn off dual cursors
      end;  
    case exphis_
      % need to return an array of a consistant shape
      % e.g 4x5 = EXPMAXc x EXPFLAGc ...  being [xmin,xmax,ymin,ymax,select_flag];
      % plus the aux axis scales at end of array yielding a 5x5 array
      %
      % data in the 5th column is a flag...
      % 0=valid expansion, not active
      % 1=valid expansion, active ... there can only be one of these
      %-1=invalid expansion, never active
      % 2=valid expansion, for use by 2nd axis
      expHis = get(hiy,USER);
      if isempty(expHis) % nobody home, we must make one....
         Ret1  = [[xylim 1]; [zeros(EXPMAXcm,EXPFLAGcm), -ones(EXPMAXcm,1)]];
      else aa = EXPMAXc - length(expHis(:,1));
           Ret1 = [ expHis; [ zeros(aa,EXPFLAGcm), -ones(aa,1) ] ];
      end;
      if length(ax2) Ret1 = [Ret1; [get(ax2,XLIM) get(ax2,YLIM) 2]];  % dual axis
      else           Ret1 = [Ret1; [zeros(1,EXPFLAGcm) -1]];
      end;
    case visoff_    % turn cursor objects off
       h = Hc([ixlabel:imkbut icurbase+1:end])';
       h = [h(ishandle(h)); findobj(gcf,TAG,'xslider')];
       for k = findobj(gcf,MOUSE,'plt click RMS;')' if get(k,USER) == gca  h = [h; k]; end; end;
       for k = [getappdata(gca,'xstr') getappdata(gca,'ystr')] h = [h; k]; end;
       h = findobj(h,SHOW);
       set(h,HIDE);
       setappdata(Hc(ixlabel),'hid',h);     % save objects for visON
    case vison_, set(getappdata(Hc(ixlabel),'hid'),SHOW); % turn cursors back on
    case setobjpos_
       % In2 = [x y w h  x label                  1
       %        x y w h  y label                  2
       %        x y w h  x cursor readout         3
       %        x y w h  x cursor expansion       4
       %        x y w h  y cursor readout         5
       %        x y w h  y cursor expansion       6
       %        x y w h  peak button              7
       %        x y w h  valley button            8
       %        x y w h  marker line style button 9
       %        x y w h  delta button             10
       for i=ixlabel:imkbut if ishandle(Hc(i)) set(Hc(i),POS,In1(i-1,:)); end; end;
    case xlab_,     set(Hc(ixlabel),STR,In1); % x readout label (probably not used anywhere?)
    case ylab_,     set(Hc(iylabel),STR,In1); % y readout label (probably not used anywhere?)
    case movecb_,   if length(In1) & ischar(In1) & In1(1)==';'      % first char is ';'
                       setappdata(ax,'moveCBext',1);  In1(1) = [];  % allow external
                    end;
                    set(Hc(iyexp),USER,In1);  % set cursor move callback
    case movecb2_,  setappdata(Hc(iyexp),'CB2',In1); % set cursor auxiliary move callback
    case {xylim_,ylim_,xlim_},
      oldEh = get(hiy,USER);
      expHis = oldEh;
      if length(expHis)
          curExp = find(expHis(:,EXPFLAGc)==1); % find current scale selection
          if length(curExp) expHis(curExp,EXPFLAGc)=0; end;
      end;
      % attempt to save most of old expansion history by replacing only the 1st entry in list v >2.07
      switch sact
        case xylim_, xyl = In1;  expHis(1,:) = [xyl 1];
        case ylim_  % In1 has main axis limits, xyl = [xylim(1:2),In1];
           if length(oldEh)  expHis(1,:) = [xylim(1:2) In1,1];  xyl = [xylim(1:2) In1];
           else              expHis=[];                         xyl = [xylim(1:2) In1];
           end;
        case xlim_
           if length(oldEh)  expHis(1,:) = [In1 xylim(3:4) 1]; xyl = [In1 xylim(3:4)];
           else              expHis=[];                        xyl = [In1 xylim(3:4)];
           end
      end; % end switch sact
      % set new axis limits & expansion history
      % xyl has limits
      % use sort to fix axis limits that are not increasing
      xyll = sort(xyl(1:2));  if diff(xyll) set(ax,XLIM,xyll); end;
      xyll = sort(xyl(3:4));  if diff(xyll) set(ax,YLIM,xyll); end;
      set(hiy,USER,expHis); % set expansion history
      if length(ax2)
         if Narg2==6 xy = In3; else  xy = get(ax2,YLIM); end;
         set(ax2,XLIM,xyl(1:2),YLIM,xy);
         set(hix,USER,misc);
      end;
      plt('grid',ax);
      if Action(end-2)=='l' evalQ(get(Hc(ixexp),USER)); end;   % execute axis change callback
      xView = getappdata(ax,'xView');
      if length(xView) set(xView{1},XDATA,get(ax,XLIM)); end;
    case clrpk_,                     % reset peak valley finder (probably not used anywhere?)
      setappdata(gcf,'peak',-inf); setappdata(gcf,'vall',inf);
    case exrestore_, % restore expansion history & axis limits first, check the size of what has
                     % been passed this will determine how the data is to be handled.
      if length(In1(1,:)) < EXPFLAGc
         % can't do too much here since this is the previous way of handling the restoration
         % of cursor state... which was incomplete...
         plt('cursor',CurID,'xyLim',In2);
      elseif isequal(size(In1),[EXPMAXc1 5])  % right shape....
        expHis = [];
        for i=1:EXPMAXc1
          if i<=EXPMAXc % crawl through and build the history
            if In1(i,EXPFLAGc) >= 0
              expHis=[expHis; In1(i,:)];
              if In1(i,EXPFLAGc) == 1
                 xylim = In1(i,1:4);  % this is the 'active' expansion
                 set(ax,XLIM,In1(i,1:2),YLIM,In1(i,3:4));
                 plt('grid',ax);      % adaptation for gridlines
              end;
            end
          else % check for dual axis limits
            if In1(i,EXPFLAGc)==2 set(ax2,XLIM,In1(i,1:2),YLIM,In1(i,3:4)); end;
          end;
        end; % end for i=1:EXPMAXc1
        set(hiy,USER,expHis);
      else disp('error in plt(cursor,CurId,set,exRestore,xxx), xxx is wrong shape');
      end; % end if length(In1(1,:)) < EXPFLAGc
    case setactive_
      if In1                         % if active line is 0, use the current active line
        misc(Jact) = In1;            % new active line
        set(hix,USER,misc);
      end;
      if isempty(In2) In2 = -1; end; % go to the middle of the trace if In3 is unspecified
      plt('cursor',CurID,'update',In2);
    %-------------------------------------------------------------------------------
    case clear_  % delete cursor objects & clear out slot
      hcl = Hc([ixlabel:imkline icurbase+1:end]);  % handles of objects to delete
      delete(hcl(find(ishandle(hcl))));            % can't delete missing 4 button group
      CurMain(CurID) = 0; % free this slot
      if ~sum(CurMain) CurMain = []; end;          % empty out CurMain if all slots free
      setappdata(0,'CurMain',CurMain);
    %-------------------------------------------------------------------------------
    case scaleaxis_ % scaleAxis
      ofs = strcmp(In1,'y');        % zero for x axis, 1 for y
      switch MouseType
      case normal_, % single left click behaves the same as previous versions
         if misc(Jxexp+ofs)
            plt('cursor',CurID,'scale','new');  misc(Jxexp)=0;  misc(Jyexp)=0;  set(hix,USER,misc);
         else % We were not in explicit expand mode. Display current axis limits of main plot
            fmty = get(Hc(iylabel),USER);  fmtx = fmty(1,:);  fmty = fmty(2,:);
            c = {BACKGROUND FOREGROUND};  clr = get(hix,c);
            set(Hc(ixro), STR,Pftoa(fmtx,xylim(1)),ENABLE);
            set(Hc(ixexp),STR,Pftoa(fmtx,xylim(2)),ENABLE,c,clr,SHOW);
            set(Hc(iyro), STR,Pftoa(fmty,xylim(3)),ENABLE);
            set(Hc(iyexp),STR,Pftoa(fmty,xylim(4)),ENABLE,c,clr,SHOW);
            misc(Jxexp+ofs)=1; % cursor is now in scale mode
            if ~misc(Jxexp) | ~misc(Jyexp)  % set expansion box limits to current display limits
               set(Hc(iexpbox),XDATA,xylim([1 2 2 1 1]),YDATA,xylim([3 3 4 4 3]),SHOW);
               plt('cursor',CurID,'ZoomOut',0.2); % zoom out 20% so we can see the zoombox
            end;
            set(hix,USER,misc);
         end;
      case alt_, plt('cursor',CurID,'scale','auto',In1); % A single right click, In1 has x or y information
      end;
    %-------------------------------------------------------------------------------
    case zoomout_ % zoom out to cover a 20% wider range on both x & y axes.
                  % for log axes, zoom out to include one more decade at both ends
      if Narg<4  d = [-.2 .2]; e = [.5 2];  % zoom factor not supplied. Use default 20%
      else       d = varargin{4}/2; e = 10^d;  d = [-d d];  e = [1/e e];
      end;
      xl = xylim(1:2);   yl = xylim(3:4);   dr = 'o';            % assume zoom out
      clk = MouseType;
      if clk==alt_ | (clk==open_ & getappdata(ax,'dir')=='i')    % right click ('alt') zooms in
        d = d(2); d = d/(1+2*d); d = [d -d]; e = 1./e; dr = 'i'; % double click ('open') zooms in if we zoomed in last time
      end;
      xs = get(ax,'Xscale');  ys = get(ax,'Yscale');
      if xs(2)=='i' xl = xl + diff(xl)*d;                        % for linear scaling
      else          xl = e.*xl;  if diff(xl)<=0 xl = xl./e; end; % for log scaling
      end;
      if ys(2)=='i' yl = yl + diff(yl)*d;                        % for linear scaling
      else          yl = e.*yl;  if diff(yl)<=0 yl = yl./e; end; % for log scaling
      end;
      set(ax,XLIM,xl,YLIM,yl);
      if ishandle(ax2)
        set(ax2,XLIM,xl);
        axl = get(get(ax2,YLABEL),STR);
        if axl(1)~=backslash_ | axl(2) ~= 'd';
          yl = get(ax2,YLIM);
          if ys(2)=='i' yl = yl + diff(yl)*d;                        % for linear scaling
          else          yl = e.*yl;  if diff(yl)<=0 yl = yl./e; end; % for log scaling
          end;
          set(ax2,YLIM,yl);
        end;
      end;
      plt('grid',ax);
      setappdata(ax,'dir',dr);
      axes(ax); evalQ(get(Hc(ixexp),USER));   % execute axis change callback
      xView = getappdata(ax,'xView');
      if length(xView) set(xView{1},XDATA,get(ax,XLIM)); end;
    %-------------------------------------------------------------------------------
    case mark_  % Add a marker (with text) at the current cursor location
      if MouseRight plt('xright','mark','0',CurID); return; end;  % right click on mark tag edits current line
      axes(ax);  x = get(hact,XDATA); y = get(hact,YDATA);  p = get(hact,PARENT);
      if p ~= ax
        rlim = xyli(3:4);     % must be on the right hand axis
        ylim = xylim(3:4);    % can't leave it there, since buttondown will be lost
        y = ylim(1) + diff(ylim) * (y - rlim(1)) / diff(rlim); % translate coordinates to left axis
      end;
      l = line(x,y,'marker','s');
      t = text(x,y,['   (' get(hix,STR) ', ' get(hiy,STR) ')'],'units','data',...
               FONTSIZE,get(p,FONTSIZE),USER,l,MOUSE,'plt misc marker;');
      % shouldn't need the 'units' property above. (Bug in Matlab R2009b?)
      set([t l],COLOR,get(hact,COLOR),TAG,'mark');
      if p ~= ax set(l,TAG,'markR',USER,{t ax p ylim rlim}); end; % indicate mark should really be on right axes
    %-------------------------------------------------------------------------------
    case tgllogy_ % Toggle the y-axis from lin to log (or back)
      if MouseRight plt('hcpy','init',gcf); % logy tag right click comes here (same as Print tag)
      else
        hl = [findobj(gcf,STR,'LinY'); findobj(gcf,STR,'LogY')]';
        for j=hl  b = get(j,MOUSE); % Find the associated LinY/LogY tag
                  if iscell(b) & length(b)>2 & b{3}==CurID break; end;
        end;
        if strcmp(get(ax,'Yscale'),'log')
             sc='linear'; st='LinY';
        else sc='log';    st='LogY';
             if xylim(3)<=0 set(ax,YLIM,abs(xylim(4))*[.001 1]); end;
             if ishandle(ax2)
               y = get(ax2,YLIM); if y(1)<=0 set(ax2,YLIM,abs(y(2))*[.001 1]); end;
               end;
        end;
        set([ax ax2],'Yscale',sc);  set(j,STR,st);
      end;  % end if MouseRight
    %-------------------------------------------------------------------------------
    case tgllogx_
      if MouseRight                     % logx tag right click comes here
        h = getappdata(ax,'Lhandles');  % get x/y vectors for all traces
        x = get(h,XDATA); y = get(h,YDATA);
        if length(h)>1 set(h,{XDATA},y,{YDATA},x);
        else           set(h,XDATA,y,YDATA,x);
        end;
        a = ax;
        for k = 1:2
          if k>1 a=ax2; if ~ishandle(a) continue; end; end;          
          set(a,XLIM,get(a,YLIM),YLIM,get(a,XLIM));              % swap x & y limits
          x = get(a,XLABEL);  y = get(a,YLABEL);
          sx = get(x,STR); set(x,STR,get(y,STR)); set(y,STR,sx); % swap x & y labels
        end;
        plt('grid',ax);
      else                               % logx tag left click comes here
        hl = [findobj(gcf,STR,'LinX'); findobj(gcf,STR,'LogX')]';
        for j=hl  b = get(j,MOUSE); % Find the associated LinX/LogX tag
                  if iscell(b) & length(b)>2 & b{3}==CurID break; end;
        end;
        p = get(ax,POS);  p = p(1);
        if getappdata(gcf,'indep') < 0
          a = getappdata(gcf,'axis');    % linked mode comes here (adjust the whole column)
          axe = [];                      % will contain all the axes to adjust
          for k = a                      % loop thru all the plot axes
            q = get(k,POS);              % add this to the list if x position is the same
            if p == q(1) axe = [axe k]; end;
          end;
        else axe = [ax ax2];             % for independent mode, don't adjust the whole column
        end;
        if strcmp(get(ax,'Xscale'),'log')
             sc='linear'; st='LinX';
        else sc='log';    st='LogX';
             if xylim(1)<=0 set(axe,XLIM,abs(xylim(2))*[.001 1]); end;
        end;
        set(axe,'Xscale',sc); set(j,STR,st);
        if isempty(ax2) ax2 = 0; end;
        for k = axe if k ~= ax2 plt('grid',k); end; end;
      end; % end if MouseRight
     %-------------------------------------------------------------------------------

    otherwise disp([Action ' is not a valid action in plt(cursor)']);
    end; % end switch Action
% end case 'cursor',

case markedit_
  switch s2i(varargin{2})
  case 0, % popup callback
     p = gcbo;  e = getappdata(p,'edt');
     % obj = getappdata(p,'obj');  obj = obj(1);
     m = getappdata(e,'m'); obj = m{4}(1);
     c = get(p,STR);   v = get(p,VALUE);  prop = deblank(c(v,:));
     f = getappdata(e,'f');  if length(f) close(f); end; % close ColorPick figure if one is open
     if strcmp(prop,'Delete') & ishandle(obj) delete(obj); end;
     if ishandle(obj)
       s = get(obj,prop);
       if isnumeric(s)
          if length(s)==3 & max(s)<=1 & min(s)>=0 s = ctriple(s);
          else                                    s = num2str(s);
          end;
       end;
       set(e,STR,s);
     else set(e,STR,'Deleted');
     end;
  case 1, % edit box callback
     e = gcbo;  p = getappdata(e,'pop');
     m = getappdata(e,'m'); obj = m{4};
     % obj = getappdata(p,'obj');
     c = get(p,STR); v = get(p,VALUE);   prop = deblank(c(v,:));
     s = get(e,STR); f = get(e,USER);
     if MouseRight if strcmp(prop,'Color') plt('ColorPick'); end;
                   return;
     end;
     switch prop
     case 'Delete',
       if strcmpi(s,'all')
         if length(c(:,1))==9 c='line'; else c='text'; end; % 9 choices in marker popup
         delete(findobj(get(get(e,PARENT),USER),'type',c,TAG,'mark'));
       end;
     case 'Color',  plt('ColorPick');
     case {'Xdata','Ydata','Zdata'},
                s = str2num(s);  n = length(s); xy = char('X' + (prop(1)=='X'));
                for k=1:length(obj)
                  if strcmp(get(obj(k),'type'),'line') & length(get(obj(k),xy))==n set(obj(k),prop,s); end;
                end;
     otherwise, if isnumeric(get(obj(1),prop)) s = str2num(s); end;
                if size(get(p,STR),1)<11 obj = findobj(obj,'type','line'); end;  % limit obj to contain only line objects
                set(obj,prop,s);
     end; % end switch prop
   case 2, % popup callback (figure properties)
     p = gcbo;  e = getappdata(p,'edt');  v = get(p,VALUE);  f = get(e,USER);
     h = get(p,USER);  h = h{v};  h1 = h(1);
     pr = {COLOR COLOR {XCOLOR YCOLOR} YCOLOR COLOR COLOR COLOR LINESTYLE};
     pr = pr{v};
     if iscell(pr) s = get(h1,pr{1}); else s = get(h1,pr); end;
     if ischar(s) s = [s getappdata(h1,'er')];  % here for grid style
     else         s = ctriple(s);               % other properties
     end;
     set(e,STR,s);
     f = getappdata(e,'f');  if length(f) close(f); end; % close ColorPick figure if one is open
     s = get(p,STR);
     setappdata(e,'m',{STR,e,pr,h,deblank(s(v,:))});
  case 3,     % edit callback (figure properties)
     s = get(gcbo,STR);
     v = get(getappdata(gcbo,'pop'),VALUE);
     if v==8  % editing grid style property
       er = s(end);
       if length(s)>1
         if er=='n' s(end)=[]; elseif er=='x'; s(end)=[]; else er='x'; end;
       end;
       gr = findobj(get(gcf,USER),isGRID); gr = gr(1); % find grid object
       setappdata(gr,'er',er);  set(gr,LINESTYLE,s);
     else plt ColorPick; % all other properties
     end;
  end; % end switch varargin{2}
% end case 'MarkEdit'

case misc_,
  in2 = varargin{2};
  if isnumeric(in2)
    switch in2
      case 1, Ret1 = get(findobj(gcf,TAG,'xstr'),USER); % returns the user data of the cursor Xstring
      case 2, Ret1 = get(findobj(gcf,TAG,'ystr'),USER); % returns the user data of the cursor Ystring
      case 3, Ret1 = getappdata(gcf,'OBJ');   % returns line handle of trace selected in the TIDbox
      case 4, Ret1 = getappdata(gcf,'OBJ2');  % returns handle of text object selected in the TIDbox
      case 5, Ret1 = getappdata(gcf,'OBJ');   % returns the trace index of the trace seleced in the TIDbox
              a = getappdata(gcf,'Lhandles'); Ret1 = find(a==Ret1);
    end;     % end switch in2
    return;
  end;       % end if numeric in2
  switch sum(in2)
    case rstyle_                                                         % style button right click
      if length(findobj(gcf,'tag','DeltaC','vis','on'))                  % are we in delta mode?
        delete([findobj(gcf,'tag','mark'); findobj(gcf,'tag','markR')]); % yes, delete cursor annotations
        h = findobj(gcf,'str','D');  c = get(h(end),'callb');            % and cancel delta mode
        feval(c{1},c{2:end});
      else h = findobj(gcf,'str','O'); h = h(end);                       % otherwise toggle LineSmoothing
           u = 1-get(h,'user');  set(h,'user',u);
           set(getappdata(gcf,'Lhandles'),'LineSmooth',char('of'+[0 8*u]));
      end;
    case rdelta_                                                % delta button right click
      if length(findobj(gcf,'tag','DeltaC','vis','on'))         % if we are in delta mode?
         h = findobj(gcf,'str','D');  c = get(h(end),'callb');  % yes, cancel delta mode and
         feval(c{1},c{2:end}); plt move res;                    % open resolution dialog
      else plt move;                                            % otherwise toggle reposition mode
      end;
    case icur_                                 % independent subplot cursor callback function
      cid = varargin{3};
      hc = plt('cursor',cid,'obj');            % find all ui objects for the current cursor
      c = get(hc(13),COLOR);                   % get cursor color
      for h = hc(3:2:5)                        % do for both x and y edit boxes
        s = get(h,STR);                        % set all edit boxes at this location to the same value/color
        hh = findobj(gcf,POS,get(h,POS));
        set(hh,STR,s,BACKGROUND,c);
        setappdata(hh(1),'indep',cid);         % probably don't need the setappdata for hh(2:end)
        % uistack(h,'top');                    % this should work, but cursor dissappears!
        %              % or set visibility below should work, but cursor also dissappears.
        % set(findobj(gcf,POS,get(h,POS)),HIDE);      % hide all objects with the same position
        % set(h,SHOW);                                % show this object
      end;
    case tidmv_, % move traceID axis, menu box axis, plotting axis, or a uicontrol
      fs = get(gcf,POS);  fs = fs(3:4);               % get figure size
      aPt = get(gcf,CurPOINT);                        % get mouse position (pixels)
      switch Narg
      case 2                                          % button down function -------------
        t = gcbo;  ax = getappdata(gcf,'axis');   m = 1;
        if strcmp(get(t,USER),'grid') t=ax(1); end;   % treat grid object as the main axis
        if     any(t == findobj(gcf,isTraceID)) k=-1;      % id number for TraceID axis
        elseif any(t == findobj(gcf,TAG, 'MenuBox')) k=-2; % id number for MenuBox axis
        else
          if Mver<7 k=find(~(ax-t)); else k=find(ax==t); end; % id numbers for plotting axes (1-50)
                                                              % aviod warning Matlab 6.1
          if isempty(k)
             ty = {' xy' 'uic' 'pop' 'axi'};   % id #'s for uicontrols (201-300), popups (101-200),
             id = [  0    200   100   50  ];   % auxiliary axes (51-100)
             for m=2:4
               tw = ty{m}; k = getappdata(gcf,tw);
               if Mver<7 k=find(~(k-t)); else k=find(k==t); end; % aviod warning Matlab 6.1
               k = k + id(m);
               if length(k) break; end;
             end;
          end;
        end;
        feval('assignin','base','hhh',t);
        if MouseType==open_ feval('inspect',t); return; end;  % prevent compiler warning
        if m==3 ev=getappdata(t,'CBsv'); feval(ev{:}); % for popups: open popup
                t = get(t,PARENT);                     % and drag the axis instead of the text object
        elseif strcmp(get(t,TAG),'E') t=get(t,USER);   % for edit lables, drag the edit object instead
        end;
        p = get(t,POS);   r = get(t,'type');
        if r(3)=='p' | (r(3)=='c' & strcmp(get(t,'style'),'frame')) ...  % here if its a panel or a frame
                     | (r(1)=='a' & strcmp(get(t,TAG),  'frame'))        % or if its an axis tagged as frame
           ch = {};  % will be a list of objects inside the frame or panel (with their positions)
           r = p(1:2);  r = [r -r-p(3:4)];
           m = getappdata(gcf,'sli');  w = getappdata(gcf,'pop');  np = length(w);
           m = [w getappdata(gcf,'axi') getappdata(gcf,'uic') m(1:5:end)];
           for j=1:length(m)
             if j<= np q = getappdata(m(j),'ppos'); w = get(get(m(j),PARENT),POS);
             else      q = get(m(j),POS);           w = q;
             end;
             s = q(1:2);  s = [s -s-q(3:4)];
             if all(s>r) ch = [ch {{m(j) w}}]; end;
           end;
           setappdata(t,'inside',ch);
        end;
        u = get(t,'units');  if u(1)=='n' aPt = aPt ./ fs; end; % convert to normal units if needed
        setappdata(gcf,'Dxy',{p aPt t k m});             % save initial object & cursor locations
        set(gcf,'WindowButtonMotionFcn','plt misc tidmv 0;',...
                'WindowButtonUpFcn',    'plt misc tidmv 0 0;');
      case 3
        s = getappdata(gcf,'Dxy'); t = s{3};             % button motion function ---------------------
        u = get(t,'units');  u = u(1)=='n';              % u is true for normal units
        if u  aPt = aPt ./ fs; end;                      % convert mouse position to normal units if needed
        r = getappdata(gcf,'snap');  r = r + 1e4*(r==0); % get SnapTo resolution (zeros are replaced by 10000)
        if ~u  r = r ./ fs; end;                         % convert resolution for pixel units
        rr = [r r];  r = [0 0 1./r];
        aPt = aPt-s{2}; s = s{1};
        if MouseType==normal_                            % left drag changes position
          aPt = [aPt 0 0];                               % position change (since beginning of drag)
          ch = getappdata(t,'inside');  cn = length(ch); % get the items inside the frame
          for k = 1:cn                                   % reposition or resize items inside frames
            h = ch{k}{1}; p = max(r,round((ch{k}{2}+aPt).*rr) ./ rr);
            ty = getappdata(h,'ty');
            switch ty(1)
              case 's', plt('slider',h,'set',POS,p);
              case 'p', plt('pop',h,'pos',p);
              otherwise set(h,POS,p);
            end;
          end;
        else                                             % right drag changes size
          aPt = [0 0 aPt];                               % size change (since beginning of drag)
        end;
        s = s + aPt;
        s = max(r,round(s.*rr) ./ rr);                   % snap to (max prevents zero width or height)
        tn = getappdata(t,'ty');                         % allow drag of edit object's label as well
        if tn(1)=='e' plt('edit',t,POS,s); else set(t,POS,s); end;
      case 4                                                  % button up function ---------------
        MOTIONOFF;
        s = getappdata(gcf,'Dxy');  t = s{3};  u = get(t,'units');
        p = get(t,POS);  ty = getappdata(t,'ty');
        r = get(t,'type');                                    % identify it by its type
        if ty(1)=='p'    h = get(t,USER); r = get(h,STR);     % unless its a popup, identify it by its string
                         plt('pop',h,'index',plt('pop',h));   % and collapse the popup
        elseif r(3)=='c' r = get(t,STR);                      % or if its a uicontrol, also id it by its string
                         if iscell(r) r = r{1}; end;          %   (but first line only)
        end;
        if u(1)=='n' a = strrep(prin('{ %0.3f}',p),'0.','.'); % normal units
        else         a = prin('{ %4d}',round(p));             % pixel units
        end;
        prin(1,'%s: %3d %s;  %% %s\n',ty,s{4},a,r);
      end; % end switch Narg
    case txtmv_,                                        % move text object
      switch Narg
      case 2                                            % button down function -------------
        t = gcbo;  ax = get(t,PARENT);  aPt = get(ax,CurPOINT);  aPt = aPt(1,1:2);
        tu = get(t,'units');                            % text unit
        set(t,'units','data');
        k = getappdata(gcf,'txt');  k = find(k==t);
        k = k+300;                                      % id numbers for text objects (301-400)
        setappdata(gcf,'Dxy',{get(t,POS) aPt t k tu});  % save initial object & cursor locations
        feval('assignin','base','hhh',t);
        if MouseType==open_ feval('inspect',t); return; end; % prevent compiler warning
        set(gcf,'WindowButtonMotionFcn','plt misc txtmv 0;',...
                'WindowButtonUpFcn',    'plt misc txtmv 0 0;');
      case 3                                            % button motion function -----------
        s = getappdata(gcf,'Dxy');
        t = s{3};  tp = s{1};  ax = get(t,PARENT);  aPt = get(ax,CurPOINT);

        set(t,POS,tp(1:2)+aPt(1,1:2)-s{2});
      case 4                                             % button up function ---------------
        MOTIONOFF;
        s = getappdata(gcf,'Dxy'); t = s{3};
        set(t,'units',s{5}); p = get(t,POS);
        ty = getappdata(t,'ty');     r = get(t,STR);  if iscell(r) r=r{1}; end;
        prin(1,'%s: %3d    %6V  %6V   ;  %% %s\n',ty,s{4},p(1:2),r);
        if ty(1)=='e' plt('edit',t,POS,p); end;          % update label position
      end; % end switch Narg
    case slimv_,                             % move pseudo slider object
      fs = get(gcf,POS);  fs = fs(3:4);      % get figure size
      aPt = get(gcf,CurPOINT);               % get mouse position (pixels)
      switch Narg
      case 2                                 % button down function -------------
        w = getappdata(gcf,'sli');
        t = gcbo;                            % id numbers for pseudo sliders (401-500)
        k = 1 + 5*floor((find(w==t)+399)/5); % move them in groups of 5. k points to label.
        if isempty(k) disp('slimv error'); return; end;
        t = w(k-400);                        % t is the label handle
        feval('assignin','base','hhh',t);
        if MouseType==open_ feval('inspect',gcbo); return; end; % prevent compiler warning
        u = get(t,'units');  if u(1)=='n' aPt = aPt ./ fs; end; % convert to normal units if needed
        setappdata(gcf,'Dxy',{get(t,POS) aPt t k});             % save initial objects & cursor locations
        set(gcf,'WindowButtonMotionFcn','plt misc slimv 0;',...
                'WindowButtonUpFcn',    'plt misc slimv 0 0;');
      case 3                                 % button motion function -----------
        s = getappdata(gcf,'Dxy');  t = s{3};
        u = get(t,'units');  u = u(1)=='n';  % u is true for normal units
        if u  aPt = aPt ./ fs; end;          % convert mouse position to normal units if needed
        aPt = aPt-s{2}; s = s{1}(1:3);
        if MouseType==normal_ s = s + [aPt 0];                   % left drag changes position
        else                  s = max([0 0 .01],s+[0 0 aPt(1)]); % right drag changes size
        end;
        r = getappdata(gcf,'snap');  r = r + 1e4*(r==0);         % get SnapTo resolution (zeros are replaced by 10000)
        if ~u q = get(gcf,POS);  r = r ./ q(3:4); end;           % convert resolution for pixel units
        rr = [r r(1)];  r = [0 0 1/r(1)];
        s = max(r,round(s.*rr) ./ rr);                           % snap to (max prevents zero width or height)
        plt('slider',t,'set',POS,s);
      case 4                                 % button up function ---------------
        MOTIONOFF;
        s = getappdata(gcf,'Dxy');  t = s{3};  u = get(t,'units');
        p = get(t,POS);  r = get(t,STR);
        if u(1)=='n' disp(strrep(prin('sli: %3d { %0.3f}     ;  %% %s',s{4},p(1:3),r),'0.','.'));
        else         disp(prin('sli: %3d { %4d}     ;  %% %s',s{4},round(p(1:3)),r));
        end;
      end; % end switch Narg
    case marker_
      t = gco;
      aPt  = get(get(t,PARENT),CurPOINT);
      if Narg==2
        switch MouseType
        case normal_ % left click
          setappdata(t,'Dxy',get(t,POS)-aPt(1,:));  % save difference between cursor & text locations
          set(gcf,'WindowButtonMotionFcn','plt misc marker 0;',MOTIONstop);
        case alt_ % right click
          callp = 'plt MarkEdit 0;';
          calle = 'plt MarkEdit 1;';
          figure(NoMENU,'resize','off',POS,auxLoc(302,85),COLOR,dlgBKc,'name','Edit Marker',TAGg,...
                         'closereq','plt click mark 4;');
          ed1 = EDIT(POS,[8 5 130 22],BOLD,CALLBK,calle,MOUSE,calle);
          pu1 = 'Delete|Color|LineStyle|LineWidth|Marker|MarkerSize|Xdata|Ydata|Zdata';
          pu1 = POPUP(pu1,POS,[8 35 130 20],CALLBK,callp,VALUE,5);
          TEXT( 'Marker properties:',POS,[8 64 130 17]); % space needed after TEXT( [mpp]
          ed2 = EDIT(POS,[145 5 150 22],BOLD,CALLBK,calle,MOUSE,calle);
          pu2 = POPUP('Delete|Color|FontAngle|FontName|FontSize|FontWeight|HorizontalAlign|Position|Rotation|String|VerticalAlign',...
                      POS,[145 35 150 20],CALLBK,callp,VALUE,10);
          TEXT( 'String properties:',POS,[145 64 150 17]);
          set([ed1 ed2 pu1 pu2],BACKGROUND,lblBKc,FOREGROUND,lblFRc);
          l = get(t,USER);
          setappdata(ed1,'pop',pu1); setappdata(pu1,'edt',ed1); setappdata(pu1,'obj',l);
          setappdata(ed2,'pop',pu2); setappdata(pu2,'edt',ed2); setappdata(pu2,'obj',t);
          setappdata(ed1,'m',{STR,ed1,COLOR,l,'Marker color'});
          setappdata(ed2,'m',{STR,ed2,COLOR,t,'String color'});
          if ishandle(l) l=get(l,'marker'); else l='Deleted'; end;
          if ishandle(t) t=get(t,STR);      else t='Deleted'; end;
          set(ed1,STR,l);  set(ed2,STR,t);
        end;  % end switch MouseType
      else  dxy = aPt(1,:) + getappdata(t,'Dxy'); set(t,POS,dxy(1:2)); % motion function
      end;  % end if Narg==2
    case tidtop_,   aid = findobj(gcf,isTraceID);   % put traceID axis on top
                    if length(aid)
                       uistack(aid,'top');
                       % chi = get(gcf,CHILDREN); chi(find(chi==aid)) = []; % older method for uistack
                       % set(gcf,CHILDREN,[aid; chi]);
                    end;
    case close_,                         % close request function
      a = getappdata(gcf,'ucreq');       % get user close request function
      if length(a) evalQ(a); end;        % if it's there, evaluate it (string or cell array)
      for cid=getappdata(gcf,'cid')
         plt('cursor',cid,'clear');      % remove all cursors for the current figure
      end; 
      for fk = findobj('type','fig',TAGg)'; % remove cursors from linked figures
        if fk ~= gcf  % Close only linked figures. The current figure is closed via final closereq
          a = getappdata(fk,'ucreq');       % get user close request function
          if length(a) evalQ(a); end;       % if it's there, evaluate it (string or cell array)
          for cid=getappdata(fk,'cid')
            plt('cursor',cid,'clear');      % remove all cursors for the current figure
          end; 
          delete(fk);
        end;
      end;
      closereq;
  end; % end switch sum(in2)

case colorpick_                % pick colors using sliders & 11 x 11 palette
  m = getappdata(gcbo,'m');    % this always points to the main object
  if isempty(m) m = getappdata(get(gcbo,PARENT),'m'); end;
  if iscell(m) hq=m; m=gcbo;   % except for the main object itself in which case it contains the cell array
  elseif ishandle(m) hq = getappdata(m,'m'); % get cell array from main object
  end;                         % hq{1,2,3,4...} = property,handleList,property,handleList, etc.
  if Narg>1 ccf = varargin{2}; else ccf = ''; end; % get 2nd argument (usually the color change function)
  if strcmp(ccf,'C')           % ColorPick figure close function
    for k=2:2:length(hq)
      h = hq{k};
      for j = 1:length(h) setappdata(h(j),'f',[]); end;
    end;
    setappdata(m,'f',[]);      % in case the main object isn't in the color list
    closereq;
    return;
  end;
  t = 0; cb = '';  f = getappdata(m,'f');       % get handle of the ColorPick figure
  if isempty(f)                % create the ColorPick figure if it hasn't been created yet
    hb = [];  for k=2:2:length(hq) hb = [hb hq{k}]; end; % hb is a list of all objects to recieve the modified color
    if length(find(m==hb))     % if m is in this list of objects
          b=m;                 % get the initial color from m
    else  b=hb(1); hb=[hb m];  % otherwise get the initial color from the first object in the list
    end;
    ed = 0;                    % will be if the color (c) is derived from a string
    switch get(b,'type')
      case 'uicontrol', c = get(b,BACKGROUND);  t = get(b,STR);  ed = strcmp(get(b,'sty'),'edit');
      case 'text',      c = get(b,COLOR);  t = get(b,STR);
      case 'patch',     c = get(b,'facecolor');
      otherwise,        c = get(b,COLOR);
    end;
    if ed             c = [str2num(t) 0 0 0];   c = min(max(c(1:3),0),1);
    elseif ischar(t)  t = str2num(t);  if length(t)==3 & min(t)>=0 & max(t)<=1 c=t; ed=1; end;
    end;
    if Narg<3 & ed & MouseLeft & b==m
      t = ctriple(c); % we are not going to open a ColorPick window
      for k=2:2:length(hq)
        p = hq{k-1};  h = hq{k};
        if ~iscell(p) p = {p}; end;
        for j=1:length(p)
          q = p{j}; if strcmp(q(1:3),STR) set(h,q,t); else set(h,q,c); end;
        end;
      end;
      if length(ccf)>1 eval(ccf); end; % execute the color change function
      return;
    end;
    f = figure(NoMENU,POS,auxLoc(302,205,3),COLOR,dlgBKc,'name','Color Pick',...
               TAGg,'double','off','closereq','plt ColorPick C;');
    setappdata(f,'ccf',ccf); % save the color change function
    cb = 'plt ColorPick;';  s1 = [0 100 0 100];  d = round(c*100);
    p1 = [.02 .20 110];  p2 = [0 .29 0];
    s = [plt('slider',p1+2*p2,[d(1) s1],'Red (%)'  ,cb,2) ...
         plt('slider',p1+p2,  [d(2) s1],'Green (%)',cb,2) ...
         plt('slider',p1,     [d(3) s1],'Blue (%)' ,cb,2)];
    obj = plt('slider',s(1),'get','obj');  set(obj(5),BACKGROUND,[1 1 0]);
    ax = axes(XLIM,[.8 12.15],YLIM,[.8 15.4],COLOR,[0 0 0],XCOLOR,dlgBKc,YCOLOR,dlgBKc,NOTICK,...
              NORMAL,POS,[.408 .02 .57 .96]);
    if ischar(hq{end})       % add label if it exists, then remove it from the appdata
      text(-3.4,14.7,hq{end},'horiz','center',COLOR,[1 .7 .8]);
    end;
    setappdata(f,'m',m);  setappdata(ax,'m',m);
    ph = zeros(11,11);
    for row = 1:11
      for col = 1:11
        ph(row,col) = patch(col+[0 1 1 0],row+[0 0 1 1],[0 0 0],MOUSE,cb);
      end;
    end;
    c = d/100;
    pat = patch([1 12 12 1],12+[.5 .5 3 3],c,MOUSE,cb);  setappdata(pat,'m',m);
    setappdata(f,'h',{c s pat ph ax});
    for k=1:length(hb) setappdata(hb(k),'f',f); setappdata(hb(k),'m',hq); end;
  end;
  % here if the ColorPick figure exists ------------------------------
  h = getappdata(f,'h');     % get {c s pat ph ax}
  p = get(gcbo,PARENT);
  s = h{2};                  % get slider handles
  if length(cb) k=1;         % if it's the 1st time
  else
    if strcmp(get(gcbo,'type'),'patch') & isempty(cb)   % here if it was one of the patch objects
      if gcbo==h{3} c = h{1}; else c = get(gcbo,'facecolor'); end;
      for k=1:3
        obj = plt('slider',s(k),'get','obj');
        bk = get(obj(5),BACKGROUND);
        if bk(1) break; end;                            % k will be the active slider
      end;
    else
      y = strcmp(get(gcbo,'sty'),'edit');               % y=1 if it is an edit box, y=0 if it's a slider
      if y & isequal(get(gcbo,USER),[0 100]) y=0; end;  % y=0 for the edit box portion of the slider as well
      if y  c = [str2num(get(gcbo,STR)) 0 0 0];  c = min(max(c(1:3),0),1);  % here if it was an edit box
      else  c = get(h{3},'facecolor');                  % here if it was one of the sliders
      end;
      d = round(100*c);
      k = 0;                                            % k will be the slider that was changed
      for j=1:3                                         % find which slider has been changed
        z = plt('slider',s(j));   obj = plt('slider',s(j),'get','obj');
        if z~=d(j) & ~k bk = [1 1 0];  k = j;  if ~y d(k)=z; end;
        else            bk = [0 1 1];
        end;
        set(obj(5),BACKGROUND,bk);
      end;
      if ~k set(obj(5),BACKGROUND,[1 1 0]); return; end;  % sliders didn't change ... do nothing
      c = d/100;
    end;
  end;
  set(h{3},'facecolor',c);
  d = round(c*100);
  for j=1:3  plt('slider',s(j),'set','val',d(j)); end;  % update the sliders
  ph = h{4};  phc = [0 0 0];  phc(k) = d(k)/10;  v = mod(k,3)+1;  w = mod(v,3)+1;
  for row = 0:10
    phc(v) = row;
    for col = 0:10
      phc(w) = col;  set(ph(row+1,col+1),'FaceColor',phc/10);
    end;
  end;
  t = ctriple(c);
  for k=2:2:length(hq)
    p = hq{k-1};  h = hq{k};
    if ~iscell(p) p = {p}; end;
    for j=1:length(p)
      q = p{j}; if strcmp(q(1:3),STR) set(h,q,t); else set(h,q,c); end;
    end;
  end;
  ccf = getappdata(f,'ccf');
  if length(ccf)>1 eval(ccf); end;  % execute the color change function

case open_  % load plt figure
  if Narg<2 [fi pth] = uigetfile('plt.plt','Select plt figure to open');
            if isnumeric(fi) return; end;
            fi = [pth fi];
  else      fi = varargin{2};
  end;
  ydat = [];
  feval('load',fi,'-mat'); % use feval to prevent compiler warning
  if isempty(ydat)         % must do this malarky because compiler
    p = find(fi=='.');     % does not support the '-mat' option
    if length(p) f = [fi(1:p(end)) 'mat']; end; % change extension to .mat
    dos(['copy ' fi ' ' f ' > NUL:']);
    load(f); delete(f);
  end;
  xdat = [xdat'; ydat'];
  plt(xdat{:},params{:});
% end case 'ColorPick'

case save_    % save plt figure
  if Narg<2 [fi pth] = uiputfile('plt.plt','Save plt figure as');
            if isnumeric(fi) return; end;
            fi = [pth fi];
  else      fi = varargin{2};
  end;
  AX    = findobj(gcf,TAG,'click');  AX = AX(1);
  CurID = get(AX,USER);
  AX2   = findobj(gcf,'YAxisLoc','right',USER,CurID);
    lh = getappdata(gcf,'Lhandles');
    xdat = get(lh,XDATA);  ydat = get(lh,YDATA);
    xlm =  get(AX,XLIM);   ylm =  get(AX,YLIM);
    xymult = getappdata(gcf,'xymult');  % correct data modified for metric prefixes
    if xymult(1) ~= 1
       mult = 1/xymult(1);
       for k = 1:length(xdat) xdat{k} = mult * xdat{k}; end;
       xlm = xlm * mult;
    end;
    ym = 1;
    for k = 1:length(ydat)
      mult = xymult(k+1);
      if mult ~= 1  
         mult = 1/mult;
         if ym ylm=ylm*mult; ym=0;  end;
         ydat{k} = mult * ydat{k};
      end;
    end;
    v = get(lh,VISIBLE);  v = [v{:}];  
    params = [getappdata(gcf,'params') { ...
             POS        get(gcf,POS) ...
             'DIStrace' v(find(v=='o')+1)=='f' ...
             XLIM       xlm ...
             YLIM       ylm     }];
    if length(AX2) params = [params {'YlimR' get(AX2,YLIM)}]; end;
    ver = PLTversion;
    save(fi,'xdat','ydat','params','ver');
% end case 'save'

case click_
  if MverE  ERAS = 'eras';  ERAXOR = 'xor';  ERANOR = 'norm'; % for Matlab R2014a or earlier
  else      ERAS = 'pi';    ERAXOR = 'v';    ERANOR = 'v';    % Matlab R2014b or later doesn't
  end;                                                        % support the erasemode property
  y2    = varargin{2};
  AX = findobj(gcf,TAG,'click');
  if ischar(y2)       % is it the traceID callback
    y2s = sum(y2);  % No ... come here
    if y2s == Yedit_
      hpop = getappdata(gcf,'epopup');
      hd = getappdata(hpop,'EdHide');
      set(hpop,HIDE);  set(hd,SHOW);                % hide the popup
      if nargin==2 ix = plt('pop',hpop);            % get index from popup
                   cb = get(hd(1),CALLBK);          % cb = {@plt 'cursor' 13 'editCB' 2} (for example)
                   if ~iscell(cb) return; end;
                   if length(AX)>1 AX = findobj(gcf,'YAxisLoc','left',USER,cb{3}); end;
      else         ix = varargin{3};                % get index from argument list
                   if ischar(ix) ix = s2i(ix); end; % allow string index as well
                   if length(AX)>1
                     CurID = [];  gtag = get(gcbo,TAG);  if ischar(gtag) CurID = s2i(gtag); end;
                     if isempty(CurID) | ~isnumeric(CurID)
                       CurID = get(gca,USER);
                       if isempty(CurID) | ~isnumeric(CurID) | mod(CurID,1)
                         CurID = getappdata(gcf,'cid');  CurID = CurID(1);
                       end;
                     end;
                     AX = findobj(gcf,'YAxisLoc','left',USER,CurID);
                   end;
      end;
    end;
    if length(AX)>1                        % here if more than one plt called in the same figure (exFig)
       a = gca;  yal = get(a,'YAxisLoc');  % is the current axis the right hand axis?
       if yal(1)=='r' a = findobj(gcf,'YAxisLoc','left',USER,get(a,USER)); end; % if yes switch to the left one
       fi = find(a==AX);                   % is that axis in this list?
       if length(fi)==1 AX = AX(fi);       % if yes, that must be the one.
       else  AX = AX(end);                 % if not, just pick the last one (and hope)
       end;
    end;
    CurID = get(AX,USER);
    AX2   = findobj(gcf,'YAxisLoc','right',USER,CurID);
    AXrl  = [AX AX2];
    if isempty(AX2) AX2 = -1; end;
    CurMain = getappdata(0,'CurMain');  Hc = get(CurMain(CurID),USER);
    switch y2s

    case link_    % toggle right/left axis link
      h = get(AX2,YLABEL);  s = get(h,STR);
      if s(1)==backslash_ & s(2)=='d'  s = s(6:end-5);
      else                             s = ['\div ' s ' \div'];
      end;
      set(h,STR,s);

    case mark_
      if Narg>2 in3 = s2i(varargin{3}); else in3 = -1; end;
      switch in3
        case 3,                                            % here for saving figure colors
          % note: Crashes if TraceIDs were disabled (=[])
          cFIGbk = get(gcf,COLOR);
          cPLTbk = get(AX,COLOR);
          if isstr(cPLTbk) cPLTbk = get(AX2,COLOR); end; % if 'none' get from right axis
          cXYax  = get(AX,XCOLOR);
          cXYlbl = get(get(AX,XLABEL),COLOR);
          cDELTA = findobj(gcf,TAG,'DeltaC'); cDELTA = get(cDELTA(1),COLOR);
          cTRACE = get(getappdata(gcf,'Lhandles'),COLOR);
          cTRACE = reshape([cTRACE{:}],3,length(cTRACE))';
          cFile = findobj(gcf,'style','push',STR,'D');  cFile  = get(cFile(end),TAG);
          gr = findobj(gcf,isGRID);  gr = gr(1);        cGRID  = getappdata(gr,'clr');
          GridSty = get(gr,LINESTYLE);                  GridEr = get(gr,ERAS);
          if isempty(cFile) [cFile pth] = uiputfile('*.mat','Select file for saving colors');
                            cFile = [pth cFile];
          end;
          if sum(cFile)
             save(cFile,'cFIGbk','cPLTbk','cXYax','cXYlbl','cDELTA','cTRACE');
             msgbox(['This program will now use colors saved in file ' cFile],'modal');
          else disp('No file was selected'); end;
          return;
        case 4,                                            % here for close request function
          close(findobj('name','Color Pick')); 
          g = s2i(get(gcf,TAG));  g = findobj('type','fig','Number',g);
          gr = findobj(g,isGRID);
          if length(gr)
            gr = gr(1);
            er = getappdata(gr,'er'); if isempty(er) closereq; return; end;
            setappdata(gr,'er',[]);
            if er=='n' er=ERANOR; else er=ERAXOR; end;
            c = get(gr,COLOR);    % in case grid color or style was modified
            setappdata(gr,'clr',c);
            ax = getappdata(g,'axis');  axr=ax(end);  r = get(axr,'YAxisLoc');
            if r(1)=='r' % it's a right hand axis
              vis = get(axr,VISIBLE);
             if vis(2)=='n' gx = get(g,COLOR); else gx = get(axr,COLOR); end;
              c = bitxor(round(255*c),round(255*gx))/255;
            end;
            set(gr,COLOR,c,ERAS,er);
          end;
          closereq;
          return;
      end; % end switch in3
      g = gcf;
      mb = findobj(g,TAG,'MenuBox')';
      callc = 'plt MarkEdit 3;';
      if in3==2 % here for editing figure colors
        figure(NoMENU,'resize','off',POS,auxLoc(302,60),COLOR,dlgBKc,'name','Edit figure colors',TAGg,...
                      'closereq','plt click mark 4;');
        ps = 'Figure background|Plot background|Axis color|Axis color (right)|Axis labels|Delta cursor|Grid color|Grid style';
        pu = POPUP(ps,POS,[80 35 140 20],CALLBK,'plt MarkEdit 2;');
        ed = EDIT(POS, [80  5 140 22],BOLD,CALLBK,callc,MOUSE,callc);
        gr = findobj(g,isGRID);  gr = gr(1);
        er = get(gr,ERAS);  setappdata(gr,'er',er(1));
        set(gr,ERAS,ERANOR);
        set(gr,COLOR,getappdata(gr,'clr')); % change grids to normal erase mode for editing
        set([ed pu],BACKGROUND,lblBKc,FOREGROUND,lblFRc);
        setappdata(ed,'m',{STR,ed,COLOR,[g mb],'Figure background'});
        setappdata(ed,'pop',pu); setappdata(pu,'edt',ed); setappdata(pu,'obj',[]);
        set(ed,STR,ctriple(get(g,COLOR)));
        ax = getappdata(g,'axis');  a = ax(1);  ar = ax(end); % Get left & right axes (a & ar)
        if isstr(get(a,COLOR)) ap=ar; else ap=a; end; % if color(LeftAxis)=='none' use right axes for plt backgr
        lb = [get(a,XLABEL) get(a,YLABEL) get(mb,CHILDREN)'];
        dc = findobj(g,TAG,'DeltaC');
        set(pu,USER,{[g mb]; % Figure background
                     ap;      % Plot background
                     a;       % Axis color
                     ar;      % Axis color (right)
                     lb;      % Axis labels
                     dc(1)    % Delta cursor
                     gr       % Grid color
                     gr       % Grid style
                    });
        return;
      end;
      sb = 0;    % subplot indicator (and line number offset)
      if Narg>3  % cid  is specified: plt('click','mark','0',cid)
        CurID = varargin{4};
        [lm lh] = plt('cursor',CurID,'getActive');
        if length(AX)>1
          AX  = get(lh,PARENT);
          Hc = get(CurMain(CurID),USER);
        else
          lhs = getappdata(gcf,'Lhandles');
          ln = find(lhs == lh);
          nl = length(getappdata(AX,'Lhandles'));
          if ln > nl  % here if its for a subplot
            Hc = get(CurMain(CurID),USER);
            sb = ln-1;
          end;
        end;
      end;
      if length(AX)>1 AX=AX(1); CurID = get(AX,USER); Hc = get(CurMain(CurID),USER); end;
      hix = Hc(ixro);
      misc = get(hix,USER);   % misc parameters
      actv = misc(Jact);      % active cursor
      iact = icurbase + actv; % active cursor offset
      hact = Hc(iact);        % handle of active cursor
      if MouseRight | Narg>2  % right click ('alt') edits line or cursor properties
        tx = [];  hb = [];  tid = [];
        if sb h=[]; else h = findobj(gcf,isTraceID)'; end;
        if length(h)>1 for j=h if CurID == getappdata(j,'cid') h=j; break; end; end; end; 
        if length(h) h = flipud(get(h,CHILDREN));
                     tx = findobj(h,'type','text');  tid = tx(actv);  % pick the active traceID label
                     h = findobj(h,'type','line');  % find the lines in the traceID box
                     bt = get(h,'button');
                     if iscell(bt)
                       hb = h(find(cellfun('length',bt)));             % keep lines with a buttondown fcn
                       if length(hb)>=actv tid = [tid hb(actv)]; end;  % hb will be non empty when TraceMK=1
                     end;
        end;
        c = hact;                  % handle to active cursor
        h = get(c,USER); h = h{1}; % handle to active line
        if in3>0 alll = in3;      % edit all lines if 3rd arg is 1
        else  alll = get(Hc(imkline),VISIBLE);
              if alll(2)=='n'                  % are we in delta mode?
                 h = findobj(gcf,STR,'D');  h = get(h(end),'callb');
                 evalQ(h); plt click mark 1;   % yes, cancel delta mode and edit all line colors instead
                 return;
              end;
              alll = 0;                        % edit just one line
        end;
        if alll
          c = [];  h = [];  a = [];            % edit all lines
          for i=icurbase+1:length(Hc)
            lh = get(Hc(i),USER);
            c = [c Hc(i)];  h = [h lh{1}];     % append next cursor & line
          end;
          tid = [tx; hb]';                     % change all traceID labels & TraceMK lines
          fname = 'Edit all lines';
        else                                   % edit just a single line
          if length(tid) tx=tid(1); a=[];      % for main plot with a traceID box
          else a=get(h,PARENT); tx=get(a,YLABEL); tid=tx; % for subplots or when traceID box is missing
          end;
          fname = sprintf('Edit Line %d (%s)',actv+sb,deblank(get(tx,STR)));
        end;
        callp = 'plt MarkEdit 0;';
        calle = 'plt MarkEdit 1;';
        figure(NoMENU,'resize','off',POS,auxLoc(302,85),COLOR,dlgBKc,'name',fname,TAGg,...
               'closereq','plt click mark 4;');
        props = 'Color|LineStyle|LineWidth|Marker|MarkerSize|Xdata|Ydata|Zdata';
        ed1 = EDIT(POS,[8 5 130 22],BOLD,CALLBK,calle,MOUSE,calle);
        pu1 = POPUP(props,POS,[8 35 130 20],CALLBK,callp);
        TEXT( 'Line properties:',POS,[8 64 130 17]); % space needed after TEXT( [mpp]
        ed2 = EDIT(POS,[145 5 150 22],BOLD,CALLBK,calle,MOUSE,calle);
        pu2 = POPUP(props,POS,[145 35 150 20],CALLBK,callp,VALUE,5);
        TEXT( 'Cursor properties:',POS,[145 64 150 17]);
        set([ed1 ed2 pu1 pu2],BACKGROUND,lblBKc,FOREGROUND,lblFRc);
        setappdata(ed1,'pop',pu1); setappdata(pu1,'edt',ed1); setappdata(pu1,'obj',h);
        setappdata(ed2,'pop',pu2); setappdata(pu2,'edt',ed2); setappdata(pu2,'obj',c);
        setappdata(ed1,'m',{STR,ed1,COLOR,[h tid],'ycolor',a,'Line color'});
        setappdata(ed2,'m',{STR,ed2,COLOR,c,'Cursor color'});
        set(ed1,STR,ctriple(get(h(1),COLOR)));
        set(ed2,STR,get(c(1),'MarkerSize'));
        r = get(AX,'YAxisLoc');
        if r(1)=='r' AX = findobj('type','axes',POS,get(AX,POS)); AX=AX(1); end;
        axes(AX);
      end; % end if MouseRight | Narg>2
    case TGLgrid_
      ax = getappdata(gcf,'axis');  n = length(ax);  axr = []; axl = [];
      for k=ax  r = get(k,'YAxisLoc');
                if r(1)=='r' axr = [axr k]; else axl = [axl k]; end;
      end;
      if MouseRight % grid tag right click comes here
        r = get(ax(n),'YAxisLoc');
        if length(axr) era=ERAXOR; else era=ERANOR; end;
        for k = axl
          g = findobj(k,isGRID);
          if isempty(g) | isempty(deblank(get(g,TAG))) continue; end;
          c = getappdata(g,'clr');  st = get(g,LINESTYLE); 
          inv = c(1) > .5;
          if st(1)=='-'  c = 2*c;  if inv c=c-1; end;  c=max(min(c,1),0); cc=c; er=ERANOR; sty=':';
          else           c = c/2;  if inv c=c+.5; end; c=max(min(c,1),0); cc=c; er=era;    sty='-';
          end;
          if MverE & length(axr)
            p = get(k,POS);  mainA=0; % indicate it is not a main axis that includes a right axis
            for j=axr if all(get(j,POS)==p) mainA=1; break; end; end;
            if mainA
              vis = get(j,VISIBLE);
              if vis(2)=='n' gx = get(gcf,COLOR); else gx = get(j,COLOR); end;
              c = bitxor(round(255*c),round(255*gx))/255;
            end;
          end;
          setappdata(g,'clr',cc);
          set(g,LINESTYLE,sty,COLOR,c,ERAS,er);
        end;
      else                            % grid tag left click comes here
        for k=axl                     % toggle grid lines on all left hand axes
          g = findobj(k,isGRID);
          if isempty(g) | isempty(deblank(get(g,TAG))) continue; end;
          plt('grid',k,'toggle');
        end;            
      end;  % end if MouseRIght
    case TGLmenu_
      if MouseRight                   % here for right click (open Cursor Data Window)
        cf = gcf;
        l = getappdata(cf,'Lhandles');
        if isempty(l) disp('No data to display'); return; end;
        tn = get(flipud(findobj(findobj(gcf,isTraceID),'type','text')),STR); % get trace names
        a = getappdata(gcf,'axis');
        if length(a)>1                % append names of subplot y-axis labels
           a = get(a,YLABEL);
           for k = 2:length(a) a{k} = get(a{k},STR); end;
           tn = [tn; a(2:end)];
        end;
        t = ' index';
        x = [];  % will contain the last used x axis data
        d = [];  % will contain the listbox data in the same orientation as the display
        n = 0;   % i.e. data for traces appears in columns. n will be number of rows in d
        nc = 0;  % number of columns in listbox data (not counting index)
        np = 0;  % length of previous x data
        for k = 1:length(l)
          if strcmp(get(l(k),VISIBLE),'off') continue; end;
          xx = get(l(k),XDATA);  nn = length(xx);  ix = [1 min(nn,2) max(1,nn-1) nn]; xxi = xx(ix);
          if nn~=np | ~isequalNaN(x(ix),xxi(:)) % we need a new column for x data if its different than before
            np = nn;  x = xx;
            sz = size(x);   if sz(1)==1 x = transpose(x); end; % make sure it's a column
            ex = [];                                           % extension on new x or y data to make it fit into d.
            if     nn>n  d = [d; NaN+ones(nn-n,nc)];  n = nn;  % expand old d array to accomidate a longer vector
            elseif nn<n  ex = NaN+ones(n-nn,1);                % expand smaller vectors to match previous longer ones
            end;
            d = [d [x; ex]];  t = [t '     X    '];  nc=nc+1;  % add new x column
          end;
          y = get(l(k),YDATA);  sz = size(y); if sz(1)==1 y = transpose(y); end; % make sure y vector is a column
          d = [d [y; ex]];  nc=nc+1;                % add new y column
          if length(tn)>=k
            s = tn{k};                              % get name of y column
            if length(s)>=9 s = [' ' s(1:9)];       % trunctate names to 9 chars
            else m = 9-length(s);  mf = floor(m/2); % pad names up to 9 chars
                 s = [blanks(1+m-mf) s blanks(mf)];
            end;
            t = [t s];                              % append y column name to heading
          end;
        end;
        s = {}; clr = get(cf,COLOR);
        w = 70*nc + 80;                             % required figure width for no scroll bars
        sz = get(0,'screens');  p = get(cf,POS);    % get screen size & plt figure size
        if p(3)<1 p = p .* sz([1 2 1 2]); end;      % if plt figure position was normalized, convert to pixels
        x1 = p(1) + p(3) + 12;  wa = sz(3) - x1;    % width available on right side
        if p(1) > wa  x1 = 5;  wa = p(1)-5; end;    % use left side if there is more room there
        y1 = p(2);  ha = p(4);
        if wa > w                                   % is excess width is available?
          if x1==5 x1=wa-w-7; end; wa=w;            % Yes. Use only w pixels for width.
        else                                        % will we need scroll bars?
          Y1 = p(2) + p(4) + 35;  Ha=sz(4)-Y1-80;   % height available above
          if p(2) > Ha+80  Y1=59; Ha=p(2)-94; end;  % use space below if there is more room there
          if (Ha>400) | ((Ha>200) & (sz(4)>w))      % use space above or below if it is advantagous
            ha = Ha; y1 = Y1; x2 = sz(4)-20; wa = min(x2,w); % align with right side of figure if possible
            x1 = x2-wa;  x1 = x1 - min(x1,x2-p(1)-p(3));
          elseif wa<210 wa = min(w,sz(4)-10); x1=5; % not enough room. Allow overlap with plt figure
          end;
        end;
        pos = [x1 y1 wa ha];                        % listbox figure position
        foobar = 0;   fnt = 'Courier';              % font for other operating systems & compiled code
        if exist('foobar')                          % here if running from matlab
          fnt = feval('listfonts'); fnt = [fnt{:}];
          if     length(findstr(fnt,'Consolas'))       fnt = 'Lucida Sans Typewriter';  % Windows 7/8 should come here
          elseif length(findstr(fnt,'Lucida Console')) fnt = 'Lucida Console';          % Windows XP should come here
          end;
        end;
        % Other fixed spaced fonts: 'DejaVu Sans Mono' 'Bitstream Vera Sans Mono' 'Andale Mono'
        % 'Droid Sans Mono' 'Courier New' 'Bitstream Vera Sans Mono' 'Miriam Fixed' 'Monaco' 'MS Gothic';
        for k = 1:n  s = [s {[sprintf('%5d  ',k) strrep(prin('%8V  ',d(k,:)),'NaN','   ')]}]; end;
        f = figure(NoMENU,'name',get(cf,'name'),POS,pos,COLOR,clr,TAGg);
        bx = uicontrol('style','listbox',POS,[1 1 wa ha-30],...  % data listbox
        FOREGROUND,[1 1 0],BACKGROUND,[0 0 0],USER,{s t},'FontName',fnt);
        fs = POPUP(prin('{fontsize: %d!row}',4:18),VALUE,6,POS,[wa-100 ha-19 85 16],...
          CALLBK,'set(findobj(gcf,''sty'',''l''),''fontsize'',3+get(gcbo,''value''));');
        sv = BUTTON('save',USER,bx,POS,[15 ha-25 50 20],CALLBK,...;
           '[f p]=uiputfile(''pltData.txt''); s=get(get(gcbo,''user''),''user''); t=s{2}; s=s{1}; prin(-[p f],''%s\n'',t,s{:});');
        set([bx fs sv],NORMAL);
        setappdata(cf,'bx',bx);
        figure(cf);  plt('cursor',CurID,'MVcur');
      else                                               % here for left click (toggle menu bar)
        f = get(gcf,'menu');
        if   f(1)=='f' delete(findobj(gcf,'type','uimenu')); set(gcf,'menu','none');
        else set(gcf,'menu','fig');
             v = get(0,'ShowHidden');                    % save previous value
             set(0,'ShowHidden','on');
             a = findobj(gcf,'label','&File');           % find file menu
             uimenu(a,'Label','p&lt  save','separator','on',CALLBK,'plt save;');
             uimenu(a,'Label','pl&t  open',CALLBK,'plt open;');
             c = get(a,CHILDREN);
             set(a,CHILDREN,c([4:end-3 1:3 end-2:end])); % put the new menus 4th from top
             a = findobj(gcf,'label','&Help');           % find help menu
             if length(a)                                % it won't exist if compiled
               uimenu(a,'Label','p&lt help','separator','on',CALLBK,'plt help;');
               c = get(a,CHILDREN); set(a,CHILDREN,c([2:end 1])); % put the new menus on top
               set(c(end),'separator','on');               % separator after "plt help"
             end;
             set(0,'ShowHidden',v);                      % restore previous value
             m = uimenu('label','&plt');                 % Create Color menu
             cb1 = 'a=getappdata(gcf,"axis"); a=a(1); if getappdata(a,"DualCur") b=0; ';
             cb2 = 'set(findobj(gcf,"buttond","plt click EDIT 6 3;"),"vis","of"); ';
             cb3 = 'else b=plt("cursor",get(a,"user"),"getActive",0); end; setappdata(a,"DualCur",b);';
             cb = {'plt click mark 0;' ...
                   'plt click mark 1;' ...
                   'plt click mark 2;' ...
                   'plt click mark 3;' ...
                   'set(gcf,"SelectionT","alt"); plt click TGLmenu;' ...
                   'set(gcf,"SelectionT","alt"); plt cursor 0 TGLlogx;' ...
                   'plt("hcpy","init",gcf);' ...
                   'plt hidecur;' ...
                   'h=findobj(gcf,"str","O"); eval(get(get(h(end),"ui"),"callb"));' ...
                   'delete([findobj(gcf,"tag","mark"); findobj(gcf,"tag","markR")]);' ...
                   [cb1 cb2 cb3] ...
                   'plt move;' ...
                   'plt move res;' };
             lb = {'<1>&Edit line (<2>e<3>) <4>Rclick Mark<5>' ...
                   '<1>Edit &all lines (<2>a<3>) <4>Delta+Rclick Mark<5>' ...
                   '<1>Edit &figure colors (<2>f<3>) <4>Rclick Properties in Ypopup<5>' ...
                   '<1>&Save figure colors (<2>s<3>)' ...
                   '<1>&Cursor Data Window (<2>c<3>)  <4>Rclick Menu<5>' ...
                   '<1>S&wap X/Y axes (<2>w<3>) <4>Rclick LinX<5>' ...
                   '<1>&Hardcopy (<2>h<3>) <4>Rclick LinY<5>' ...
                   '<1>H&ide/Show cursor controls (<2>i<3>)  <4>Rclick Yaxis label<5>' ...
                   '<1>&Toggle line smoothing (<2>t<3>)  <4>Rclick "o"<5>' ...
                   '<1>&Delete cursor annotations (<2>d<3>)  <4>Delta+Rclick "o"<5>' ...
                   '<1>Set d&ual cursor (<2>u<3>)' ...
                   '<1>Toggle &Reposition mode (<2>r<3>)  <4>Rclick Delta<5>'...
                   '<1>Reposition &Grid size (<2>g<3>) <4>Delta+Rclick Delta<5>' };
             sp = {'of' 'of' 'of' 'of' 'on' 'of' 'of' 'of' 'of' 'of' 'of' 'on' 'of'};
             rp = {'<1>' '<html>' '<2>' '<u>' '<3>' '</u>' '<4>' '<font color="blue"><i>' '<5>' ''};
             v = version; % no html in Matlab 6 ------------------------------------------------
             if v(1)=='6' rp = {'<1>' '' '<2>' '' '<3>' '' '<4>' '[' '<5>' ']'}; end;
             for k=1:length(cb)
               s = lb{k};
               for j=1:2:length(rp) s = strrep(s,rp{j},rp{j+1}); end;
               uimenu(m,'label',s,CALLBK,strrep(cb{k},'"',''''),'sep',sp{k});
             end;
        end;
      end;  % end if MouseRight

    case RMS_
      p = findobj(gcf,MOUSE,'plt click RMS;')';
      if length(p)>1 for pp=p if pp==gcbo p = pp; break; end; end;
                     AX = get(p,USER);  CurID = get(AX,USER);
                     Hc = get(CurMain(CurID),USER);
      end;
      misc = get(Hc(ixro),USER);                   % misc parameters
      lH = get(Hc(icurbase+misc(Jact)),USER);
      hix = Hc(ixro);  hiy = Hc(iyro);  hix2 = Hc(ixexp);  hiy2 = Hc(iyexp);
      x = get(lH{1},XDATA);  y = get(lH{1},YDATA);
      xlim = get(Hc(iaxOwner),XLIM);               % get current x-axis limits
      xx = find(x >= xlim(1)  &  x <= xlim(2));    % indicies within x limits
      y = y(xx); y = y(~isnan(y)); ly = length(y); % y data within x limits
      ps = get(p,STR);
      switch sum(ps)
        case Avg_,  s = 'RMS'; r = Pftoa('%7w',sqrt(sum(y.^2)/ly));
        case RMS_,  s = 'y/x';
                    xr = s2d(get(hix,STR));
                    r = getappdata(p,'idcur');
                    r = Pftoa('%7w',s2d(r{2})/xr);
                    if sum(get(hiy2,VISIBLE))==on_ & sum(get(hix2,VISIBLE))==on_
                       xr = str2num(get(hix2,STR));
                       set(hiy2,STR,s2d(get(hiy2,STR))/xr);
                    end;
        case yox_,  s = '\surdx^2+y^2';
                    xr = s2d(get(hix,STR));
                    q = getappdata(p,'idcur');
                    r = Pftoa('%7w',abs(xr + s2d(q{2})*1j));
                    if sum(get(hiy2,VISIBLE))==on_ & sum(get(hix2,VISIBLE))==on_
                       xr = str2num(get(hix2,STR));
                       set(hiy2,STR,abs(xr + s2d(q{3})*1j));
                    end;
        case x2y2_, r = getappdata(p,'idcur');  s = r{1}; set(hiy2,STR,r{3});  r = r{2};
        otherwise,  nwt = getappdata(gcf,'newtxt');
                    if MouseRight & length(nwt)
                         setappdata(gcf,'newtxt',[]);
                         set(findobj(findobj(gcf,isTraceID),STR,ps),STR,nwt);
                         set(p,STR,nwt); set(hiy,STR,'');
                         return;
                    else setappdata(p,'idcur',{ps get(hiy,STR) get(hiy2,STR)});
                         s = 'Avg';
                         r = Pftoa('%7w',sum(y)/ly);
                    end;
      end;  % end switch sum(ps)
      set(p,STR,s); set(hiy,STR,r);

    case EDIT_
      in3 = varargin{3} - '0';
      a = getappdata(gcf,'Dedit');
      if isempty(a) return; end;
      cid = a{1};   Hc = get(CurMain(cid),USER);
      % oops ... kinda mixing up the use of this case, i.e. not only used for data editing anymore
      % so we have two versions of cid & Hc
      cid2 = get(gcbo,TAG);  Hd = [];
      if length(cid2) cid2 = s2d(cid2);
                      if length(cid2) & cid2>0 & cid2<=length(CurMain)
                         hd = CurMain(cid2);
                         if ishandle(hd) Hd = get(hd,USER);  end;
                      end;
      end;
      switch in3
      case 1,                                                     % right click on the xedit box comes here
        if length(Hd) & sum(get(Hd(iexpbox),VISIBLE))==on_        % if expansion box is visible move its left
          plt click EDIT 6 0;                                     % edge to the left or right
          return;
        end;
        if ishandle(a{3}) & length(get(a{3},MOUSE)) return; end;  % do nothing if already in edit mode
        misc = get(Hc(ixro),USER);                                % misc parameters
        hact = Hc(icurbase + misc(Jact));                         % handle of active cursor
        a{9} = misc(Jix);                                         % current cursor index
        m = get(hact,'marker'); a{4} = m(1)+0;                    % current marker shape
        ix = a{2};
        if a{3}~=hact  a{3} = hact;  a{7} = 0;                    % if we moved to a new trace
                       if ix<4 ix=ix+3; a{2}=ix; end;             % then switch from range to modify mode
        end;
        setappdata(gcf,'Dedit',a);
        b = 'plt click EDIT 3;';
        if ix<4 fc = get(hact,COLOR); else fc = 'auto'; end;
        mk = 'd>^d>^';  msz = getappdata(gcf,'EditCur');
        set(hact,'marker',mk(ix),'markerface',fc,'markersize',msz,MOUSE,b);
      case 2,                                              % right click on yedit box comes here
        if length(Hd) & sum(get(Hd(iexpbox),VISIBLE))==on_ % if expansion box is visible, move lower edge
          plt click EDIT 6 2;                              % of the expansion box up or down
          return;
        end;
        hd = [findobj(gcf,'style','edit',SHOW); findobj(gcf,isGRID)];
        set(hd,HIDE);                                      % hide edit boxes
        gc = findobj(hd,MOUSE,'plt click EDIT 2;');        % instead of gco (to allow external calls)
        if length(gc)>1 gc = gco; end;
        fd = find(hd==gc);
        if length(fd) hd(fd) = [];  hd = [gc; hd]; end;    % put current object first
        hpop = getappdata(gcf,'epopup');
        setappdata(hpop,'EdHide',hd);                      % remember so we can unhide them
        pe = get(gc,POS);  pa = get(hpop,PARENT);
        set(pa,POS,[pe(1) .01 .13 .45]);
        set(gcf,ClickType,'normal');
        evalQ(get(hpop,MOUSE));
        set(findobj(pa,STR,'Cancel'),COLOR,[0 0 0],BOLD);
      case 3, set(gcf,'WindowButtonMotionFcn','plt click EDIT 4;',...
                      'WindowButtonUpFcn',[MOTIONoff ' plt click EDIT 5;']);
      case 4, % move the data editing cursor
        i = mod(a{2},3);                                        % 0,1,2 = modify y,both,x
        fmt = get(Hc(iylabel),USER);                            % formats stashed here
        y = get(get(a{3},PARENT),CurPOINT); x=y(1,1); y=y(1,2); % get (x,y) using correct axis
        if i~=2 set(a{3},YDATA,y); set(Hc(iyro),STR,Pftoa(fmt(2,:),y)); end;
        if i~=0 set(a{3},XDATA,x); set(findobj(gcf,'sty','edit',STR,get(Hc(ixro),STR)),...
                                                STR,Pftoa(fmt(1,:),x));
        end;
        m = getappdata(gca,'MotionEdit');
        if length(m)  if ischar(m)     feval(m,a);
                      elseif iscell(m) m = [m {a}]; feval(m{:});
                      else             m = {m a};   feval(m{:});
                      end;
        end;
      case 5, % cancel data editing
        ix = a{2};  hact = a{3};  lh = get(hact,USER);  lk = lh{1};
        xy = getxy(lk);  i = a{9};  xy1 = getxy(hact);
        if ix<4 ilast = a{7};                             % modify range --------------
                xy0 = xy(ilast);                          % yes ... do it.
                inc = 1 - 2*(ilast>i);  dxy = (xy1-xy0)/max(1,abs(ilast-i));
                for k = ilast:inc:i xy(k)=xy0; xy0=xy0+dxy; end;
        else    if MouseRight
                  co = plt('cursor',cid,'obj');  ye = find(get(co(2),'str') == [168 62 68]); % get yedit mode from ylabel string
                  if isempty(ye) xy = xy([1:i i i+1:end]); end; % for non-persistent insert mode 
                end;
                xlim = get(hact,PARENT);  ylim=get(xlim,YLIM); xlim=get(xlim,XLIM); % here for modify a point
                if real(xy1)<xlim(1) | real(xy1)>xlim(2) | imag(xy1)<ylim(1) | imag(xy1)>ylim(2)
                      xy(i) = [];   % remove a point
                else  xy(i) = xy1;  % modify a single point
                end;
        end;
        setxy(lk,xy); setappdata(gcf,'NewData',i);
        if (Narg==4 & mod(a{2},3)==1) return; end; % stay in edit mode if typing in both x & y
        a{7} = i;  a{8} = hact;  setappdata(gcf,'Dedit',a);  % remember for modify range mode
        set(a{3},'marker',char(a{4}),'markerface','auto','markersize',a{5});
        plt('cursor',cid,'update',i);  % update xstring,ystring,movecb2
        es = getappdata(gcf,'EditStop');
        if length(es) if ischar(es)     feval(es,a);
                      elseif iscell(es) es = [es {a}]; feval(es{:});
                      else              es = {es a};   feval(es{:});
                      end;
        end;
        set(a{3},MOUSE,'');            % save to the end so 'update' can tell we were in edit mode
      case 6, % adjust expansion box size
        in4 = varargin{4} - '0';  % in4 = 0/1/2/3 for left/right/lower/upper edge
        e = zeros(1,4);  e(in4+1) = 1;                   % e(1/2/3/4)=1 for left/right/lower/upper edge
        h = Hd(ixro:iyexp);  v = get(h,STR);             % get strings for all 4 edit boxes
        v=[v v]'; v(2,:)={' '}; v=sscanf([v{:}],'%f')';  % insert blanks between strings & convert to numbers
        limy = Hd(iaxOwner);
        limx = get(limy,XLIM);  limy = get(limy,YLIM);   % smallest expansion box allowed is
        mnxy = [diff(limx)/300 diff(limy)/300];          % 1/3 of a percent of the axis limits.
        lim = [limx limy];  spd = mnxy/100;              % movement speed factor
        p = get(0,'PointerLoc');                         % horiz/vert position of mouse click
        r = get(gcbo,POS);  r = r(1) + [0 r(3)];         % left/right edges of edit box  
        if r(1)<1 fp = get(gcf,POS);  r = r*fp(3); end;  % convert to pixels
        q = get(gcf,CurPOINT);
        if min(abs(q(1) - r)) < 5 e=1+0*e; end;          % if click is close to an edge, move all 4 sides
        f = gcf;  setappdata(f,'bdown',1);
        set(f,'WindowButtonUp','setappdata(gcf,''bdown'',0);');
        if length(v)<4 return; end;
        while getappdata(f,'bdown')                      % loop until user lets go of mouse
          q = spd .* (get(0,'PointerLoc')-p);            % compute horiz/vert speed from mouse position
          if e(1) v(1) = min(max(v(1)+q(1),lim(1)),v(2)-mnxy(1)); set(h(1),STR,Pftoa('%7w',v(1))); end;
          if e(2) v(2) = max(min(v(2)+q(1),lim(2)),v(1)+mnxy(1)); set(h(2),STR,Pftoa('%7w',v(2))); end;
          if e(3) v(3) = min(max(v(3)+q(2),lim(3)),v(4)-mnxy(2)); set(h(3),STR,Pftoa('%7w',v(3))); end;
          if e(4) v(4) = max(min(v(4)+q(2),lim(4)),v(3)+mnxy(2)); set(h(4),STR,Pftoa('%7w',v(4))); end;
          set(Hd(iexpbox),XDATA,v([1 2 2 1 1]),YDATA,v([3 3 4 4 3]));
          mZoom(v); pause(.02); % execute MotionZoom function (50 Hz repeat rate)
        end;
      end; % end switch in3

    case Yedit_                                     % callback for Yedit popup
      a = getappdata(gcf,'Dedit'); a3 = a{3};
      switch ix
      case 1,                                         % the first popup selection ("properties")
         if MouseLeft plt('click','mark','-1',CurID); % here for left click (lines or all lines)
         else         plt click mark 2;               % for right click: edit figure properties
         end;
      case 2,                                         % toggle multiCursor
         multi = getappdata(AX,'multi');
         if length(multi) delete(multi); setappdata(AX,'multi',[]);   % if multicursors exist, remove them
                          if MouseLeft return; end;                   % use right click to reconfigure multicursors
         end;
         Lha = getappdata(AX,'Lhandles'); Lhav = get(Lha,VISIBLE);   % get line handles and their visibility
         n = length(Lha);  cL = get(Lha,COLOR);
         c = (get(Lha(1),COLOR) + get(Lha(min(n,4)),COLOR))/2;        % average color of two traces
         nn = zeros(1,n);  nnn = [nn; nn];  par = get(Lha,PARENT);
         tx = text(nn,nn,'');                                         % multiCursor text
         x = get(Lha(plt('cursor',CurID,'getActive')),XDATA);  if length(x)<3 return; end;  x12 = x([1 2 end]);
         for k=1:n  % only enable multiCursor text on lines with the same x vector as the active cursor
           x = get(Lha(k),XDATA);
           if length(x)<3 | ~all(x([1 2 end])==x12) Lhav{k} = 'off'; end;
         end;
         pr1 = {PARENT};  cl1 = {COLOR};  vl1 = {VISIBLE};
         if n<2 pr1 = pr1{1};  cl1 = cl1{1};  vl1 = vl1{1}; end;
         set(tx,pr1,par,'unit','data',cl1,cL,TAG,'  %7w',vl1,Lhav); 
         mr = line(nnn,nnn,COLOR,c,'marker','o');                     % multiCursor markers
         set(mr,pr1,par,vl1,Lhav);                                    % show markers only on visible lines
         vl = line([0 0],1e9*[-1 1],COLOR,c,LINESTYLE,':',PARENT,AX); % multiCursor vertical line
         mc = [tx; mr; vl];  set(mc,MOUSE,get(AX,MOUSE));
         p = getappdata(gcf,'mcProps');
         for k = 1:2:length(p)
           prop = p{k};  prp = prop(2:end); val = p{k+1};
           switch prop(1)
             case '|',  set(vl,prp,val);
             case '+',  if iscell(val) prp  = {prp};  end; set(mr,prp,val);
             otherwise, if iscell(val) prop = {prop}; end; set(tx,prop,val);
           end;
         end;
         setappdata(AX,'multi',mc);  plt('cursor',CurID,'update');   % save for cursor update function
      case 3,
         xView = getappdata(AX,'xView');
         if nargin<4 % toggle xView slider
           if length(xView) l = xView{1};  delete([l get(l,PARENT)]);
                            set(AXrl,POS,xView{2});
                            setappdata(AX,'xView',[]);
                            return;
           end;
           hL = getappdata(AX,'Lhandles');  minx=+inf;  maxx=-inf;
           for i=1:length(hL) x = get(hL(i),XDATA);  minx  = min(minx,min(x));  maxx  = max(maxx,max(x));  end;
           xlm = [minx maxx];   if length(xlm) ~= 2 return; end;
           p = get(AX,POS);  g = get(gcf,POS);  g = g(4);
           c1 = get(gcf,COLOR);  c2 = get(AXrl(end),COLOR);  d = c2 > 0.5;
           p2 = p - [0 0 0 20/g];  set(AXrl,POS,p2);
           vs = 30 - 20*isempty(get(get(AX,'title'),STR)); % vertical space between plot and xView slider
           p3 = p2 + [0 p2(4)+vs/g 0 12/g-p2(4)];
           lx = get(AX,XLIM);  dlx = mean(lx) + diff(lx)*[-1 1]./16;
           v = axes(POS,p3,XLIM,xlm,YLIM,[1 3],COLOR,c2,XCOLOR,c2,YCOLOR,c1,NOTICK,MOUSE,'plt click Yedit 3 0;');
           l = line(lx,[2 2],COLOR,c2 + .33*(~d - d),'linewidth',16,MOUSE,'plt click Yedit 3 1;',USER,dlx);
           set([v l],TAG,sprintf('%d',CurID));
           if ~MverE set(v,'clippingStyle','rectangle'); end; % for Matlab R2014b or later
           r = getappdata(gcf,'xvProps');
           for k = 1:2:length(r)
             prop = r{k};  val = r{k+1};
             if prop(1) == '+'  prop(1)='';  if isempty(prop) prop=POS; val = val+p3; end;
                                set(v,prop,val);
             else               set(l,prop,val);
             end;
           end;
           setappdata(AX,'xView',{l p 0});
           axes(AX);
         else % plt('click','Yedit',3,x)
           if isempty(xView) disp('Error in plt: xView not found'); return; end;
           l = xView{1};  v = get(l,PARENT);  x = get(v,CurPOINT);  x = x(1,1);  lx = get(l,XDATA);
           v4 = varargin{4}-'0';  if v4==1 & MouseRight v4=0; end; % right click always does axis buttondown
           switch v4
             case 0, % axis buttondown function
                     lx((x>mean(lx))+1) = x;  x = lx;
                     set(gcf,'WindowButtonMotionFcn','plt click Yedit 3 2;','WindowButtonUpFcn',MOTIONoff,TAG,get(v,TAG));
             case 1, % line buttondown function
                     if MouseDbl x = get(v,XLIM);
                                 if lx(1)>x(1) | lx(2)<x(2) set(l,USER,lx); else x = get(l,USER); end;
                     else xView{3} = x-lx(1);  setappdata(AX,'xView',xView); x=lx; % save mouse x position offset
                          set(gcf,'WindowButtonMotionFcn','plt click Yedit 3 3;','WindowButtonUpFcn',MOTIONoff,TAG,get(v,TAG));
                     end;
             case 2, lx((x>mean(lx))+1) = x;  x = sort(lx);
             case 3, x = x-xView{3};  x = [x x+diff(lx)];
           end; % end switch v4
           set(l,XDATA,x);  set(AXrl,XLIM,x);
           axes(AX); evalQ(get(Hc(ixexp),USER));   % execute axis change callback
         end; % end if nargin<4
      case 4,  % cancel
        if ishandle(a3)
          set(a3,'marker',char(a{4}),'markerface','auto','markersize',a{5},MOUSE,'');
          if MouseRight  lh = get(a3,USER);  setxy(lh{1},a{6}); end;
          a{3} = -1;  a{6} = [];  setappdata(gcf,'Dedit',a);
        end;
      otherwise,  % all the other popup selections (cursor data edit)
        b = 'plt click EDIT 3;';                                         % buttondownfunction
        if ishandle(a3) & strcmp(b,get(a3,MOUSE)) plt click EDIT 5; end; % cancel any edit operations in progress
        ix = ix - 4; % ix=1,2,3 modify range,  4,5,6 modify or insert point
        if MouseRight & ix>3 & nargin<4
          h = plt('cursor',CurID,'obj'); h = h(2);  s = [168 62 68];  s = char(s(ix-3));
          pr = {'str' 'fontn'}; of = getappdata(h,'of'); % get old string,fontname
          if length(of) set(h,pr,of); rmappdata(h,'of'); % restore old string,fontname
          else setappdata(h,'of',get(h,pr));  set(h,pr,{s 'symbol'});
          end;
          return;
        end;
        Hc = get(CurMain(CurID),USER);  misc = get(Hc(ixro),USER);  % misc parameters
        hact = Hc(icurbase + misc(Jact));              % handle of active cursor
        if ix<4 & hact~=a{8}                           % don't allow range unless we are on the same trace
          ix=ix+3;                                     % switch from range to modify mode
        end;
        m = get(hact,'marker'); m = m(1)+0;            % current marker shape
        i = misc(Jix);                                 % current cursor index
        lh = get(hact,USER);  lk = lh{1};  if strcmp(get(lk,TAG),'NoEdit') return; end;
        xy = getxy(lk);
        if MouseRight setxy(lk,xy([1:i i i+1:end])); end;% add a single point (insert mode)
        %      1   2   3   4  5                     6   7    8   9   % index into Dedit
        a = {CurID ix hact m get(hact,'markersize') xy a{7} a{8} i}; % info for processing & cancelling edit mode
        setappdata(gcf,'Dedit',a);
        if ix<4 fc = get(hact,COLOR); else fc = 'auto'; end;
        mk = 'd>^d>^';  msz = getappdata(gcf,'EditCur');
        set(hact,'marker',mk(ix),'markerface',fc,'markersize',msz,MOUSE,b);
        es = getappdata(gcf,'EditStart');
        if length(es) if ischar(es)     feval(es,a);
                      elseif iscell(es) es = [es {a}]; feval(es{:});
                      else              es = {es a};   feval(es{:});
                      end;
        end;
      end;
    end;  % end switch sum(y2)
    plt('grid',AX);
  else % here for the traceID box callback
       AX = get(y2(1),PARENT);  CurID = get(AX,USER);
       yal = get(AX,'YAxisLoc');  % AX now must either the correct left or right hand axis
       if yal(1)=='r' AX2 = AX;  AX = findobj(gcf,'YAxisLoc','left',USER,get(AX,USER));
       else           AX2 = findobj(gcf,'YAxisLoc','right',USER,CurID);
       end;
       if isempty(AX2) AX2 = -1; end;
       y8 = y2;  j = y8(2);                         % here for trace ID callback
       clkType = MouseType;                         % get type of mouse click
       p = {COLOR; 'marker'; LINESTYLE; 'linewidth'}; q = {[0 .3 .3] 'none' '-' 9};
       if clkType==normal_ | Narg>2     % left click
          k = y8(1);  s = get(k,VISIBLE); s = s(2)=='n';
          if s set(k,HIDE); else set(k,SHOW); end;   % toggle trace visibility
          if ishandle(j) & length(get(j,PARENT))
            mk = getappdata(j,'mk');                 % traceID line handle
            if s   set(j,ITALIC,BOLDnot); set(mk,p,q);
            else   set(j,ITALICnot,BOLD); set(mk,p,get(k,p));
            end;
          end;
       else                                          % right click or double click
          for k = findobj(get(j,PARENT),'type','text')'  % find all the trace ID srings
            t = get(k,MOUSE);
            if iscell(t) & length(t{end})==2
              t = t{end}(1);
              mk = getappdata(k,'mk');
              if clkType==open_ | k==j  set(t(1),SHOW);  set(k,ITALICnot,BOLD);  set(mk,p,get(t,p));
              else                      set(t(1),HIDE);  set(k,ITALIC,BOLDnot);  set(mk,p,q);
              end;
            end;
          end;
       end;
       DualCur = getappdata(AX,'DualCur');
       Lh = getappdata(AX,'Lhandles');
       ls = findobj(Lh,PARENT,AX);     % traces on left axes
       v = 'off';
       for k=1:length(ls)
         if strcmp(get(ls(k),VISIBLE),'on') v = 'on';  break; end;
       end;
       set(get(AX,YLABEL),VISIBLE,v);
       if ishandle(AX2)                % here if there is a right hand axis
         ls = findobj(Lh,PARENT,AX2);  % traces on right axes
         v = 'off';  leftC = get(AX2,COLOR);  gridXOR = leftC;
         for k=1:length(ls)
           if strcmp(get(ls(k),VISIBLE),'on')
             v = 'on';  leftC = 'none';  gridXOR = get(gcf,COLOR);
             set(AX2,XLIM,get(AX,XLIM));
             break;
           end;
         end;
         set(AX2,VISIBLE,v);  set(AX,COLOR,leftC);
         gridH = findobj(AX,isGRID);
         if length(gridH)==1
           er = get(gridH,ERAS);
           if er(1)=='x'
             set(gridH,COLOR,bitxor(round(255*getappdata(gridH,'clr')),round(255*gridXOR))/255);
           end;
         end;
       end;
       TIDback = [];
       if Narg<3 & ishandle(j) TIDback = getappdata(get(j,PARENT),'TIDcback'); end; % get trace ID callback
       if length(TIDback)
          setappdata(gcf,'OBJ',y2(1));  setappdata(gcf,'OBJ2',y2(2));
          evalRep(TIDback,{'@LINE' 'plt("misc",3)' '@TID' 'plt("misc",4)' '@IDX' 'plt("misc",5)'});
       end;
       axes(AX);  % may not need
  end;  % end ischar(y2)
% end case 'click'

case hidecur_, % right click on y-axis label to hide/show cursor objects
  cid = get(gca,USER);  h = plt('cursor',cid,'obj');  h = get(h(1),VISIBLE);
  if h(2)=='n' plt('cursor',cid,'visOFF'); v = 'off';
  else         plt('cursor',cid,'visON');  v = 'on';
  end;
  for k = findobj(gcf,'tag','MenuBox')'
    if getappdata(k,'cid')==cid  set([k; get(k,CHILDREN)],VISIBLE,v); end;
  end;
% end case 'hideCur'

case show_, % In2 is a list of trace numbers to enable. All other traces are disabled
  h = getappdata(gcf,'Lhandles');  n = length(h);
  q = 3-cellfun('length',get(h,VISIBLE));   % q(I) is true if the Ith trace is visible
  if Narg<2 Ret1 = find(q'); return; end; % no arguments ... returns list of visible traces
  v = zeros(n,1);  w=v;  e = varargin{2};
  if ischar(e) & length(e) v=v+1;  else v(e)=1; end; % enable selected traces, disable the remaining
  v = find(xor(v,q));          % trace numbers to toggle
  t = findobj(gcf,isTraceID);  % find axis holding the Trace IDs
  if length(t)                 % get handles of text strings in TraceID box
    t = [flipud(findobj(t,'type','text')); w];
  end;
  for k=1:length(v) plt('click',[h(v(k)) t(v(k))],0); end; % toggle appropriate traces
% end case 'showTrace'

case move_,
  if Narg==1  % toggle move status (right click on delta button)
     if isempty(getappdata(gcf,'mv')) plt move init; end; % initialize if it hasn't been done yet
     if getappdata(gcf,'mv') plt move off; else plt move on; end;
     return;
  end;
  ui = getappdata(gcf,'uic');                          Nui = length(ui);
  si = getappdata(gcf,'sli');                          Nsi = length(si);
  ax = getappdata(gcf,'axi');                          Nax = length(ax);
  tx = getappdata(gcf,'txt');  tx = tx(ishandle(tx));  Ntx = length(tx); % don't included deleted help text
  pp = getappdata(gcf,'pop');                          Npp = length(pp);
  v = varargin{2};
  if ~ischar(v)  % allow the mouse to move the objects in the handle list In2
    for k=1:length(v)
      t = v(k);
      switch get(t,'type')
        case 'uicontrol', ui = [ui t]; setappdata(gcf,'uic',ui);
        case 'text',      tx = [tx t]; setappdata(gcf,'txt',tx);
        case 'axes',      ax = [ax t]; setappdata(gcf,'axi',ax);
      end;
    end;
    return;
  end;
  v = sum(v);
  switch v
  case res_  % set SnapTo resolution
    f = gcf;
    if isempty(getappdata(f,'mv')) plt move init; end;
    r = getappdata(f,'snap');
    figure(NoMENU,'resize','off',POS,auxLoc(270,60),COLOR,dlgBKc,'name','SnapTo resolution',USER,gcf,TAGg);
    plt('slider',[.035 .64],[r(1) 0 200 0 10000],'No. of X grid points',...
      'g = get(gcf,"user"); r = getappdata(g,"snap"); setappdata(g,"snap",[@VAL r(2)])',2);
    plt('slider',[.525 .64],[r(2) 0 200 0 10000],'No. of Y grid points',...
      'g = get(gcf,"user"); r = getappdata(g,"snap"); setappdata(g,"snap",[r(1) @VAL])',2);
    figure(f);  % return to the active figure
    return;
  case init_ % allow the mouse to move all text and ui objects in the current figure
    if isempty(getappdata(gcf,'snap')) setappdata(gcf,'snap',[100 100]); end; % default SnapTo res

    t = findobj(gcf,'type','text');
    for k=1:length(t); % add text objects not created by plt
      if isempty(getappdata(t(k),'ty')) tx = [tx t(k)]; setappdata(t(k),'ty','txt'); end;
    end;
    setappdata(gcf,'txt',tx)

    for k=1:Nsi setappdata(si(k),'ty','sli'); end;
    t = findobj(gcf,'type','uicontrol');
    for k=1:length(t)  % add uicontrols not created by plt
      if isempty(getappdata(t(k),'ty')) ui = [ui t(k)]; setappdata(t(k),'ty','uic'); end;
    end;
    t = findobj(gcf,'type','uipanel');  r = findobj(gcf,'type','uitable');
    ui = [ui t' r'];
    for k=1:length(t) setappdata(t(k),'ty','uip'); end;
    for k=1:length(r) setappdata(r(k),'ty','uit'); end;
    setappdata(gcf,'uic',ui);

    t = findobj(gcf,'type','axes');
    for k=1:length(t)  % add axes not created by plt
      if isempty(getappdata(t(k),'ty')) ax = [ax t(k)]; setappdata(t(k),'ty','axi');
      end;
    end;
    setappdata(gcf,'axi',ax);
    setappdata(gcf,'mv',0);  % indicate that the move initialization is complete
    return;
  end; % end switch v
  uip = {MOUSE 'ena'};
  if v==on_                                                   % here to enter repositioning mode -----------
    if isempty(getappdata(gcf,'mv')) plt move init; end;      % initialize if it hasn't been done yet
    setappdata(gcf,'mv',1);                                   % indicate repositioning mode is on
    tidmvs = 'plt misc tidmv;';
    for k=1:Nui uik = ui(k);  tys = sum(getappdata(uik,'ty'));
                if tys==uip_ uipp=MOUSE; else uipp=uip; end;  % uipanel doesn't have an enable property
                setappdata(uik,'CBsv',get(uik,uipp));         % save properties listed in uipp
                if tys==uip_ | tys==edi_ | strcmp(get(uik,TAG),'E')
                   set(uik,MOUSE,tidmvs);                     % allow uipanel & edit pseudo objects to be dragged
                else                                          % (don't disable edit pseudo objects and their labels)
                  set(uik,DISABLE,MOUSE,tidmvs);              % allow uicontrol to be dragged to new position
                end;
    end;
    for k=1:Nsi setappdata(si(k),'CBsv',get(si(k),uip));      % save properties listed in sli
                set(si(k),DISABLE,MOUSE,'plt misc slimv;');   % allow pseudo slider to be dragged to new position
                setappdata(si(k),'ty','sli');
    end;
    for k=1:Nax setappdata(ax(k),'CBsv',get(ax(k),MOUSE));    % save buttondown function
                set(ax(k),MOUSE,tidmvs);                      % allow axis to be dragged to new position
    end;
    for k=1:Ntx setappdata(tx(k),'CBsv',get(tx(k),MOUSE));    % save buttondown function
                set(tx(k),MOUSE,'plt misc txtmv;');           % allow text object to be dragged to new position
    end;
    for k=1:Npp setappdata(pp(k),'CBsv',get(pp(k),MOUSE));    % save buttondown function
                set(pp(k),MOUSE,tidmvs);                      % allow popup pseudo object to be dragged to new position
    end;
    setappdata(gcf,'CBsv',get(gcf,MOUSE));  set(gcf,MOUSE,'');
    gr = findobj(gcf,isGRID);
    if length(gr) gr=gr(end); setappdata(gr,'CBsv',get(gr,MOUSE)); set(gr,MOUSE,tidmvs); end;
    set(findobj(gcf,STR,'D','fontn','symbol'),STR,char(222)); % change delta to a right arrow to indicate reposition mode
  else                                                        % revert to normal mode ----------------
    set(findobj(gcf,STR,char(222),'fontn','symbol'),STR,'D'); % change the right arrow back to a delta
    setappdata(gcf,'mv',0);                                   % indicate repositioning mode is off
    for k=1:Nui if sum(getappdata(ui(k),'ty'))==uip_
                     set(ui(k),MOUSE,getappdata(ui(k),'CBsv'));
                else set(ui(k),uip,getappdata(ui(k),'CBsv'));
                end;
    end;
    for k=1:Nsi set(si(k),uip,     getappdata(si(k),'CBsv')); end;
    for k=1:Nax set(ax(k),MOUSE,   getappdata(ax(k),'CBsv')); end;
    for k=1:Ntx set(tx(k),MOUSE,   getappdata(tx(k),'CBsv')); end;
    for k=1:Npp set(pp(k),MOUSE,   getappdata(pp(k),'CBsv')); end;
    set(gcf,MOUSE,getappdata(gcf,'CBsv'));
    gr = findobj(gcf,isGRID);
    if length(gr) gr=gr(end); set(gr,MOUSE,getappdata(gr,'CBsv')); end;
  end;

case close_,   for f = findobj('type','fig')'
                   b = get(f,MOUSE);
                   if iscell(b) & length(b)>3 & sum(lower(b{4}))==axiscb_
                     set(f,'closereq','closereq'); close(f);
                   end;
               end;
               setappdata(0,'CurMain',[]);
case rename_,  set(flipud(findobj(findobj(gcf,isTraceID),'type','text')),{STR},varargin{2}(:));
case cright_,  set(gcf,ClickType,'alt');    plt('cursor',varargin{2:end});
case cleft_,   set(gcf,ClickType,'normal'); plt('cursor',varargin{2:end});
case xright_,  set(gcf,ClickType,'alt');    plt('click',varargin{2:end});
case xleft_,   set(gcf,ClickType,'normal'); plt('click',varargin{2:end});
case version_, Ret1 = PLTversion; Ret2 = 0;

otherwise, [Ret1 Ret2] = pltinit(varargin{:});
%otherwise, [Ret1 Ret2] = feval('pltinit',varargin{:});
end; % end switch y1
% end function plt


function t = logTicks(lim)
  a = lim(1);  b = lim(2);
  if a<=0 | b<=0  t=lim; return; end;  % shouldn't happen
  ex = floor(log10(a));  p = 10^ex;
  d = floor(a/p);  t = d*p;
  while 1
    d = d+1;
    if d>9 d=1; ex=ex+1;  p=p*10; end;
    v = d*p;   t = [t v];
    if v>=b break; end;
  end;
% end function logTicks

function setlim(ax,prop,lim);                        % set axis xlim or ylim property
  if lim(1) <= 0 | lim(2) <= 0                       % can't use negative limits for log scaling
    s = get(ax,[prop(1) 'scale']);                   % get scaling type
    if s(2) == 'o' lim = abs(lim(2))*[0.001 1]; end; % use 3 decades for log scaling
  end;
  set(ax,prop,lim);
%end function setlim

function mZoom(xy) % execute MotionZoom function
  a = getappdata(gca,'MotionZoom');
  if length(a)
    x = sort(xy(1:2));  y = sort(xy(3:4));
    if diff(x) & diff(y)
      b = [x y];
      if ischar(a)     feval(a,b);
      elseif iscell(a) a = [a {b}]; feval(a{:});
      else             a = {a b};   feval(a{:});
      end;
    end;
  end;
% end function mZoom

function fixMark()
  markR = findobj(gcf,TAG,'markR')';
  if isempty(markR) return; end;
  for l = markR
    u = get(l,USER);                                       % set(l,TAG,'markR',USER,{t AX p ylim rlim});
    t = u{1};  ax = u{2};  axr = u{3};  ylim = u{4};  rlim = u{5};
    if ishandle(t) p = get(t,POS);  else p = [0 0]; end;
    y = [get(l,YDATA) p(2)];                               % y coordinate of marker & associated text
    y = rlim(1) + diff(rlim) * (y - ylim(1)) / diff(ylim); % translate coordinate to right axis
    rlim = get(axr,YLIM);   ylim = get(ax,YLIM);
    y = ylim(1) + diff(ylim) * (y - rlim(1)) / diff(rlim); % translate back to left axis
    set(l,YDATA,y(1),USER,[u(1:3) {ylim rlim}]);           % move marker
    if ishandle(t) p(2) = y(2);  set(t,POS,p); end;        % move associated text
  end;
%end function fixMark

function edg(txt,clr)
  v6 = version;  v6 = (v6(1)=='6');
  if nargin>1
    if v6 if strcmp(clr,'none') return; end; % don't need a line if edge color is 'none'
          a = get(txt,PARENT); % version 6 doesn't have text edge property, so draw a line box
          setappdata(txt,'li',line(0,0,PARENT,a,COLOR,clr,'clip','off'));
    else  set(txt,'edge',clr); % set the text edge color (Matlab 7 or greater)
    end;
  elseif v6  li = getappdata(txt,'li');
             if ishandle(li)
               e = get(txt,'extent');  x=e(1); y=e(2); x2=x+e(3); y2=y+e(4)*1.1;
               set(li,XDATA,[x x2 x2 x x],YDATA,[y y y2 y2 y]);
             end;
  end;
%end function edge

function v = auxLoc(w,h,au)   % returns position for auxiliary figure
     f = findobj('type','fig',TAGg);  nfig = length(f);
     if nargin==3  % if the au argument is included,
       area = 0;   % gf will be the figure with the largest area
       for k=1:nfig
         p = get(f(k),POS); p = prod(p(3:4)); if p>area area=p; gf=f(k); end;
       end;
     else gf=gcf; au=0;                      % otherwise just use the current figure as the base
     end;
     set(0,PIXELS);  sz = get(0,'screens');  % get screen size in pixels
     szw = sz(3) - w - 4;                    % farthest to the right it will fit
     ppos  = get(gf,POS);
     if ppos(4)<1 sp = sz(3:4); ppos = ppos .* [sp sp]; end; % in case units = normalized
     x = min(ppos(1)+ppos(3)+9,szw) + au;    % add offset for fatter border (resizeable)
     y = ppos(2) + ppos(4) - h - 30*(nfig-1);
     v = [x y w h];
% end function auxLoc

function c = divc(a,b)  % divide real & imaginary parts separately
  c = complex(real(a)/real(b),imag(a)/imag(b));
% end function divc

function r2 = plt2nd(v) % returns the second plt output argument
  [r1 r2] = plt(v{:});
%end function plt2nd

function evalQ(a)
  % disp(a);  % debug
  if ischar(a)     a = strrep(a,'"','''');  % allow double quote to mean two single quotes
                   eval(a);
  elseif iscell(a) feval(a{:});
  else             feval(a);
  end;
%end function evalQ

function evalRep(a,rep) % evaluation with replacements
  % disp(a);  % debug
  if ischar(a)     for k=1:2:length(rep) a = strrep(a,rep{k},rep{k+1}); end;
                   a = strrep(a,'"','''');  % allow double quote to mean two single quotes
                   eval(a);
  elseif iscell(a) feval(a{:});
  else             feval(a);
  end;
%end function evalRep

function r = evalRep2(a,rep)                % same as evalRep except a result is returned
  % disp(a);  % debug
  if ischar(a)     for k=1:2:length(rep) a = strrep(a,rep{k},rep{k+1}); end;
                   a = strrep(a,'"','''');  % allow double quote to mean two single quotes
                   r = eval(a);
  elseif iscell(a) r = feval(a{:});
  else             r = feval(a);
  end;
%end function evalRep2

function [rpt,p] = getREPEAT(e)                   % get custom or default repeat rate
  rpt = getappdata(gcbo,'repeat');                % get custom repeat rate (-1 for no repeats)
  if nargin & isempty(rpt)                        % only used for pseudo edit objects
     b = get(gcbo,MOUSE);                         %  (in case we clicked on the label)
     if iscell(b) & length(b)>2 rpt = getappdata(b{3},'repeat'); end;
  end;
  if length(rpt)>1 p = rpt(2); else p = .4; end;  % 2nd element is repeat delay (default = .4 sec)
  if length(rpt) rpt = rpt(1);                    % 1st element is repeat rate (default = 33Hz)
  else           rpt = .03;
  end;
%end function getREPEAT

function s = ctriple(val)                   % convert a 3 element color triple vector to text
  s = strrep(prin(' {%3w!  }',val),' 0.','.'); % remove leading zeros
  if s(1)==' ' s = s(2:end); end;
% end function ctriple

function c = ctrip(v)                       % converts alternate form color triples to standard form
  if ischar(v) c = v;  return; end;         % allow forms such as ['red '; 'blue'] and ('rbk')'
  [s1 s2] = size(v);
  if s1>1 c = [];                           % here if more than one color is specified
          for k = 1:s1  c = [c; ctrip(v(k,:))]; end;
          return;
  end;
  if s2==3
       if max(v)>1 c = v/100; else c = v; end;  % If it's too big, divide by 100
  else v1 = floor(v/10000);  v = v - 10000*v1;  % handle rrggbb decimal form
       v2 = floor(v/100);    v = round(v - 100*v2);
       c = [v1 v2 v];
       c(find(c==1))=100;
       c = c/100;
  end;
% end function ctrip

function set2(h,varargin)  % same as set but ignores invalid handles
  set(h(ishandle(h)),varargin{:});
%end function set2

function b = isequalNaN(x,y)
  x(isnan(x)) = 123456789;
  y(isnan(y)) = 123456789;
  b = isequal(x,y);
% end function isequalNaN

function c = getxy(h)   % get the x and y coordinates of object h
  c = complex(get(h,'x'),get(h,'y'));
%end function getxy

function setxy(h,c)     % set the x and y coordinates of object h
  set(h,'x',real(c),'y',imag(c));
%end function setxy

function v = s2d(s) % replacement for str2double (for speed)
   v = sscanf(s,'%f');
%end function s2d

function v = s2i(s) % replacement for str2double (for speed)
   v = sscanf(s,'%d');
%end function s2i
