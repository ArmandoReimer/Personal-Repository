<html>
<head>
<title>GUI building with plt</title>
<style>
<!--
span.mcode
{ color: #ff0000;
  font-family: 'Lucida Console', 'Andale Mono', 'Courier New', monospace;
  font-size: smaller;
}
span.mcode2
{ color: #ff0000;
  font-family: 'Lucida Console', 'Andale Mono', 'Courier New', monospace;
  font-size: 75% 
}
span.mcode3
{ color: #4040ff;
  font-family: 'Lucida Console', 'Andale Mono', 'Courier New', monospace;
  font-size: smaller;
}
span.cmt
{ color: #4040ff;
  font-size: smaller;
}
-->
</style>
</head>
<body>

<img src="../images/plt.png" width="300" height="160" align="right"></td>
<br><h1>GUI building with plt</h1> <br clear="left">
Over the years I have created dozens of GUIs using Matlab, nearly all of which
involved collecting and/or viewing data and interacting with the data or data collection
process in some way, and I suspect the same is true for the GUIs that you need to create.
The first GUIs I created were quite difficult, but as I built up my bag of tools each
new program became easier and quicker to write. The key I found was to avoid re-inventing
the wheel each time and the best way to do that was to create a series 
of "<font size="+1" color="4040ff">pseudo objects</font>". A pseudo object is a collection
of Matlab graphics objects embedded with features commonly needed in Matlab GUI applications.
(I chose to call them pseudo objects to distinguish them from the graphics objects supplied
in the standard Matlab environment.) These pseudo objects are combined into one file exchange
submission called (for historical reasons) <font color="4040ff">plt</font>. My primary goal for
plt is to make building GUI applications in Matlab easier, faster, and more fun while
enabling you to create clearer, more concise code that is compatible across all Matlab
platforms and versions.
<br><br>
The two main tasks in creating a GUI application are:
<ol>
<li>Choosing the graphical elements and configuring the sizes and positions of these elements.
<li>Writing the code that enables these graphical elements to serve their intended purpose.
</ol>

Matlab's GUI building tools
(<span class="mcode">App Designer</span> since 2016 and <span class="mcode">Guide</span> for older Matlab versions)
helps a lot with the first
task but contributes little to the second. However I've found that for all but the most trivial
applications, the second task accounts for most of the frustrations and time spent. My strategy
is to aid the second task by providing a rich set of the pseudo objects mentioned above.
It may seem like this is a tall order for these new objects, but I hope the examples that
follow will convince you that they can impressively reduce the amount of code you need to write.
The current set of pseudo objects is merely a start. I plan to continue implementing new
pseudo objects ... hopefully many of them conceived by Matlab users such as yourself.
<br><br>
A parallel goal is to make it easier to learn Matlab GUI programming by providing many well
commented examples that demonstrate as many of the pseudo object features as possible. It's
easier to begin a new GUI application by starting with an example that has at least some
of the graphical features that you need. To this end, plt includes 31 example programs
covering a wide variety of GUI features and programming techniques. New example programs
have been steadily added to the list over the years since the first version of plt, often
initiated by questions and requests sent to me by plt users.

Although the standard Matlab plotting and graphical elements are thoroughly documented, a
common complaint is that this information is spread out over thousands of pages of Matlab
documentation making it difficult to find what you are looking for. Also it is difficult
to find examples for most features. This inspired me to design the plt help file to
avoid these pitfalls by organizing plt's many features into one coherent help file including
many examples. Every question from a plt user leads me to reexamine the documentation
to see if I have described each feature and example as completely and clearly as possible.
<br><br>
Although the first task mentioned above (configuring sizes and positions of graphical elements)
is not where most of the time is spent, without an appropriate tool this could be a painstaking
task. Matlab's Guide tool does provide a reasonable solution to this problem however I found
several annoyances with this tool:
<ol>
<li>Guide forces me to adopt a particular programming methodology and style. Although plt
    offers unique pseudo objects you are free to use all or none of them to suit your purpose
    and no demands are made on your programming style. My preferences lean towards conciseness
    and clarity, as you can see from my programming examples.
<li>Guide has evolved over the years and works somewhat differently in different Matlab versions
    which can cause compatibility issues. I often support my Matlab applications for use with older
    Matlab versions, some of which were released even before Guide was invented.
<li>I sometimes find it inconvenient that the program definition is split between the
    .m and .fig files. The .fig file format can also lead to Matlab version dependencies.
    (GUIs designed with plt don't depend on .fig files.)
<li>And most importantly Guide was not compatible with the powerful pseudo objects that I had created.
</ol>

In addition, to the Guide compatibility issues mentioned in point 2 above, the graphics objects
themselves have changed between versions. For example when version R2014b was released, Matlab
finally allowed you to set the grid line color independently (a long requested feature) allowing
you to create far more pleasing plots.
However this won't help when you try to run your program on previous Matlab versions (which in fact
represent a significant fraction of the user base). On the other hand, plt is designed to work the same across
all Matlab versions, so you can share your code with colleagues running older Matlab versions.
I have tested plt on most Matlab releases dating as
far back as June 2001 (Matlab&nbsp;6.1) and of course it works with Matlab's most recent
R2019a version as well. You might think that supporting older versions would limit plt's flexibility,
however as you will see plt generally meets or exceeds the flexibility available with even the
latest native Matlab plot commands (including grid lines of course).
<br><br>
Matlab's newer GUI tool, App Designer, doesn't split the program definition into two files like Guide
does but it doesn't solve the version compatibility issues since it saves the program in a new file
type that can't be used in versions of Matlab older than 2016. Also applications developed with
App Designer often can't be edited using versions of Matlab older than the version used to create
the application.

After abandoning Guide for the above reasons, at first I simply entered position coordinates
by hand, often iterating many times to adjust controls to achieve the desired look. But for
complicated GUIs with many objects, this is too time consuming. This led me to develop a more
automated method of positioning pseudo objects as well as native Matlab objects without using Guide.
This method is not as automated as Guide or App Designer, but I hope you will see from the following
examples that it strikes a good balance between automation, power, and flexibility.

The basic idea was to give plt the the ability to reposition and resize the graphical objects
and to display the results in a way that allows you to copy the positions of all your
objects into your program with a single cut and paste.
<br><br>
Since the pseudo objects are the key innovation that simplifies Matlab GUI programming, let's briefly
summarize the nine pseudo objects that have been implemented so far:
<ul>
<li><font color="4040ff" size="+1"><b>Cursor - </b></font>My goal for the cursor pseudo object was to
    tailor plt for its role in data exploration. The ease and responsiveness of the cursoring,
    panning, and zooming operations is unmatched by any other Matlab plotting package (at
    least according to reports from some plt users). Although you can create cursor pseudo objects
    independently, by default a cursor object is created for you when you define a plt pseudo
    object. This relieves you of the need to know about the many details of the cursor object.
   <li><font color="4040ff" size="+1"><b>Grid - </b></font>In the latest Matlab release (R2014b) you
    can change the grid color using the axis 'gridcolor' property. However as I mentioned earlier,
    using this property will give an error if you run the program on any earlier Matlab release.
    If you are using any release earlier than R2014b, you can see the problem by typing
    <span class="mcode"><nobr>plot(rand(1,100)); grid&nbsp;on;</nobr></span>. and note how the
    grid lines are so overpowering it is hard to see the trace underneath. Now try changing
    the grid line color to something less overwhelming by typing
    <span class="mcode"><nobr>set(gca,'xcolor',[.7 .7 .7],'ycolor',[.7 .7 .7]);</nobr></span>.
    Now the grid lines look pretty nice but the tick labels become so faint you can barely see
    them. (This insanity was an annoyance and embarrassment to Matlab users for at least two
    decades and in fact was one of my motivations for creating the first version of plt a decade ago).
    The plt grid pseudo object gives you even more flexibility than the latest Matlab release by
    allowing you to select the grid color, thickness, line style, and erase mode without
    affecting any other graphic element. As with the cursor pseudo object, you will rarely need
    to define a grid pseudo object explicitly since it is also created by the plt pseudo object.
    The defaults are to most people's liking so you may never need to adjust them.
  <li><font color="4040ff" size="+1"><b>plt - </b></font>This can be thought of a super axis (or
    collection of axes). In that respect it is similar to Matlab's <span class="mcode">plot</span>
    and data is passed to plt in the same way making simple calls to plt look the same as
    the call to plot (except for the missing "o"). However unlike plot, plt also (by default
    anyway) creates:
    <ul>
    <li>a cursor pseudo object.
    <li>a grid pseudo object.
    <li>a menu box containing various plotting controls.
    <li>a TraceID box which serves both as a legend and as a way to enable
            and disable individual traces.
    <li>a menu bar containing the traditional Matlab menus (File,Edit,View,Tools,etc) as
        well as a plt menu containing items unique to plt.
    </ul>
    The plt pseudo object integrates all these elements together in a consistent
    logical manner with the defaults oriented towards the typical data exploration
    needs of the most common graphical interfaces. This allows you to take advantage
    of the plt features in your design even before learning about the many ways to
    tailor plt to your needs. It might seem strange that I use "plt" both as the name
    of this pseudo object as well as the name of the entire toolbox, however I think
    you will find that you can tell which one I'm referring to by context.
<li><font color="4040ff" size="+1"><b>Slider - </b></font>Matlab's slider is the most
    versatile uicontrol because of the many ways you can change the value (dragging
    the slider bar, clicking the left or right arrow, clicking the trough). Plus it
    is the only uicontrol whose action can repeat continuously as you hold down the
    mouse button. This allows you to smoothly vary a parameter over a range while
    observing its effect. However the slider control rarely can stand alone. At a
    minimum you need a label to identify what the control is for and usually you
    also need a more precise representation of the slider value than the slider bar
    itself provides. A text box is often used for this purpose, although an edit box
    is better since it allows a way to set the slider value precisely. It is also
    common to want labels to identify the minimum and maximum values associated with
    the left and right slider bar positions. Furthermore sometimes the slider value
    must be restricted to be an integer or a multiple of some other factor or other
    condition (such as a power of 2 for example). Also you may want to adjust the
    step size for the arrows or trough or to make the steps logarithmically spaced.
    These requirements mean that you usually need to write a lot of code to make
    a slider useful for your application. The pseudo slider solves this problem by
    integrating all the elements and options just mentioned into one object that you
    can simply drop into your application and move around as a unit. All the code you
    need to make it useful is already done for you!
<li><font color="4040ff" size="+1"><b>Edit - </b></font>As mentioned above, the ability
    of the slider and the pseudo slider to respond continuously as the mouse button
    is held down is a powerful feature. The one drawback of these objects is that they
    take up quite a bit of space. For a GUI with many controls, you may not have room to use
    sliders for many of them. The edit pseudo object is the answer to such a problem. It
    takes up even less space than a uicontrol edit box. It doesn't have all the features
    of the pseudo slider, but you can continuously increment its value by holding down
    the mouse on the right side of the object, and likewise decrement its value on the
    left side. Like the pseudo slider, you can select the increment amount as well as
    the min/max limits. The edit object may also be used to contain vectors or strings.
    (The auto-increment features do not apply in that case.) Usually edit objects require a
    label to identify the purpose of the control. The edit pseudo object includes a label
    (optionally) as an integrated feature. When you reposition the edit control, the label
    moves right along with it. One less graphical object to define, size, and position.
    Other advantages over the uicontrol edit box include:
    <ul>
    <li>Auto evaluations
    <li>More flexible formatting
    <li>More powerful callbacks
    <li>Tex interpreter support
    <li>Choice of figure or axis coordinates
    </ul>
    As an example of an Auto evaluation, consider that typing "cos(pi/6)" into the pseudo
    object would set its value to 0.866025 (with fewer or more digits depending on the format code).
    The last point also deserves elaboration. Normally you will want to define the edit pseudo
    object in figure coordinates (what I call a type I edit pseudo object) just as you do
    with a uicontrol. However if you want to associate the object with a plot (so it moves
    with the plot if it is repositioned, or if you want to create an array of edit objects
    it is more convenient to use axis coordinates (i.e. a type II edit pseudo object).
<li><font color="4040ff" size="+1"><b>Popup - </b></font>The popup pseudo object closely
    mimics the function of Matlab's popup uicontrol but has these advantages:
    <ul>
    <li>You can fit twice as many pseudo popups into a given space as uicontrol popups.
	<li>You can cycle through the popup's options without opening the popup by right
        clicking on the object. When you want to see the effect of all the possible
        selections, it is far faster with the pseudo popup than with the uicontrol.
    <li>Optionally swap the role of left & right clicks (super-button mode).
    <li>Integrated label (optional).
    <li>More powerful callbacks.
    <li>Independent control of the location/appearance of the opened and closed view of the popup.
    <li>More flexible formatting.
    <li>Tex interpreter support.
	<li>Ability to open or close the popup from a program.
    </ul>
    Of course uicontrol popups and uicontrol edit boxes may still be used and may be
    preferred when you don't need any of the advantages listed above.
<li><font color="4040ff" size="+1"><b>Image - </b></font>Most of plt's features are tailored
    toward 2D plotting (functions of a single variable). However plt provides two methods
    to plot functions of two variables. One is to use a waterfall plot which makes use of
    the auxiliary function <span class="mcode">pltwater.m</span>. The other method is to use
    the Image pseudo object. The Image pseudo object provides cursoring methods appropriate
    for this object type and also includes several optional components including:
    <ul><li>A color bar which serves as a legend for the z-axis values as well as providing a method
            of changing the colormap used to represent the z data.
        <li>A slider (labeled <b>'edge'</b>) that allows you to control how wide a range around a midpoint
            is used when determining the color used to represent each array element.
        <li>A slider (labeled '<b>'mid''</b>) that allows you to control the center value of the range of values
            used to determine the color for each array element.
        <li>A checkbox that allows you to control the visibility of the axis gridlines.
        <li>A <b>'view all'</b> button, that when clicked on resets the axis limits so that all the data is visible.
            A secondary feature of this button is activated by right-clicking on it instead which zooms in on the center
            of the region currently in view.
    </ul>
<li><font color="4040ff" size="+1"><b>ColorPick - </b></font>Nothing is quite as individual
    as the colors we prefer in our applications, and allowing the user to choose the
    application colors is a true sign that the programmer cares about the user. However
    choosing several colors that have to blend together in a pleasing way is not a simple
    matter and providing a substandard interface for color choice can be more of a curse
    than a blessing. The ColorPick pseudo object was carefully designed to make it as
    easy as possible to give your application this flexibility. I've found it is important
    to present the user with palettes of colors to choose from and have the selected
    objects change instantly when a new choice is made. A very simple example of the use
    of the ColorPick object is given in afilt.m. A more elaborate example is the demoplt.m
    program which also includes the code to save the selected colors in a setup file
    so that the chosen colors remain permanent until changed again.
<li><font color="4040ff" size="+1"><b>HelpText - </b></font>To make our GUIs as easy to
    use as possible, it is nice to show help messages right on the main GUI figure.
    Even if the GUI is complicated enough to need a manual, most people won't read it
    and even if they do, some reminders of the basics when the program starts up can
    be useful. Of course these reminders will quickly become annoying if they get in the
    way or take up valuable screen area that could be better used by the application.
    The HelpText pseudo object was designed to solve this need by making it easy to
    format and position the help messages as well as to make them disappear as soon as
    you start using the GUI. When this pseudo object is created along with the plt pseudo
    object (by using the 'HelpText' parameter), right-clicking on the menu box help tag will
    make the help text reappear, although it is easy to create a dedicated button for that
    purpose if you prefer.
</ul>
A more complete description of these pseudo objects from a programming perspective
can be found here: <a href="Pseudo%20objects.htm">Pseudo objects</a>.
<br><br>
Now you are prepared to dive into the examples that follow:

<h2>A first example (<span class="mcode">gui1.m</span>)</h2>

Our first GUI example doesn't do any plotting or anything else useful for that matter, so it may
not present a compelling case for the GUI tools provided by plt. However since it consists
of just a few dozen lines of code it is simple enough that you can quickly see how to use plt
to arrange graphic elements inside a figure window.
<br><br>
<img src="../images/gui1Sketch.png" align="left" width="400">
I find that it is best to start working on a new GUI with pencil and paper. Imagine
the control types and arrangement for the application and then sketch a mock up such as this.
Your finished application rarely will look much like your first sketch, but with the rapid
prototyping possible with Matlab and plt you can quickly iterate improvements in form,
concept and implementation.
<br><br>
Here I have decided on 3 pseudo sliders across the top followed below by a uitable on the left
and a frame on the right containing 4 uicontrols (a popup, slider, button, and checkbox).
<br><br>
The bottom part of the GUI consists of two large objects for displaying lists of numbers.
The right most one is a simple text box with room to show about 10 lines of text. The left most
one is a listbox which by virtue of its scroll bar can display a far larger data set
(80 lines of text in this example).
<br clear=left><br>
First we create the figure window. I usually start by typing "figure" in the command window
and adjust the figure size to get a first guess. In this example I decide on 430 by 350 pixels.
The menu bar is not needed for such a simple GUI so the menu property is set to 'none'.
I chose a dark blue-green for the figure background:

<span class="mcode"><pre><font size=+1>function gui1()
  figure('name','gui1','menu','none','pos',[150 60 430 350],'color',[0 .1 .2]);</font></pre></span>

The next line defines the choices for the popup menu.
Then we create an array which contains the positions for the three pseudo sliders and the
uitable followed by the positions of the seven uicontrols. Note that the positions of the
three pseudosliders are all the same which means (initially) they will all be on top of each
other. Also note that the uitable and all seven uicontrols all (initially) have the same
position, which means they too will be on top of each other. This is done for simplicity
and as you will soon see will not be a problem because it will be easy to use the mouse to move and
resize the sliders and other controls to an appropriate position.
<span class="mcode"><pre><font size=+1>  cho = {'choice A' 'choice B' 'choice C'}; % choices for popup control
  p = {[.5 .5      ];  % PseudoSlider 1
       [.5 .5      ];  % PseudoSlider 2
       [.5 .5      ];  % PseudoSlider 3
       [.1 .1 .1 .1];  % uitable
       [.1 .1 .1 .1];  % frame
       [.1 .1 .1 .1];  % popup
       [.1 .1 .1 .1];  % slider
       [.1 .1 .1 .1];  % button
       [.1 .1 .1 .1];  % checkbox
       [.1 .1 .1 .1];  % listbox (80 lines)
       [.1 .1 .1 .1]}; % text (10 lines)</font></pre></span>
Next, the three pseudo sliders and the uitable are created.
@CBsli, the last parameter of the slider call, specifies the callback - a function that will be called when the slider value is changed.
Note that we save the handles of these four objects even though we don't really use them. (In a real GUI we would almost always need them.)
<span class="mcode"><pre><font size=+1>  h1 = plt('slider',p{1}, 10,'PseudoSlider 1',@CBsli); <font color="#4040ff" size=+0> % create the pseudo sliders </font>
  h2 = plt('slider',p{2}, 60,'PseudoSlider 2',@CBsli);
  h3 = plt('slider',p{3},800,'PseudoSlider 3',@CBsli); 
  h4 = uitable('units','norm','pos',p{4});             <font color="#4040ff" size=+0> % create the uitable</font>
</font></pre></span>
Since the uitable hadn't been invented yet for Matlab 6, there is an alternate version of gui1.m in
the demo folder called gui1v6.m where this uitable is replaced by a radio button. Of course these two
objects don't serve the same function, but since we aren't worried yet about functionality with this
example, this is not a problem.
<br><br>
Next, let's create all seven uicontrols in a single line while collecting the handles in a variable
named <span class="mcode">h</span>. (A long variable name I know ...) The spaces after the
<span class="mcode">h = </span> are there so that the property
values (style, string, and callback) in the following three lines line up under the respective uicontrol
command. This makes it easier to follow what is going on.
<span class="mcode"><pre><font size=+1>  h =            [uicontrol uicontrol uicontrol uicontrol uicontrol uicontrol uicontrol];
  set(h,{'style'},{'frame' ;'popup';  'slider';'pushb'  ;'checkbox';'listbox';'text';},...
       {'string'},{'frame1'; cho   ;  'slider';'button1';'check001';''       ;''     },...
       { 'callb'},{''      ; @CBpop;  @CBsli  ;@CBpush  ; @CBcheck ;''       ;''     },...
       'backgr',[.5 1 1],'units','norm',{'pos'},p(5:11));</font></pre></span>
Finally we save all 11 handles  in the figure user data so the callbacks can easily find them (h1,h2,h3,h4
followed by the seven uicontrols we just created). This method works fine for such a simple program, but in
the next example we will see the advantages of using a structure for this purpose instead of an array.
We also execute the callback function to initialize the random data tables:
<span class="mcode"><pre><font size=+1>  set(gcf,'user',[h1 h2 h3 h4 h]);  CBsli; <font color="#4040ff" size=+0>% save the handles and execute the slider callback</font></font></pre></span>
That's it for the main function, just 13 lines of code! (not counting the initial position array)
We finish up by writing the control callbacks.
The first three are just stubs to remind us to eventually put some useful action there.
The last one (the slider callback) is the only one that does anything, which is to update the data tables with new random data.
The reason the random numbers are in the exponent is to create numbers with a widely varying magnitude so that the table looks more interesting.
(The same random numbers get put into both the textbox and the listbox).
Note that the random numbers are converted to strings using <span class="mcode">prin</span> a substitute for
<span class="mcode">sprintf</span> that includes features commonly needed in GUI programming.
(<span class="mcode">prin.m</span> and its documentation <span class="mcode">prin.pdf</span> are included with plt.)
<span class="mcode"><pre><font size=+1>function CBpop(a,b)   <font color="#4040ff" size=+0>% popup callback -------------</font>
                      disp('popup callback');
function CBcheck(a,b) <font color="#4040ff" size=+0>% checkbox callback ----------</font>
                      disp('checkbox callback');
function CBpush(a,b)  <font color="#4040ff" size=+0>% button callback ------------</font>
                      disp('pushbutton callback');

function CBsli(a,b)                     <font color="#4040ff" size=+0>% The slider callback -------------------</font>
  h = get(gcf,'user');                  <font color="#4040ff" size=+0>% Get the handle list</font>
  t = 1e20.^(rand(3,80))/1e6;           <font color="#4040ff" size=+0>% Random numbers (with wide dynamic range)</font>
  set(h(10:11),'fontname','courier',... <font color="#4040ff" size=+0>% Use the same random table of numbers</font>
    'string',prin('3{%6V   }~, ',t));   <font color="#4040ff" size=+0>%  for both the listbox and the textbox</font>
  set(h(4),'data',100*rand(3,2));       <font color="#4040ff" size=+0>% More random numbers for the uitable</font>
</font></pre></span>
<br>
<img src="../images/gui1Place1.png" width=238 height=207 hspace=10 vspace=10 align="left"><br>
Now that we are done with the coding, start the GUI by typing <span class="mcode">gui1</span> in the command window.
The figure window on the left will appear. As we mentioned above, the uitable and all seven uicontrols are on top
of each other near the lower left corner, so we only see the last one.
Likewise all three pseudo sliders are also on top of each other in the middle of the figure.
Now its time to fix this problem.
<br><br>
Type <span class="mcode">plt&nbsp;move</span> in the command window
to enable the mouse driven repositioning mode.
<br clear=left>
<img src="../images/gui1Place2.png" width=238 height=207 hspace=10 vspace=10 align="left"><br>
The graphical objects inside the current figure are grayed out to indicate that the repositioning
mode is active. Now we can:
<br><br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; left-click, hold, and drag to move an object.<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; right-click, hold and drag to resizes an object.<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; Double click to open an object's property inspector window.
<br><br>
At the stage shown here we at least have moved and resized all the objects so we can see all the individual items,
none of them overlap, and they are at least close to the positions we outlined in our sketch.
<br clear=left><br>
I notice that the frame is too bright since I intended it to be a subtle grouping. One way to adjust this is
by typing commands into the command window. When in repositioning mode, plt saves the handle of the last object that you
clicked on in a variable named <span class="mcode">hhh</span> in the base workspace. So now you can experiment with colors
or other properties by typing commands such as:
<br><br>
<nobr><span class="mcode">set(hhh,'backgr',[1 1 2]/6,'foregr',[1 1 1]/2);</span>.</nobr>
<br><br>
Once I get the look I want I can copy and paste the command from the command window into the program (right before
the line that saves the handles to the figure userdata):
<br><br>
<nobr><span class="mcode">set(h(1),'backgr',[1 1 2]/6,'foregr',[1 1 1]/2);</span>.</nobr>
<br><br>
Note that I changed the <span class="mcode">hhh</span> to <span class="mcode">h(1)</span> before inserting the line into the program.
<br><br>
Another way of doing this (instead of typing the commands in the command window) is to double click on the
object which will bring up the property inspector for that object. Then as you change the property values
in the inspector you will immediately see the effect on the GUI. (This second method is certainly easier if you
don't know the exact property names for the objects you are working with.)
<br>
<img src="../images/gui1Place3.png" width=238 height=207 hspace=10 vspace=10 align="left"><br>
With a little more rearranging we finally get the look we are aiming for as shown here.
Note that the controls are still grayed out since the repositioning mode is still active.
One thing that you will notice while repositioning objects is that moving the frame also
moves all the objects inside the frame. Unless you have a very old version of Matlab you may
also use a uitable to allow this grouping effect. The main advantage of the uitable is that
you can optionally specify a label for the grouping that will appear along the top edge.
<br><br>
Before exiting the program or canceling the repositioning mode click on each of the graphical
objects once in the order that you created them in the program (left to right and top to bottom in the GUI).
As you are clicking each item, plt will be displaying the positions of the objects in the command window.
When you are done the command window will contain something similar to this:
<br clear=left>
<pre><span class="mcode3">sli: 401  .020 .920 .300     ;  % PseudoSlider 1
sli: 406  .350 .920 .300     ;  % PseudoSlider 2
sli: 411  .680 .920 .300     ;  % PseudoSlider 3
uit: 208  .020 .500 .480 .280;  % uitable
uic: 207  .540 .500 .440 .280;  % frame1
uic: 206  .680 .710 .170 .050;  % choice A
uic: 205  .570 .610 .380 .060;  % slider
uic: 204  .570 .520 .170 .060;  % button1
uic: 203  .780 .520 .170 .060;  % check001
uic: 202  .020 .050 .480 .400;  % 2.0e10   1.3e12   3.5e-4  
uic: 201  .540 .050 .440 .400;  % 2.0e10   1.3e12   3.5e-4  
</span></pre>
The first column is a three letter identifier for the object type. The native Matlab types - uicontrol,
uitable, uipanel, axis, and text are identified as uic, uit, uip, axi, txt respectively and plt's pseudo objects
are identified as sli, edi, pop, and xy. (xy refers to elements created by the cursor and plot pseudo objects.)
The next column is a unique integer associated with the object. We won't need that now, but example 2 will show
how that is used. The next four columns (or three columns for the pseudo sliders) specify the size and position
of each object in normalized units. At the end of the line, the object type or string property of the object is
included as a comment to make it clear which object the line refers to.<br>
<img src="../images/gui1Edit1.png" width=700 height=340 hspace=10 vspace=10 align="left"><br>
Now we are going to make the work we did to reposition the controls permanent by changing the position array
(<span class="mcode">p</span>) from the initial guess to the values that appear in the command window (blue text above).
First cut and paste those 11 lines of coordinates from the command window directly into the gui1.m source code as shown here.
<br clear=left><br>
<img src="../images/gui1Edit2.png" hspace=10 vspace=10 align="left"><br>
Then we use the column select mode of our editor (as pretty much every programmer's editor does)
to remove the initial coordinate estimates, and then
highlight the new positions, and finally pasting the highlighted (yellow) text into the <span class="mcode">p</span> array.
Once that is done, delete the 11 lines that we had pasted in from the command window and now our file
should like the same as the gui1.m file that is included in the demo folder.
<br clear=left><br>
<img src="../demoImages/gui1.png" width=283 height=246 hspace=10 vspace=10 align="left"><br>
Hit save on your editor, close the gui1 figure window, type "gui1" in the command window to
restart it ... and as we hoped the GUI appears just as we had organized it.
Try expanding the size of the figure window and note how all the objects grow in proportion
to the figure size. This is because we used normalized coordinates throughout. If you want to
convert this GUI to pixel coordinates, enter repositioning mode, type
<nobr><span class="mcode">set(findobj(gcf),'units','pix'),</span></nobr> and then
click on every graphics object, again in the same order as they are defined. Again, cut
and paste the coordinates (which now are integer pixels) into the program as we did before.
Also remove the two instances of <nobr><span class="mcode">'units','norm'</span></nobr>
(since pixels is the default when the units aren't specified). When you run it, the GUI will at first
look the same, but when you stretch the figure size, all the objects will stay exactly the same size
in the same position, thus creating empty space inside the figure. Generally you will stick with either
pixels or normalized coordinates, although you can mix them if it suits your purposes.
<br clear=left><br>
This concludes our example, although if this was a real GUI you would not likely be satisfied yet.
But using the methods we just demonstrated you will be able to iterate until you are satisfied
with the control types and positions.
<br clear=left>
<h2>A second example (<span class="mcode">afiltS.m</span>)</h2>
Now that we have covered most of the basic concepts and techniques, its time to explore the true power
of plt by reviewing the design of a real GUI in one of the application areas that Matlab was designed for.
The application I have chosen is the display and analysis of the classical analog filters. Granted this
is not a particularly novel idea as it probably has been done before in Matlab and other languages,
but nonetheless it serves various educational and practical needs and there is always room to apply
our own slant to the project. I'll start out with a relatively modest set of goals:
<ul>
<li>Display the magnitude frequency response for the five "classical" analog filters (Butterworth,
    Bessel, Chebyshev type 1 & 2, and Elliptic). The user should be able to easily select which
    of these filters to display, as well as allowing all of them (or any subset) to be plotted
    at the same time.
<li>Interactive selection of the filter order and type (lowpass, highpass, bandpass, stopband).
<li>Interactive selection of the number of decades to plot as well as the frequency resolution.
<li>Both numerical entry and slider control of cutoff frequencies and pass/stop band ripple.
<li>Cursors should be provided which allow for the easy readout of the frequency response at any
    point as well as delta readouts to verify stop band and pass band ripples. Peak finding
	should be provided as well as the ability to annotate the plot with text and markers
    to document features of interest.
</ul>
<img src="../images/afiltSketch.png" hspace=10 vspace=10 align="left"><br>
As is my habit, I start with a sketch to clarify my thoughts. I decide to use an array of four
pseudo sliders along the top to control the continuously adjustable parameters (edge frequencies & ripple)
The four remaining filter and display parameters are grouped to the left of the sliders inside a
box for visual appeal and to allow those four parameters to be moved around as a group when repositioning.
The Trace IDs to the left of that will be named after the classical filter types and be used to select which
filters to display. The plot and the cursor controls and readouts along the bottom edge are the standard ones
created by the plt pseudo object.
<br><br>
By the way, I've called this program <span class="mcode">afiltS.m</span>
(supplied in the demo folder) where the "S" stands for "Simplified" because it is a simplified version of
<span class="mcode">afilt.m</span> (also in the demo folder) which has several more advanced features.
But of course here we want to start simple.
<br clear=left><br>
Ok ... it's time to start writing code.
First I have to come up with some first guess for the object positions,
and then I define the choices for filter types and number of points to display:
<span class="mcode"><pre><font size=+1>function afilt()
  p = {[.5 .4 .2 .2];  <font color="#4040ff" size=+0>% plot    position</font>
       [.4 .2 .1 .1];  <font color="#4040ff" size=+0>% axis    position: Parameter frame</font>
       [.2 .2 .1 .1];  <font color="#4040ff" size=+0>% edit    position: filter order</font>
       [.2 .3 .1 .2];  <font color="#4040ff" size=+0>% popup   position: filter type</font>
       [.2 .4 .1 .2];  <font color="#4040ff" size=+0>% popup   position: # of decades</font>
       [.2 .5 .1 .2];  <font color="#4040ff" size=+0>% popup   position: # of points</font>
       [.2 .8      ];  <font color="#4040ff" size=+0>% slider  position: Passband ripple</font>
       [.4 .8      ];  <font color="#4040ff" size=+0>% slider  position: Stopband ripple</font>
       [.6 .8      ];  <font color="#4040ff" size=+0>% slider  position: Cutoff frequency</font>
       [.8 .8      ]}; <font color="#4040ff" size=+0>% slider  position: frequency 2</font>
  typ = {'low pass' 'high pass' 'band pass' 'stop band'};  pts = 100*[1 2 4 8 16];
  ftypes = {'Butter' 'Bessel', 'Cheby1'  'Cheby2' 'Elliptic'};
</font></pre></span>
<img src="../images/afiltPlace1.png" width=427 height=336 hspace=10 vspace=10 align="left">
<br>So how good are my guesses?
To find out, let's look at this first screen shot (even though I haven't yet shown you all the code used to create it).
Clearly the guesses are not accurate. The plot is way too small compared to the sketch and
the pseudo popups and edit objects are scattered around and not inside the grey frame meant to contain them.
But as you will see, this will not be a problem. In fact, it would be a waste of time to spend more than a
few minutes coming up with the initial guess. (Even if all the objects were on top of each other, it would
not be difficult to drag them to the desired locations.)
<br clear=left><br>
Ok, now let's continue with the coding by creating the
plotting pseudo object (figure, axis, cursor, grid, traces, etc)
<span class="mcode"><pre><font size=+1>  S.tr = plt(0,zeros(1,5),'TraceID',ftypes,'Options','logX','xy',p{1},...
             'Ylim',[-80 5],'LabelX','radians/sec','LabelY','dB');</font></pre></span>
The <span class="mcode">'xy'</span> parameter is used to position the plot within the figure window
(although you will soon learn that this parameter can do far more than that). The data to be plotted
for all 5 traces is defined in the plt call (as it must), but notice that each trace just contains
the single point (0,0). When calling plt from the command line, you almost always include the actual
plot data in the argument list, however in a GUI more often than not the data supplied is just a
place holder. The real data is loaded later (in the callback in this example) by using the trace
handles returned by plt. Note that we save these handles in <span class="mcode">S.tr</span> (a 1x5 array).
S is the structure where we will store the handles of all the objects we define in the GUI.
The remaining plt parameters should be reasonably self explanatory. Next we create a frame
(actually an axis object) and four pseudo objects that will go inside the frame:

<span class="mcode"><pre><font size=+1>  axes('units','norm','pos',p{2},'box','on','xtick',[],'ytick',[],'color','none',...
       'linewidth',3,'xcolor',[1 1 1]/2,'ycolor',[1 1 1]/2,'tag','frame');
  axes(get(S.tr(1),'parent'));   <font color="#4040ff" size=+0>% reset the main plot axis as the active one</font>
  S.n   = plt('edit',  p{3} ,[6 1 25],'callbk',@clb,'label','Or~der:');
  S.typ = plt('pop',   p{4} ,typ,'callbk',@clb,'index',3,'swap');
  S.dec = plt('pop',   p{5} ,1:5,'callbk',@clb,'index',3,'label','Decades:');
  S.pts = plt('pop',   p{6} ,pts,'callbk',@clb,'index',2,'label','Points:');</font></pre></span>
Note that the tag property of the axis was set to 'frame'. This is to tell plt that
moving the axis in repositioning mode should also move all the objects inside it (even
objects not children of the axis).
The [6 1 25] parameter of the pseudo edit object means that its initial
value will be six with min/max limits of 1 and 25. The string 'Order' is used as a label for
the edit object, but notice that there is a tilde character (~) inserted into that string.
This is to change the amount of space (width) allocated to the label. You might want to experiment
by moving and/or removing the tilde character to see how that effects the label width.
The parameters for the three pseudo popup objects are probably more obvious,
but if not, consult the <a href="Pseudo%20objects.htm">Pseudo objects</a> page.
Next we create the pseudo sliders:

<span class="mcode"><pre><font size=+1>  S.Rp  = plt('slider',p{7} ,[ 2   .01   9],'Passband ripple', @clb);
  S.Rs  = plt('slider',p{8} ,[ 40  10  120],'Stopband ripple', @clb);
  S.Wn  = plt('slider',p{9} ,[.004 .001  1],'Cutoff frequency',@clb,5,'%4.3f 6 2');
  S.Wm  = plt('slider',p{10},[.03  .001  1],'frequency 2',     @clb,5,'%4.3f 6 2');</font></pre></span>
The [2 .01 9] on the first slider has the same meaning as the similar pseudo edit parameter mentioned
above - i.e. 2 is the initial value with min/max limits of .01 and 9. The @clb specifies the callback function.
(Note that same callback function is used for all the controls.) The "5" after the callback function indicates
that the slider will move logarithmically (so for example the slider will move the same number of pixels going from
.01 to .1 as it does when changing from .1 to 1. The final parameter <span class="mcode">'%4.3f&nbsp;6&nbsp;2'</span> is
shorthand for <span class="mcode">'%4.3f&nbsp;%6v&nbsp;%2v'</span> and specifies the display format for the min value,
current value, and max value respectively. Now we have just one more line left to complete the afiltS function:

<span class="mcode"><pre><font size=+1>  set(gcf,'user',S);  clb; <font color="#4040ff" size=+0>% save parameters for clb, and initialize the plot
% end function afiltS</font></font></pre></span>
The set command saves the handle structure in the figure user data where the callback function can easily retrieve it.
The clb command (the last command of the afiltS function) executes the callback function to initialize the display to agree
with the initial values of the controls. After just 16 lines of code, we're finished writing the main line function,
plus 10 more lines for our initial guess for the control positions. But now the real work begins - the
callback function <span class="mcode">clb()</span> that makes the GUI come alive and this will require another 16 lines of code:
<span class="mcode"><pre><font size=+1>function clb() <font color="#4040ff" size=+0>% callback function for all objects</font>
  S = get(gcf,'user');                           <font color="#4040ff" size=+0>% get handle structure</font>
  ty = plt('pop',S.typ);                         <font color="#4040ff" size=+0>% get filter type index</font>
  N   = plt('edit',S.n);                         <font color="#4040ff" size=+0>% get filter order</font>
  dec = plt('pop',S.dec);                        <font color="#4040ff" size=+0>% get number of decades to plot</font>
  pts = str2num(get(S.pts,'string'));            <font color="#4040ff" size=+0>% get # of points to plot</font>
  X   = logspace(-dec,0,pts);                    <font color="#4040ff" size=+0>% X-axis data (radians/sec)</font></font></pre></span>
First we pick up the filter parameters that are inside the gray box (filter type, filter order, number of decades, and number of points).
Finally the logspace command generates the requested number of points
logarithmically spaced between .001 and 1 (for the 3 decades example).
<span class="mcode"><pre><font size=+1>  Wn  = plt('slider',S.Wn);                      <font color="#4040ff" size=+0>% get filter freq</font>
  Rp  = plt('slider',S.Rp);                      <font color="#4040ff" size=+0>% get passband ripple</font>
  Rs  = plt('slider',S.Rs); Rs2 = max(Rp+.1,Rs); <font color="#4040ff" size=+0>% get stopband ripple (must be > passband)</font>
  if ty>2 Wn = [Wn plt('slider',S.Wm)];          <font color="#4040ff" size=+0>% get frequency 2</font>
          plt('slider',S.Wm,'visON');            <font color="#4040ff" size=+0>% make frequency 2 slider visible</font>
  else    plt('slider',S.Wm,'visOFF');           <font color="#4040ff" size=+0>% make frequency 2 slider invisible</font>
  end;</font></pre></span>
Next we pick up the filter parameters from the four pseudo sliders. Note that for the last two filter types (bandpass and stopband)
we need the second frequency slider ("frequency 2") and so this slider is only visible when one of those filter types is selected.
<span class="mcode"><pre><font size=+1>for k=1:5 set(S.tr(k),'x',X,'y',af(k,ty,N,Wn,Rp,Rs,X)); end; <font color="#4040ff" size=+0>% set trace data</font>
  plt('cursor',-1,'xlim',X([1 end]));                        <font color="#4040ff" size=+0>% set Xaxis limits</font>
<font color="#4040ff" size=+0>% end function clb</font></font></pre></span>
The next line of the callback function calls the <span class="mcode">af()</span> function
(which computes the magnitude frequency response) and copies that result to the trace data. Then the
final line uses the plt cursor function to sets the x-axis limits of the display in case the decades
parameter had been modified. The <span class="mcode">af</span> function is not shown here because it is
only computational and doesn't deal with any of the GUI design issues. Refer to that function inside the
<span class="mcode">afiltS.m</span> file if you are interested in the computational details.
<br><br>
We are done with the initial coding and we can try it out. Typing <span class="mcode">afiltS</span> to start
the program brings up the figure shown above. Although all the controls are there as promised, they are not anywhere close
to being in the right place, but it will take only a few minutes to fix this. Begin by entering
"repositioning mode" by right-clicking on the delta button (or if you prefer, by typing
<span class="mcode">plt&nbsp;move</span>.)
<br>
<img src="../demoImages/afiltS.png" hspace=10 vspace=10 align="left">
<br><br>Then as I described in the previous example, use a left
click and drag to move the objects around and a right click and drag to resize them.
Soon we will have all the objects placed in about the right locations based on our original sketch
and the figure will look something like this one. Note that once objects are placed inside the gray frame (axis)
moving the frame will also move all the objects inside it.
<br><br>
Before closing this figure, remember to left-click once on every object in the order that they were created
in our program. As we are doing this, the text below will appear in the command window:
<br clear=left><br>
<span class="mcode"><pre><font size=+1 color="#4040ff"> xy:   1  .125 .105 .800 .760;  % axes
axi:  52  .100 .882 .235 .100;  % axes
edi: 211  .165 .935 .040 .030;  %   6  
pop: 102  .110 .710 .100 .200;  % band pass
pop: 103  .310 .750 .024 .200;  % 3
pop: 104  .287 .710 .054 .200;  % 200
sli: 401  .350 .946 .150     ;  % Passband ripple
sli: 406  .510 .946 .150     ;  % Stopband ripple
sli: 411  .670 .946 .150     ;  % Cutoff frequency
sli: 416  .830 .946 .150     ;  % frequency 2</font></pre></span>
<img src="../images/afiltEdit1.png" hspace=10 vspace=10 align="left"><br>
Then as before, we copy and paste those lines into the source code as shown here. (If you forget to
do this left-clicking sequence on all the objects, you won't be able to copy and paste all the
positions at once as described here. You could still copy and paste each position individually
by finding them in the Matlab command window output stream, but this would be more time consuming.)
<br clear=left><br>
<img src="../images/afiltEdit2.png" vspace=10 align="left"><br>
As we did in the previous example we use the editor's column select mode to do a block move
(as shown by the red arrow) of the new coordinates into the blank array.
<br><br>
We're done with the repositioning step, so we hit save in our editor, restart the application and we
should see the same figure we had before.
<br clear=left><br>
Now we can play with all the controls and make sure everything is behaving as we
imagined. Not bad considering we've written a non-trivial GUI application with so few lines of code.
It's the power of the pseudo objects that allows the program to be written so quickly and concisely. 
<br><br>
Of course what nearly always happens the first time you get to experiment with your GUI is that
you will have some new ideas:
<ul>
    <li>Perhaps this isn't the most convenient set of controls. Would it be more useful to have
        fewer controls, more controls, ... or just different controls?
    <li>Even if the controls seem appropriate, perhaps it would be more esthetically pleasing to rearrange
        and resize them?
    <li>Do we have features that we don't really need? Or can we add useful features without making
        the GUI too complicated?
    <li>Can we rearrange or refactor the code to make it easier to understand and adapt?
</ul>
Indeed after testing <span class="mcode">afiltS</span> I had ideas for the six enhancements described below.
Because of the power of the plt pseudo objects, it didn't take much code to implement these enhancements.
When reviewing the enhancements listed below, you can look at the code in <span class="mcode">afilt.m</span>
(also in the demo folder) to see how each of these new features was implemented.

<h3>1.) Adding a multi-line text string <i>(elliptic transition ratio)</i></h3>

I was curious (mostly for the elliptic filter) how the width of the transition band
(the space between the passband and the stopband) varied as the filter order changed
as well as the four slider parameters. Could I define such a measure, figure out how to
compute it and find a place on the GUI to display it?
<br>
<img src="../images/etr.png" hspace="10" vspace="10" align="left"><br>
For a low pass filter, I characterized the transition width in terms of the ratio of these two frequencies:<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; The frequency where the stop band spec is first achieved<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; divided by the last frequency where the passband spec is still achieved<br>
For a high pass filter, the ratio is:<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; The frequency where the pass band spec is first achieved<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; divided by the last frequency where the stopband spec is still achieved
<br clear=left><br>
I added an additional line to the position array at the beginning of the program, to define the location
for the new text object. As with the other object positions, initially it was just a wild guess which was refined using the
plt repositioning mode.
<br><br>
Once the transition ratio is calculated (saved in the variable <span class="mcode">h</span>) it only takes this one
line to convert it into a multi-line string:
<span class="mcode"><pre><font size=+1>set(S.etr,'string',prin('Elliptic ~, transition ~, ratio: ~, %5v',h));</font></pre></span>
Because the sprintf function does not handle cell arrays, this operation normally would require several awkward
lines of code, but this is simplified by using the <span class="mcode">prin.m</span> supplied in the plt folder.
Learn more about this useful function here: <a href="Auxiliary%20functions.htm">Auxiliary functions</a>.

<h3>2.) Selecting colors</h3>
My second idea was to allow the user to control at least some aspect of the color choices used
in the application. Actually I don't think such a simple application like this really needs
this flexibility, but my ulterior motive was to showcase the ColorPick pseudo object and how
easy it is to add to your GUI and how easy it is to select the color you find most pleasing
for any display element.
<br>
<img src="../images/sliderColor.png" hspace="10" vspace="10" align="left"><br>
This was one of the simplest of the five enhancements requiring just the three extra lines shown below.
I decided to enable color adjustment of just the pseudo sliders (the most prominent controls),
although it would be easy to extend this to other graphic elements. In this figure I have changed
the background color of the sliders from its default gray to orange. I encourage you to play around
with this ColorPick figure. (Just right-click on any of afilt's pseudo sliders to bring up ColorPick.)
If you have ever dealt with the frustrations of assigning screen colors, I think you will be
pleasantly surprised about how easy it can be. Also you can read about the ColorPick details near
the bottom of this page: <a href="Pseudo%20objects.htm">Pseudo objects</a>
<br><br>The first line (below) gets puts the handles of all the objects associated with pseudo sliders
into "h". Then the 5th element of each slider is removed, since that is the edit box portion which
generally is set to a contrasting color. The second line assigns the ColorPick object as the buttondown
function (the action associated with <b>right</b> clicking on the pseudo slider). The third line is
necessary to tell ColorPick which property of these objects should be adjusted when a new color is
chosen (the background color in this example).
<br clear=left><br>
<nobr><span class="mcode"> &nbsp; h = getappdata(gcf,'sli'); &nbsp;h(5:5:end) = [];</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; set(h,'buttondown','plt ColorPick;');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; for k = 1:length(h) setappdata(h(k),'m',{'backgr' h}); end;</span>&nbsp;</nobr>

<h3>3.) Adding the phase display</h3>
<img src="../images/afiltMagPhase.png" hspace="10" vspace="10" align="left"><br>
Since the phase of the frequency response is an important characteristic in some applications, I thought it
would be useful to have the plot show phase as well as amplitude. So far we have only used the left hand axis,
so the easiest way to show the phase information is to plot it on the right hand axis. Usually the right
hand axis is used to superimpose traces on the left hand axis, although in this instance I decided it
would be clearer to plot the phase above the magnitude so the traces would not overlap. That choice allows
us to display both magnitude and phase for all five filter types at once without the display becoming
hopelessly cluttered and confusing. This is accomplished by adjusting the left and right Yaxis limits
so that the magnitude and phase traces don't overlap. The tick mark labels are set explicitly so that they
only appear in the valid range of the display. Here is an example of what the display looks like when a
single filter type (Cheby1) is enabled.
<br><br>
It would have been
natural to expand the TraceID box to include 10 elements instead of 5 however that has the following
drawback. To enable or disable the traces associated with a particular filter type (Cheyb1, for example)
one would have to click on two traceID tags, one for the magnitude and one for the phase. That is somewhat
unnatural and it would be less cumbersome to do this with just a single click. The trick to make this
happen is to link traces 1 and 5 (Butterworth mag/phase) and to link traces 2 and 6 (Bessel mag/phase), etc.
so that 5 is enabled only when trace 1 is enabled, etc. This linking can be done in a single line
inside the call back function, and I will show that line in section 4 below since that enhancement
also involves linking traces.
<br clear=left>

<h3>4.) Adding the pole/zero plot</h3>
<img src="../images/afiltPZplot.png" hspace="10" vspace="10" align="left"><br>
The analog filters are designed by first designing a prototype filter (always low pass) and than transforming
it as selected (high pass, stop band, pass band) with the requested filter cutoff frequencies. Displaying
the roots of the prototype filter in the s-plane can help our understanding of the design and use of the five filter
types displayed by afilt. I could have used plt's <span class="mcode">subplot</span> parameter to create
both plots (Mag/Phase plot on the left and Pole/Zero plot on the right all with a single call to plt.
However because the characteristics of these two plots are so dramatically different, this would have
been difficult and I decided to use a separate call to plt for each of the two plots. This necessitated
using the <span class="mcode">Fig</span> parameter on the second call so that both plots are created
in the same figure window. Like the Mag/Phase plot on the left, the Pole/Zero plot uses 10 traces
(the first 5 to display the zeros for the 5 filter types, and the next 5 to display the poles. Actually
an 11th trace was added to show a unit circle on the plot. A unit circle doesn't have the significance
it does on z-plane plots, but it still provides a useful size reference, and some of the filter types
have roots placed along or near the unit circle. Usually the x/y cursor readout appears below the plot,
but for this plot they were moved to the top because that's where there was the most room (allowing for
a bigger plot in a given figure size). If you enable only the Bessel filter traces, the figure will look
like the one shown here. Note that the Bessel filter has only poles (X's on the plot) where as some of the
filter types will have both poles and zeros (X's and O's).
<br clear=left><br>
This single line was added to the callback function so that if you enabled or disabled the magnitude display
of a certain filter type (butterworth for example) then the associated phase trace, zeros trace and poles trace
would also be appropriately enabled or disabled:
<span class="mcode"><pre><font size=+1>t = plt('show');  t = t(find(t<6));  plt('show',[t t+5 t+10 t+15 21]);
<font color="#4040ff" size=+0> % for traceID callback</font></font></pre></span>
<span class="mcode">t</span> (using the find subscript) will contain a list of magnitude traces that are enabled,
while <span class="mcode">t+5</span> will be a list of the associated phase traces, <span class="mcode">t+10</span>
will be a list of the associated zeros traces, and <span class="mcode">t+15</span> will be a list of the
associated poles traces. Trace 21 (showing the unit circle) is always enabled.
<br><br>
Often when the TraceID callback is a simple one or two line function, it is more convenient to include the entire TraceID
callback in the plt parameter list. Look at the function <span class="mcode">afiltALT.m</span> (an alternate
version of afilt also supplied in the demo folder) for an example of how this is done.
<h3>5.) Saving/restoring the GUI state using a configuration file</h3>
It would be nice if whenever we made a change to the figure size/position or the color
selection, that these changes would be recorded so that the application looks the same
the next time it is restarted. While we are at it, we might as well remember the state
of the eight filter parameters (shown above the plot) so that on start up, the figure
looks identical to the way it was when it was shut down.
<br><br>
To implement this, before the call to plt, let's choose a file name and path for saving the configuration data:
<br><br>
<nobr><span class="mcode"> &nbsp; S.cfg = [which(mfilename) 'at'];</span>&nbsp;</nobr>
<br><br>
Next let's add a new function, called cfg which saves the current configuration to the file:
<br><br>
<nobr><span class="mcode"> &nbsp; function cfg()</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp;
S = get(gcf,'user');  sli = findobj(gcf,'style','slider');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp;
cf = { plt('edit',S.n); &nbsp; &nbsp;&nbsp; plt('pop',S.typ);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
plt('pop',S.dec); &nbsp; &nbsp; plt('pop',S.pts);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
plt('slider',S.Rp); &nbsp;&nbsp;plt('slider',S.Rs);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
plt('slider',S.Wn); &nbsp;&nbsp;plt('slider',S.Wm);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
get(sli(1),'backgr');  get(gcf,'pos') &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp;
save(S.cfg,'cf');</span>&nbsp;</nobr>
<br><br>
Then right before we initialize the plot, we load the configuration file if it exists
and set the GUI elements to agree with the data in the file:
<br><br>
<nobr><span class="mcode"> &nbsp; &nbsp; if exist(S.cfg) load(S.cfg);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
plt('edit',S.n,'value', cf{1});  plt('pop',S.typ,'index',cf{2});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
plt('pop',S.pts,'index',cf{3});  plt('pop',S.dec,'index',cf{4});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
plt('slider',S.Rp,'set',cf{5});  plt('slider',S.Rs,'set',cf{6});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
plt('slider',S.Wn,'set',cf{7});  plt('slider',S.Wm,'set',cf{8});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
set(h,'background',     cf{9});  &nbsp; &nbsp; set(gcf,'position',     cf{10});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; end;</span>&nbsp;</nobr>
<br><br>
And finally we add this parameter to the <span class="mcode">plt</span> call:
<br><br>
<nobr><span class="mcode"> &nbsp; &nbsp; 'closeReq',@cfg</span>&nbsp;</nobr>
<br><br>
This instructs plt to call the function that saves the configuration data when the user closes
the figure window to exit the application.
<h3>6.) Adding temporary user help message</h3>
<img src="../images/afiltHelp.png" hspace="10" vspace="10" align="left"><br>
Finally lets add a very brief set of help messages to allow a new user of the program to
get started without having to consult any help files or manuals. The most important
consideration should be that the help messages are not distracting in any way to the user who
is already familiar with the help information presented. The <b>HelpText</b> pseudo object is
ideal for this task since it provides a mechanism for removing the messages once you start using the program.
<br><br>
To define the help text shown here, these four lines were added to the beginning of the afilt routine:
<br clear="left"><br>
<span class="mcode"><pre><font size=+1>htxt = {'Select the filter order & type' 'in the parameter box above.' '' ...
        'Vary the ripple & frequency' ' parameters using the sliders.' .6+.62i 2i ...
        'pole/zero plot' 1.19+1.06i 'color' 'yellow' 2i ...
        'Prototype filters' '(low pass with' '1 rad/sec cutoff)' 1.16+.98i};</font></pre></span>
Note that we have defined three help strings within the <span class="mcode">htxt</span> cell array,
each delimited by <span class="mcode">2i</span> (which actually may be any complex number).
<ol><li>The first of these strings consists of the 5 lines that appear inside the left hand plot
        (the 3rd line is a blank line). The <span class="mcode">.6+.62i</span> after those five lines indicates
        that the upper left corner of the 5 line help text should be positioned at x = .6 and y = .62
        (normalized coordinates in the magnitude/phase plot axis frame). Since no color was specified, the
        default helptext color was used (orange).
    <li>The second help string consists of just the one line "pole/zero plot" and is positioned at x = 1.19 and y = 1.06
        (again in normalized coordinates in the magnitude/phase plot axis frame). A color (yellow) was specified
        for this string. (Note that instead of the string <span class="mcode">'yellow'</span> we could have used the traditional
        Matlab color triple vector (<span class="mcode">[1 1 0]</span>) or the alternate vector form allowed in plt
        calls (<span class="mcode">[100 100 0]</span>) or by the single number <span class="mcode">010100</span>
        (the most compact way of specifying colors in plt parameters). These alternate ways of specifying colors
        are explained more completely at the top of the <a href="Colors.htm">Colors</a> help section.
    <li>Finally the last help string consists of three lines that appear inside the pole zero plot
        (again using the same reference frame for the xy position as the previous two help strings and again
        using the default orange help string color).
</ol>
Then this line was added at the end of the afilt routine to make the help text visible on the screen:
<br><br>
<nobr><span class="mcode">plt('HelpText','on',htxt);</span>&nbsp; <span class="cmt">% show help text</span></nobr>
<br><br>
And lastly, this line was added to the end of the callback function (clb):
<br><br>
<nobr><span class="mcode">plt('HelpText','off');</span></nobr>
<br><br>
That line insures that as soon as the user starts doing anything with the program, the HelpText will disappear
so that it does not become a distraction.
<br clear="left"><br>
This concludes our discussion of the <span class="mcode">afilt</span> example. Although it might seem like coding this example was
a lot of work, GUI programming is notorious for its complexity, and I believe that if you tried
to implement this application in other programming languages you would be looking at a far larger
effort with source code running into the many hundreds of lines.
<br><br>
To further your education of GUI programming with plt, I especially recommend reviewing the
<span class="mcode">pltsq.m</span> application if you are interested in moving plots (i.e. real-time updating).
Also the<span class="mcode"> curves.m</span>, <span class="mcode">editz.m</span>, <span class="mcode">pltmap.m</span>,
<span class="mcode">julia.m</span>, and <span class="mcode">winplt.m </span>applications are worth reviewing since they each have
a fairly rich GUI design with lots of opportunities for using various plt features in interesting ways.

<h2>SnapTo resolution</h2>
You may have noticed that in repositioning mode, the objects when dragged don't move or resize smoothly,
but rather move in steps of a fixed size. This makes it easier to align related objects and generally
gives a more pleasing result. The default grid size is 100 by 100 which means that there are 100 useable
positions inside the figure in both the x and y directions. This also means that if you are using normalized
coordinates the third decimal place for all position vector elements will be zero. However sometimes you
may want to move objects around with finer precision. The <span class="mcode">SnapTo</span> figure allows you to do that.
<br><br>
There are three ways to bring up the SnapTo figure shown below:
<ol><li>Type <span class="mcode">plt move res</span> in the command window. (This is the only method if you are not using a plot pseudo object).
    <li>First left-click on the delta button, followed by a right click on the same button.
    <li>It's easy to forget the sequence for method two, so you can also go to the plt menu in the menu bar. There you will see the option
	    <i>"Reposition grid size"</i> which will bring up the SnapTo figure.
</ol>

<img src="../images/SnapTo.png" hspace="10" vspace="10" align="left"><br>

The default resolution is usually enough, but if you want finer control, move one or both of these sliders to the right edge (i.e. 200).
This is nearly always enough, although if you like you can type in a number bigger than 200 into either edit box.
Or you can move the slider all the way to the left (i.e. zero) which disables the snap-to feature altogether.

</body>

</html>